The LiteScript Compiler Module
==============================
LiteScript is a highly readable language that compiles to JavaScript.
The LiteScript compiler is written in LiteScript. 

String helpers. Note: if not assigned to dummy, not recognized as 'import'

    var dummy1=require('./string-shims') #.startWith, endsWith
    var dummy2=require('./util') #.startWith, endsWith

/!

    declare Environment
    declare on Environment
        splitImportParameter
        searchModule
        checkExternalCache
        loadFile
        externalCacheSave

    declare on ModuleNode
        addToScope
        exports, required, imported
        importDeclarations

    declare on ASTBase
        toText
        createDeclarations
        body
        toExportObject
        produce

    declare on lexer
        initSource
        outStartNewLine
        outCode
        clear

    declare on outCode
        lines

    declare on fileInfo
        basename
        currentDir

!/        

Dependencies

    var ASTBase = require('./ASTBase')
    var Grammar = require('./Grammar')
    var Lexer = require('./Lexer')
    var Scope = require('./TypeCheck')

    var producerDummy = require('./Producer_js')

----------------
##helper method getMembersFromObjProperties(obj) - Recursive

recursively converts a obj properties in NameDeclarations.
it's used when a pure.js module is imported by 'require'
to convert required 'exports' to LiteScript compiler usable NameDeclarations

    method getMembersFromObjProperties(obj) of Grammar.NameDeclaration

/!

        declare newMember:Grammar.NameDeclaration
!/
        
        var newMember

        if obj instanceof Object
            for prop in Object.keys(obj)
                newMember = me.addMember(prop)
                newMember.getMembersFromObjProperties(obj[prop]) #recursive

        #'protoype' is hidden from Object.keys(obj)
        if obj.prototype
            newMember = me.addMember('prototype')
            newMember.getMembersFromObjProperties(obj.prototype) #recursive



----------------

Project class
=============

A **Project** object acts as the root for a complex AST spanning several related **Modules**

Normally, you launch the project compilation by calling `Project.compile()` on the main module 
of your project. At `Project.compile()` the main module is imported and compiled.

When a `ImportStatement: import IDENTIFIER`, or a `require()` call is found in the module code, 
the *imported/required* "child" module is loaded, compiled **and cached**. 
(is the same logic behind node's 'require' function).

This creates a **tree** of Modules, cached, and recursively parsed on demand.
The Modules dependency tree is the *Project tree*.

Project
-------

    class Project 

/!

      properties
        options, 
        name, basePath, fileInfo
        moduleCache
        root: Grammar.NameDeclaration
        compilerVars: Grammar.NameDeclaration
        lexer 
        Producer
        recurseLevel

!/

      method initialize(basePath, options)

/!

        declare root:Grammar.NameDeclaration
        declare valid root.scope.addMember

        declare functionPrototype:Grammar.NameDeclaration

        declare valid me.root
        declare valid me.recurseLevel

        declare on options
            target, debug

        declare valid global.debugOptions.enabled

!/

        if no options
            options = {}
        if no options.target 
            options.target='js'

        if no options.debug
            global.debugOptions.enabled = false

Initialize this project. Receives compiling options
Project has a cache for required modules. As with node's `require` mechanism, a module, 
when imported/required is only compiled once and then cached.
    
        me.name = 'Project'
        me.basePath = basePath
        me.options = options
        me.moduleCache = {}

        me.fileInfo = 
            dirname: "."
            moduleName: me.name

Create the "root" node (a NameDeclaration) to hold the globalScope and all modules. 
All modules are children of "root".

        var root = new Grammar.NameDeclaration(me)
        root.name = "Root Node"
        root.createScope() #"scope" in "root" is the global scope

        #Initialize global scope
        var objectPrototype = root.addBuiltInClass('Object')
        var stringPrototype = root.addBuiltInClass('String',objectPrototype)
        var functionPrototype = root.addBuiltInClass('Function',objectPrototype)
        var booleanPrototype = root.addBuiltInClass('Boolean',objectPrototype)
        functionPrototype.addMember('name',{type:stringPrototype})
        functionPrototype.addMember('apply')
        functionPrototype.addMember('bind')
        functionPrototype.addMember('call')

        root.addBuiltInClass('Array',objectPrototype)
        root.addBuiltInClass('Number',objectPrototype)
        root.addBuiltInClass('RegExp',objectPrototype)

        root.addBuiltInClass('JSON',objectPrototype)
        root.addBuiltInClass('Error',objectPrototype)

        root.scope.addMember 'true',{type:booleanPrototype, value:true}
        root.scope.addMember 'false',{type:booleanPrototype, value:false}
        root.scope.addMember 'undefined',{type:booleanPrototype, value:undefined}
        root.scope.addMember 'null',{type:booleanPrototype, value:null}
        root.scope.addMember 'require',{type:functionPrototype}
        root.scope.addMember 'debugger',{type:functionPrototype}

        var globalType = root.addMember('prototype')
        root.addBuiltInClass('global',globalType) 
        root.addBuiltInClass('GLOBAL',globalType) 

        me.root = root

in 'options' we receive also the target code to generate. (default is 'js')
Now we load the **Producer** module for the selected targent code.
The **Producer** extends Grammar classes adding a `produce()` method
which generates target code for the AST class. Example: [Producer_js.lite.md]
    
        me.Producer = require('./Producer_'+options.target)


## Project.importModule - Recursive

      method importModule(importingModule, importParameter)

The importModule method receives a `importParameter` string, 
the raw string passed to `import/require` statements,
with the module to load and compile.

*Return*: a ModuleNode AST Class instance (from local cache, external cache or as a result of compilation)

/!

        declare valid me.root
        declare valid me.recurseLevel

        declare moduleNode:Grammar.Module
        declare valid moduleNode.fileInfo
        declare valid moduleNode.exports
        declare valid moduleNode.required
        declare valid moduleNode.imported

        declare valid me.recurseLevel

        declare contents:string
    
        declare fileInfo
        declare on fileInfo
            importParameter #: raw string passed to import/require
            dirname #: path.dirname(importParameter)
            extension #: path.extname(importParameter)
            moduleName #: clena module name, no path no extension
            notLite #: true is extension is not '.lite'|'.lite.md' 
            filename #: found full module filename
            outFilename #: output file for code production
            outExportRequired #: output file for export members cache
            outExportRequiredExists #: if outExportRequired file exists

        declare valid importingModule.fileInfo.dirname
!/

Determine the full module filename. Search for the module in the environment.

        me.recurseLevel+=1
        var indent = String.spaces(me.recurseLevel*2)
        #print String.spaces(me.recurseLevel*2),"'#{importingModule.name}' imports module: '#{importParameter}'"
        print ""
        print indent,"module '#{importingModule.name}' imports '#{importParameter}'"

        var fileInfo = Environment.searchModule(importParameter, me.basePath, importingModule.fileInfo.dirname)

Before compiling the module, check internal, and external cache
Check Internal Cache: if it is already compiled, return cached Module node

        if me.moduleCache.hasOwnProperty(fileInfo.filename)
            print indent,'cached: ',fileInfo.filename
            me.recurseLevel-=1
            return me.moduleCache[fileInfo.filename]

It isn't on internal cache, 
then create a **new Module**.
and then create a **new lexer** for the Module 
(each module has its own lexer. There is one lexer per file)

        var moduleNode = new Grammar.Module(me.root)
        moduleNode.lexer = new Lexer()

        moduleNode.name = fileInfo.moduleName
        moduleNode.fileInfo = fileInfo

/!

        declare on moduleVar
            addMember
!/

create the module scope
create two local scope vars: 
'module' and 'exports = module.exports'
'exports' will hold all exported members 

        moduleNode.createScope()
        var moduleVar = moduleNode.addToScope('module')
        moduleNode.exports = moduleVar.addMember('exports') #first, as member of 'module'
        moduleNode.addToScope(moduleNode.exports) #second reference as scope var 'exports'

add other common built-in members of var 'module'. http://nodejs.org/api/modules.html#modules_module_id

        moduleVar.addMember 'filename',{value:fileInfo.filename}
        moduleVar.addMember 'parent'

Also, register every `import/require` in this module body, to track dependency.
We create a empty `.required[]` to keep track of every other importe/require '**importParameter**'
and also a empty `.imported[]` to hold the **imported AST Module node**

        moduleNode.required=[]
        moduleNode.imported=[]

early add to local cache, to cut off circular references

        me.moduleCache[fileInfo.filename] = moduleNode

if it is not a lite file, require the module, get the exported vars
(it can be a pure-js module required)

        if fileInfo.notLite
            print indent,'non-Lite module: ',fileInfo.filename

            var contents = Environment.loadFile(fileInfo.filename)
            Environment.externalCacheSave(fileInfo.outFilename, contents)
            contents=undefined

            if fileInfo.extension is '.js'
                print indent,"require('#{fileInfo.importParameter}')"
                moduleNode.exports.getMembersFromObjProperties(require(fileInfo.importParameter))

            me.recurseLevel-=1
            return moduleNode 

/!

        declare valid me.options.force
!/

        #EXTERNAL CACHE DISABLED - beta
        if true or me.options.force #do not use cache, delete files
            Environment.externalCacheSave(fileInfo.outFilename)
            Environment.externalCacheSave(fileInfo.outExportRequired)

        else
Check External Cache:

If the module is already compiled and cached in external cache (disk)
We just retrieve externally cached members and the list of required modules, 
to continue with the dependency tree

            if Environment.checkExternalCache(fileInfo, me.options)

                print indent,'cached (external): ', fileInfo.outFilename

Get cached members

                var declarationsContent = Environment.loadFile(fileInfo.outExportRequired)
                var declarationsCache = JSON.parse(declarationsContent)

/!

                declare on declarationsCache
                    exported,required

!/

exported names goes to moduleNode.exports

                moduleNode.exports.importMembersFromArray(declarationsCache.exported)

Import the required modules, walk the dependency tree

                moduleNode.required = declarationsCache.required
                for requiredParam in moduleNode.required
                    me.importModule(moduleNode,requiredParam)                
            
and return the node, since it does not need compilation

                me.recurseLevel-=1
                return moduleNode 

            #end if - external cache

        #end if - force

If we have reached here, we need to compile the source. 'to compile' a module means: 
Load source -> Lexer/Tokenize -> Parse/create AST -> Produce target code -> cache

        print indent,'compile: ',fileInfo.filename

set Lexer source: Load source code

        moduleNode.lexer.initSource( fileInfo.filename, Environment.loadFile(fileInfo.filename) )

Tokenize and parse source

        moduleNode.parse()

prepare out buffer

        moduleNode.outCode.start()

produce target code 

        moduleNode.body.produce()

Get the produced code

        var resultLines = moduleNode.outCode.getResult()

add to external cache (save to disk)
Note: convert exports NameDeclarations to a simpler object structure for JSON & cache

        Environment.externalCacheSave(fileInfo.outFilename,resultLines)

        var exportedArray = moduleNode.exports.toExportArray()
        var cacheContents = JSON.stringify({required:moduleNode.required, exported:exportedArray},null,2)
        Environment.externalCacheSave(fileInfo.outExportRequired,cacheContents)

and return the Module node

        print ""
        print indent,'compiled:', fileInfo.filename
        print indent, resultLines.length,'lines ->', fileInfo.outFilename

        me.recurseLevel-=1
        return moduleNode 

    #end importModule


##Project.startCompilation (mainModuleName)

      method startCompilation(mainModuleName,options)

        if no options
            options={debug:false}

        print "Base Path: #{me.basePath}"

compiler vars, usable at conditional compile

        me.compilerVars = me.root.declareName('Compiler Vars')

        #print me.compilerVars.toText()
        me.compilerVars.addMember('debug',{value:options.debug or false})
        me.compilerVars.addMember('mainModule',{value:mainModuleName})
        print me.compilerVars.toText()
        print ""

Import the main module. The main module will trigger import/require on the dependency tree

        me.recurseLevel = 0
        me.importModule(me, mainModuleName)

After importing mainModuleName, if no errors occurred, 
mainModuleName and all its dependencies, will be compiled in 
the output dir: './out/debug'

      #end Project.importModule


##levelIndent

      method levelIndent()
        return ""

Compiler.compile
================

The 'compile' function will import and compile the main Module of a project. 
The compilation of the main module will trigger import and compilation of all its "child" modules 
(dependency tree is constructed by `import`/`require` between modules)

    exports.compile = function(basePath, mainModuleName, options)

/!

        declare window
        declare valid window.Environment
        declare valid global.Environment
!/

First create a 'Environment' for the compiler to use.
The global 'Environment' object, must provide functions to load files, search modules, 
and a optional external cache (disk). 
The `Environment` abstraction allows us to support compile on server(node) or the browser.

        if typeof window is 'undefined' #in node
            global.Environment = require('./node-environment-support.js')
        else
            window.Environment = require('./browser-environment-support.js')

Create a 'Project' to hold the main module and dependency tree.

        var project = new Project(basePath,options)

Now call `importModule` on the main module
and store the result in me.main

The main module is the root of the module dependency tree, and can reference
another modules via import/require.

We 'import' the main module, which in turn will 'import' and 'compile' -if not in cache-, 
all the modules in the dependency tree.

        project.startCompilation(mainModuleName)

After project compilation, if no errors occurred, 
mainModuleName and all its dependencies, will be compiled in 
the output dir: './out/debug'

        return project
        
    #end compiler.compile

