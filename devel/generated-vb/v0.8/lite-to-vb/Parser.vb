'Generated by LiteScript compiler v0.8.9, source: Parser.lite.md
' -----------
Module Parser
' -----------
'=================

'The main class in this module is the Lexer.

'The Lexer translates code (an array of lines) into an array of tokenized lines to be parsed.

'The Lexer class acts as
'* Lexer/Tokenizer
'* Token Stream (input)

'All the parts of the lexer work with "arrays" of lines.
'(instead of a buffer or a large string)

'The first lexer pass analyzes entire lines.
'Each line of the array is classified with a 'Line Type': CODE, COMMENT or BLANK

'then each CODE line is *Tokenized*, getting a `tokens[]` array

'-------------------------
'### dependencies

    'import
        'ControlledError, GeneralOptions
        'logger, fs, mkPath

    'shim import Map, PMREX
    'var ControlledError = require('./lib/ControlledError.vb');
    'var GeneralOptions = require('./lib/GeneralOptions.vb');
    'var logger = require('./lib/logger.vb');
    'var fs = require('fs');
    'var mkPath = require('./lib/mkPath.vb');

    'shim import Map, PMREX
    'var Map = require('./interfaces/Map.vb');
    'var PMREX = require('./interfaces/PMREX.vb');

    '//ifdef PROD_JS
    '////if we're creating a compile-to-js compiler
    '//import SourceMap
    '//endif

'module vars

    'var preprocessor_replaces: map string to string
    Dim preprocessor_replaces = Nothing

    '//ifdef PROD_C
    '//var COMMENT_START="//"
    '//endif
    '//ifdef PROD_JS
    '//var COMMENT_START="//"
    '//endif
    '//ifdef PROD_VB
    'var COMMENT_START="'"
    Dim COMMENT_START = "'"
    '//endif


'The Lexer Class
'===============

    '    public class Lexer
    ' constructor
    Class Lexer
        Public Property project as Object
         Public Property filename as String' mainType: String  
     
         Public Property options as GeneralOptions' mainType: GeneralOptions  
     
         Public Property lines as Array' mainType: Array  ' itemType: String
     
         Public Property infoLines as Array' mainType: Array  ' itemType: InfoLine
     
         Public Property line as String' mainType: String  
     
         Public Property indent as Object
         Public Property lineInx as Object
         Public Property sourceLineNum as Object
         Public Property infoLine as Object
         Public Property token as Object
         Public Property index as Object
         Public Property interfaceMode as Boolean' mainType: Boolean  
     
         Public Property stringInterpolationChar as String' mainType: String  
     
         Public Property last as LexerPos' mainType: LexerPos  
     
         Public Property hardError as Error' mainType: Error  
     
         Public Property softError as Error' mainType: Error  
     
         Public Property outCode as OutCode' mainType: OutCode  
     
    
    Sub New(project, options)

          '//.compiler = compiler #Compiler.lite.md module.exports
          '.project = project #Compiler.lite.md class Project
          Me.project = project

'use same options as compiler

          '.options = options
          Me.options = options

          'default options.browser = undefined
          if ismissing(options.browser) then options.browser=undefined: end if
          'default options.comments = 1 #comment level
          if ismissing(options.comments) then options.comments=1: end if

          'preprocessor_replaces = map
              'DATE: .options.now.toDateString()
              'TIME: .options.now.toTimeString()
              'TIMESTAMP: .options.now.toISOString()

'stringInterpolationChar starts for every file the same: "#"
'can be changed in-file with `lexer options` directive

          '.stringInterpolationChar = "#"
          preprocessor_replaces = new Dictionary(Of String,Object) from {
              {DATE,Me.options.now.toDateString()}
              , {TIME,Me.options.now.toTimeString()}
              , {TIMESTAMP,Me.options.now.toISOString()}
              }

'stringInterpolationChar starts for every file the same: "#"
'can be changed in-file with `lexer options` directive

          '.stringInterpolationChar = "#"
          Me.stringInterpolationChar = "#"

          '.hardError = null # stores most significative (deepest) error, when parsing fails
          Me.hardError = null

'clear out helper

          '.outCode = new OutCode() #helper class
          Me.outCode = new OutCode()
          '.outCode.start .options
          Me.outCode.start(Me.options)

'we start with an empty Token

          '.token = new Token()
          Me.token = new Token()
     end function
    
     ' ---------------------------
     Public Function reset ()

        '.sourceLineNum = 0
        Me.sourceLineNum = 0
        '.lineInx=0
        Me.lineInx = 0
        '.lines=[]
        Me.lines = new ArrayList
        '.setPos .last
        Me.setPos(Me.last)
     end function
     ' ---------------------------
     Public Function initSource (filename, source)
'Load filename and source code in the lexer.
'First, remember filename (for error reporting)

          '.filename = filename
          Me.filename = filename
          '.interfaceMode = filename.indexOf('.interface.') isnt -1
          Me.interfaceMode = filename.indexOf(".interface.") <> -1

'create source lines array

          'if source instanceof Array
          if TypeOf source is Array Then
          
            '.lines = source
            Me.lines = source
          
          'if source instanceof Array
          
          else
          

'If code is passed as a buffer, convert it to string
'then to lines array

            'if typeof source isnt 'string', source = source.toString()
            if TypeOf source <> "string" Then source = source.toString()

            '.lines = source.split('\n')
            Me.lines = source.split("\n")
            '.lines.push "" # add extra empty line
            Me.lines.push("")
          
          End if
          
     end function
     ' ---------------------------
     Public Function preParseSource ()
'read from .sourceLines and
'prepares a processed infoLines result array

        'var infoLines = []
        Dim infoLines = new ArrayList

'Loop processing source code lines

        'var lastLineWasBlank=true, inCodeBlock=false
        Dim lastLineWasBlank = true, inCodeBlock = false

        '.sourceLineNum = 0
        Me.sourceLineNum = 0
        'do while .nextSourceLine()
        Do whileMe.nextSourceLine()
        

'get line indent, by counting whitespace (index of first non-whitespace: \S ),
'then trim() the line

            'var line = .line
            Dim line = Me.line
            'var indent = line.countSpaces()
            Dim indent = line.countSpaces()
            'line = line.trim()
            line = line.trim()

'LiteScript files (.lite.md) are "literate" markdown code files.

'To be considered "code", a block of lines must be indented at least four spaces.
'(see: Github Flavored MarkDown syntax)

'The exception are: MARKDOWN TITLES (###) introducing classes, methods and functions.

'* MarkDown level 3 title plus a space '### ' is considered CODE indented 4 spaces if
  'the line starts with: `[public|export|only|helper|namespace] [class|function|append to]`

'* MarkDown level 4 title plus one space '#### ' is considered CODE indented 5 spaces if:
  '* the line starts with: `[constructor|method|properties`]

'Anything else starting on col 1, 2 or 3 is a literate comment, MD syntax.

'Now, process the lines with this rules

            'var type
            Dim type = Nothing

'a blank line is always a blank line

            'if no line
            if Notline Then
            
                'type = LineTypes.BLANK
                type = LineTypes.BLANK
            
            'if no line
            
            else
            
                'if indent >= 4
                if indent >= 4 Then
                
                    'if lastLineWasBlank,inCodeBlock = true
                    if lastLineWasBlank Then inCodeBlock = true
                
                'if indent >= 4
                
                else
                
                    'inCodeBlock = false
                    inCodeBlock = false

                    'if indent is 0 and line.charAt(0) is '#' //starts on column 1, with a '#'
                    if indent = 0 AndAlso line.charAt(0) = "#" Then
                    

'checkTitleCode: if found a vlid title-code, rewrite the line,
'replacing MarkDown title MD hashs (###) by spaces and making keywords lowercase

                        'if .checkTitleCode(line) into var converted
                        Dim converted as Object
                        if Assign(converted,Me.checkTitleCode(line)) Then
                        

                            'line = converted
                            line = converted
                            'indent = line.countSpaces() //re-calc indent
                            indent = line.countSpaces()
                            'inCodeBlock = indent>=4
                            inCodeBlock = indent >= 4
                        
                        End if
                        
                    
                    End if

                    'end if startted with #

                'end if - line, check indent
                    
                
                End if

                'end if - line, check indent

'After applying rules: if we're in a Code Block, is CODE, else is a COMMENT

                'if inCodeBlock
                

'After applying rules: if we're in a Code Block, is CODE, else is a COMMENT

                'if inCodeBlock
                if inCodeBlock Then
                

                    'if line.startsWith("#") or line.startsWith("//") # CODE by indent, but all commented
                    if line.startsWith("#") OrElse line.startsWith("//") Then
                    
                      'type = LineTypes.COMMENT
                      type = LineTypes.COMMENT
                    
                    'if line.startsWith("#") or line.startsWith("//") # CODE by indent, but all commented
                    
                    else
                    
                      'type = LineTypes.CODE
                      type = LineTypes.CODE
                    
                    End if
                    
                
                'if inCodeBlock
                
                else
                
                    'type = LineTypes.COMMENT
                    type = LineTypes.COMMENT
                
                End if
                
            
            End if
                '#end if

            '#end if line wasnt blank

'parse multi-line string (triple quotes) and convert to one logical line:
'Example result: var a = 'first line\nsecond line\nThird line\n'

            '#saver reference to source line (for multiline)
            'var sourceLineNum = .sourceLineNum
            Dim sourceLineNum = Me.sourceLineNum

            'if type is LineTypes.CODE
            if type = LineTypes.CODE Then
            
                'line = .preprocessor(.parseTripleQuotes( line ))
                line = Me.preprocessor(Me.parseTripleQuotes(line))
            
            End if

'check for multi-line comment, C and js style //.... 
'then check for "#ifdef/#else/#endif"

            'if .checkMultilineComment(infoLines, type, indent, line )
            if Me.checkMultilineComment(infoLines, type, indent, line) Then
            
                'continue #found and pushed multiline comment, continue with next line
                continue
            
            'if .checkMultilineComment(infoLines, type, indent, line )
            
            elseif Me.checkConditionalCompilation(line) Then
            
                'continue #processed, continue with next line
                continue
            
            End if
            End if

'Create infoLine, with computed indent, text, and source code line num reference

            'var infoLine = new InfoLine(this, type, indent, line, sourceLineNum )
            Dim infoLine = new InfoLine(Me, type, indent, line, sourceLineNum)
            'infoLine.dump() # debug
            infoLine.dump()

            'infoLines.push infoLine
            infoLines.push(infoLine)

            'lastLineWasBlank = type is LineTypes.BLANK
            lastLineWasBlank = type = LineTypes.BLANK
        
        Loop

'now we have a infoLine array, tokenized, ready to be parsed
'if we do not need to produce comments with original source
'for reference at produced .c or .js, clear source lines from memory

        'if no .options.comments
        if NotMe.options.comments Then
        
            '.lines = undefined
            Me.lines = undefined
        
        End if

        'return infoLines
        return infoLines
     end function
     ' ---------------------------
     Public Function checkTitleCode (line)

'check for title-keywords: e.g.: `### Class MyClass`, `### export Function compile(sourceLines:string array)`

        '//var titleKeyRegexp = /^(#)+ *(?:(?:public|export|only|helper)\s*)*(class|namespace|append to|function|method|constructor|properties)\b/i

        '// fast exit
        'if line.slice(0,3) isnt "###", return  // should be at least indent 4: '### '
        if line.slice(0, 3) <> "###" Then return

        'var sharps = PMREX.whileRanges(line,"#")
        Dim sharps = PMREX.whileRanges(line, "#")
        'var indent = sharps.length
        Dim indent = sharps.length

        '// get spaces after ###...
        'var spaces = PMREX.whileRanges(line.slice(sharps.length)," ")
        Dim spaces = PMREX.whileRanges(line.slice(sharps.length), " ")
        'indent += spaces.length
        indent += spaces.length

        'var words = line.slice(indent).split(" ")
        Dim words = line.slice(indent).split(" ")


        '// count adjectives
        'var adjectives = ["public","export","only","helper","global"]
        Dim adjectives = new ArrayList From {"public", "export", "only", "helper", "global"}

        'var inx=0, countAdj=0, countSust=0, sustLeft=1
        Dim 
            inx = 0
            , countAdj = 0
            , countSust = 0
            , sustLeft = 1
        'while inx<words.length
        Do whileinx < words.length
        

            'if words[inx] //skip empty items
            if words(inx) Then
            

                'if words[inx].toLowerCase() in adjectives
                if adjectives.Contains(words(inx).toLowerCase()) Then
                
                    'countAdj++ //valid
                    countAdj++
                
                'if words[inx].toLowerCase() in adjectives
                
                else
                
                  'break //invalid word
                  break
                
                End if
                
            
            End if

            'inx++ //next
            inx++
        
        Loop

        'if no countAdj and inx<words.length-1
        if NotcountAdj AndAlso inx < words.length - 1 Then
        
            'if words[inx].toLowerCase() is 'append'
            if words(inx).toLowerCase() = "append" Then
            
                'inx++ //skip 'append'
                inx++
                'if words[inx] is 'to', inx++ //skip to
                if words(inx) = "to" Then inx++
            
            End if
            
        
        End if

        '// get first sustantive
        'var sustantives = ["class","namespace","function","method","constructor","properties"];
        Dim sustantives = new ArrayList From {"class", "namespace", "function", "method", "constructor", "properties"}

        'while inx<words.length
        Do whileinx < words.length
        

            'if words[inx] into var w:string //skip empty items
            Dim w as Object
            if Assign(w,words(inx)) Then
            

                '// word contains a "(", split the word at the "("
                'if w.indexOf('(') into var posParen isnt -1
                Dim posParen as Object
                if Assign(posParen,w.indexOf("(")) <> -1 Then
                
                    '//split at "(", create two words
                    'words.splice inx,1, w.slice(0,posParen), w.slice(posParen)
                    words.splice(inx, 1, w.slice(0, posParen), w.slice(posParen))
                    'w = words[inx]
                    w = words(inx)
                
                End if

                'if w.toLowerCase() in sustantives
                if sustantives.Contains(w.toLowerCase()) Then
                
                    'countSust++ //valid
                    countSust++
                    'break //exit, sustantive found
                    break
                
                'if w.toLowerCase() in sustantives
                
                else
                
                    'break //invalid word
                    break
                
                End if
                
            
            End if

            'inx++ //next
            inx++
        
        Loop

        'if countAdj>1 and no countSust, .throwErr "MarkDown Title-keyword, expected a sustantive: #{sustantives.join()}"
        if countAdj > 1 AndAlso NotcountSust Then Me.throwErr("MarkDown Title-keyword, expected a sustantive: " + (sustantives.join()))

        'if countSust
        if countSust Then
        

            'for recogn=0 to inx //each recognized word, convert to lowercase
            for recogn As Integer =0recogn to inx
                'words[recogn]=words[recogn].toLowerCase()
                words(recogn) = words(recogn).toLowerCase()
            
            Next

            'return String.spaces(indent) + words.join(' ') // re-join
            return String.spaces(indent) + words.join(" ")
        
        End if
        
     end function
     ' ---------------------------
     Public Function tokenize ()

'*Tokenize CODE lines

'Now, after processing all lines, we tokenize each CODE line

        'logger.debug "---- TOKENIZE"
        logger.debug("---- TOKENIZE")

        'for each item in .infoLines
        For Each item in Me.infoLines
        

            'try
            try 
            

                'item.dump() # debug
                item.dump()

                'if item.type is LineTypes.CODE
                if item.type = LineTypes.CODE Then
                
                    'item.tokenizeLine(this)
                    item.tokenizeLine(Me)
                
                End if
                'end if

            'catch err
                
            
            Catch err
                '//adds position info
                'throw new ControlledError("#{.filename}:#{item.sourceLineNum}:1 #{err.message}")
                Throw new ControlledError("" + Me.filename + ":" + item.sourceLineNum + ":1 " + err.message)
            
            End try
            
        Next'  each in Me.infoLines

        'end loop code lines

'reset Lexer position, to allow the parser to start reading tokens

        '.lineInx = -1 #line index
        

'reset Lexer position, to allow the parser to start reading tokens

        '.lineInx = -1 #line index
        Me.lineInx = -1
        '.infoLine = null #current infoLine
        Me.infoLine = null
        '.index = -1 #token index
        Me.index = -1

        '.last = .getPos() #last position
        Me.last = Me.getPos()

'read first token

        '.nextToken()
        Me.nextToken()
     end function
     ' ---------------------------
     Public Function preprocessor (line)

'This is a very simple preprocessor.
'Here we search for simple macros as __DATE__, __TIME__ , __TTMESTAMP__

        'for each macro,value in map preprocessor_replaces
        for Each item in preprocessor_replaces
            Dim macro as string = item.key
            Dim value=item.value
        
            'line=line.replaceAll("__#{macro}__",value)
            line = line.replaceAll("__" + macro + "__", value)
        Next'  for each item in map

        'return line
        return line
     end function
     ' ---------------------------
     Public Function process ()

'Analyze generated lines.

'preParseSource() sets line type, calculates indent,
'handles multiline string, comments, string interpolation, etc.

      '.infoLines = .preParseSource()
      Me.infoLines = Me.preParseSource()

'Tokenize final lines

      '.tokenize
      Me.tokenize()
     end function
     ' ---------------------------
     Public Function nextSourceLine ()

'returns false if there are no more lines

        'if .sourceLineNum >= .lines.length
        if Me.sourceLineNum >= Me.lines.length Then
        
            'return false
            return false
        
        End if

'get source line, replace TAB with 4 spaces, remove trailing withespace and remove CR

        '.line = .lines[.sourceLineNum].replaceAll("\t",'    ').trimRight().replaceAll("\r","")
        Me.line = Me.lines(Me.sourceLineNum).replaceAll("\t", "    ").trimRight().replaceAll("\r", "")
        '.sourceLineNum++ # note: source files line numbers are 1-based
        Me.sourceLineNum++

        'return true
        return true
     end function
     ' ---------------------------
     Public Function replaceSourceLine (newLine)
        '.lines[.sourceLineNum-1] = newLine
        Me.lines(Me.sourceLineNum - 1) = newLine
     end function
     ' ---------------------------
     Public Function parseTripleQuotes (line)

'This method handles `"""` triple quotes multiline strings
'Mulitple coded-enclosed source lines are converted to one logical infoLine

'Example:
'
' var c = """
'   first line
'   second line
'   That's all
'   """.length
'
'gets converted to:
'<pre>
'  var c = 'first line\nsecond line\nThat\'s all\n'.length
'  ^^^^^^^   ^^^^^^^                               ^^^^^
'    pre    |- section                          --| post
'</pre>

'Get section between """ and """

        'var result = new MultilineSection(this,line, '"""', '"""')
        Dim result = new MultilineSection(Me, line, """"", """"")
        'if result.section
        if result.section Then
        

          '#discard first and last lines, if empty
          'if no result.section[0].trim()
          if Notresult.section(0).trim() Then
          
            'result.section.shift()
            result.section.shift()
          
          End if

          'if no result.section[result.section.length-1].trim()
          if Notresult.section(result.section.length - 1).trim() Then
          
            'result.section.pop()
            result.section.pop()
          
          End if

          '#search min indent
          'var indent = 999
          Dim indent = 999
          'for each sectionLine1 in result.section
          For Each sectionLine1 in result.section
          
            'var lineIndent=sectionLine1.countSpaces()
            Dim lineIndent = sectionLine1.countSpaces()
            'if lineIndent>=0 and lineIndent<indent
            if lineIndent >= 0 AndAlso lineIndent < indent Then
            
                'indent = lineIndent
                indent = lineIndent
            
            End if
            
          Next'  each in result.section

          '#trim indent on the left and extra right spaces
          'for each inx,sectionLine in result.section
          Dim inx as Integer =0
          For Each sectionLine in result.section
          
            'result.section[inx] = sectionLine.slice(indent).trimRight()
            result.section(inx) = sectionLine.slice(indent).trimRight()
          Next'  each in result.section

          '#join with (encoded) newline char and enclose in quotes (for splitExpressions)
          'line = result.section.join("\\n").quoted('"')
          line = result.section.join("\\n").quoted(""")

'Now we should escape internal d-quotes, but only *outside* string interpolation expressions

          'var parsed = .splitExpressions(line)
          Dim parsed = Me.splitExpressions(line)
          'for each inx,item:string in parsed
          Dim inx as Integer =0
          For Each item in parsed
          
              'if item.charAt(0) is '"' //a string part
              if item.charAt(0) = """ Then
              
                  'item = item.slice(1,-1) //remove quotes
                  item = item.slice(1, -1)
                  'item = item.replaceAll('"','\\"') #store with *escaped* internal d-quotes
                  item = item.replaceAll(""", "\\"")
                  'parsed[inx] = '"#{item}"' #restore enclosing quotes
                  parsed(inx) = """ + item + """
              
              End if
              
          Next'  each in parsed

      '//ifdef PROD_C  // compile-to-c

          '//// code a call to "concat" to handle string interpolation
          '//line = "_concatAny(#{parsed.join(',')})"

      '//else
          '// compile-to-js
          '//if the first expression isnt a quoted string constant
          '// we add `"" + ` so: we get string concatenation from javascript.
          '// Also: if the first expression starts with `(`, LiteScript can
          '// mis-parse the expression as a "function call"
          'if parsed.length and parsed[0].charAt(0) isnt '"'
          if parsed.length AndAlso parsed(0).charAt(0) <> """ Then
          
              'parsed.unshift "''" // prepend ''
              parsed.unshift("''")
          
          End if

          '// code a call to js string concat (+) to handle string interpolation
          'line = parsed.join(' + ')
          line = parsed.join(" + ")
          '// add pre & post
      '//endif

          '// add pre & post
          'line = "#{result.pre} #{line}#{result.post}"
          line = "" + result.pre + " " + line + result.post
        
        End if

        'return line
        return line
     end function
     ' ---------------------------
     Public Function checkMultilineComment (infoLines, lineType, startLineIndent, line)

'This method handles multiline comments: ` `//` `

        'var startSourceLine = .sourceLineNum
        Dim startSourceLine = Me.sourceLineNum

        'var result = new MultilineSection(this, line, '/*', '*/')
        Dim result = new MultilineSection(Me, line, "/*", "*/")
        'if no result.section
        if Notresult.section Then
        
          'return false
          return false
        
        End if

        'if result.section.length is 1 # just one line
        if result.section.length = 1 Then
        
          'line = "#{result.pre} #{result.post}//#{result.section[0]}"
          line = "" + result.pre + " " + result.post + "//" + (result.section(0))
          'if no result.pre and no result.post, lineType=LineTypes.COMMENT
          if Notresult.pre AndAlso Notresult.post Then lineType = LineTypes.COMMENT
          'infoLines.push(new InfoLine(this, lineType, startLineIndent, line, startSourceLine))
          infoLines.push(new InfoLine(Me, lineType, startLineIndent, line, startSourceLine))
        
        'if result.section.length is 1 # just one line
        
        else
        
          'if result.pre
          if result.pre Then
          
              'infoLines.push(new InfoLine(this, lineType, startLineIndent, result.pre, startSourceLine))
              infoLines.push(new InfoLine(Me, lineType, startLineIndent, result.pre, startSourceLine))
          
          End if

          'for each inx,sectionLine in result.section
          Dim inx as Integer =0
          For Each sectionLine in result.section
          
              'infoLines.push(new InfoLine(this, LineTypes.COMMENT, 0, sectionLine, startSourceLine+inx))
              infoLines.push(new InfoLine(Me, LineTypes.COMMENT, 0, sectionLine, startSourceLine + inx))
          Next'  each in result.section

          'if result.post.trim()
          if result.post.trim() Then
          
              'logger.warning "#{.filename}:#{.sourceLineNum}:1. Do not add text on the same line after `*/`. Indent is not clear"
              logger.warning("" + Me.filename + ":" + Me.sourceLineNum + ":1. Do not add text on the same line after `*/`. Indent is not clear")
              'infoLines.push(new InfoLine(this, LineTypes.CODE, result.postIndent, result.post, .sourceLineNum))
              infoLines.push(new InfoLine(Me, LineTypes.CODE, result.postIndent, result.post, Me.sourceLineNum))
          
          End if
          
        
        End if

        'return true #OK, lines processed
        return true
     end function
     ' ---------------------------
     Public Function checkConditionalCompilation (line)

'This method handles "#ifdef/#else/#endif" as multiline comments

        'var startSourceLine = .sourceLineNum
        Dim startSourceLine = Me.sourceLineNum

        'var words: string array
        Dim words = Nothing

        'var isDefine = line.indexOf("#define ")
        Dim isDefine = line.indexOf("#define ")
        'if isDefine>=0
        if isDefine >= 0 Then
        
            'words = line.trim().split(' ')
            words = line.trim().split(" ")
            '.project.setCompilerVar words[1],true
            Me.project.setCompilerVar(words(1), true)
            'return false
            return false
        
        End if

        'var isUndef = line.indexOf("#undef ")
        Dim isUndef = line.indexOf("#undef ")
        'if isUndef>=0
        if isUndef >= 0 Then
        
            'words = line.trim().split(' ')
            words = line.trim().split(" ")
            '.project.setCompilerVar words[1],false
            Me.project.setCompilerVar(words(1), false)
            'return false
            return false
        
        End if

        'if line.indexOf("#endif") is 0, .throwErr 'found "#endif" without "#ifdef"'
        if line.indexOf("#endif") = 0 Then Me.throwErr("found "#endif" without "#ifdef"")
        'if line.indexOf("#else") is 0, .throwErr 'found "#else" without "#ifdef"'
        if line.indexOf("#else") = 0 Then Me.throwErr("found "#else" without "#ifdef"")

        'var invert = false
        Dim invert = false
        'var pos = line.indexOf("#ifdef ")
        Dim pos = line.indexOf("#ifdef ")
        'if pos isnt 0
        if pos <> 0 Then
        
            'pos = line.indexOf("#ifndef ")
            pos = line.indexOf("#ifndef ")
            'invert = true
            invert = true
        
        End if

'ifdef, #ifndef, #else and #endif should be the first thing on the line

        'if pos isnt 0, return
        if pos <> 0 Then return

        'var startRef = "while processing #ifdef started on line #{startSourceLine}"
        Dim startRef = "while processing #ifdef started on line " + startSourceLine

        'words = line.slice(pos).split(' ')
        words = line.slice(pos).split(" ")
        'var conditional = words.tryGet(1)
        Dim conditional = words.tryGet(1)
        'if no conditional, .throwErr "#ifdef; missing conditional"
        if Notconditional Then Me.throwErr("#ifdef; missing conditional")
        'var defValue = .project.compilerVar(conditional)
        Dim defValue = Me.project.compilerVar(conditional)
        'if invert, defValue = not defValue //if it was "#ifndef"
        if invert Then defValue = Not(defValue)

        '.replaceSourceLine .line.replaceAll("#if","//if")
        Me.replaceSourceLine(Me.line.replaceAll("#if", "//if"))

        'var endFound=false
        Dim endFound = false
        'do
        do 
        
            '#get next line
            'if no .nextSourceLine(),.throwErr "EOF #{startRef}"
            if NotMe.nextSourceLine() Then Me.throwErr("EOF " + startRef)
            'line = .line
            line = Me.line

            'if line.countSpaces() into var indent >= 0
            Dim indent as Object
            if Assign(indent,line.countSpaces()) >= 0 Then
            
                'line = line.trim()
                line = line.trim()
                'if line.charAt(0) is '#' and line.charAt(1) isnt '#' //expected: "#else, #endif #end if"
                if line.charAt(0) = "#" AndAlso line.charAt(1) <> "#" Then
                
                    'words = line.split(' ')
                    words = line.split(" ")
                    'case words.tryGet(0)
                    select words.tryGet(0)
                    case "#else"
                    
                            '.replaceSourceLine .line.replaceAll("#else","//else")
                            Me.replaceSourceLine(Me.line.replaceAll("#else", "//else"))
                            'if words.tryGet(1), .throwErr "expected nothing after '#else' - #elseif not supported, read '#{line}' #{startRef}"
                            if words.tryGet(1) Then Me.throwErr("expected nothing after '#else' - #elseif not supported, read '" + line + "' " + startRef)
                            'defValue = not defValue
                            defValue = Not(defValue)
                    
                    
                    case "#end"
                    
                            'if words.tryGet(1) isnt 'if', .throwErr "expected '#end if', read '#{line}' #{startRef}"
                            if words.tryGet(1) <> "if" Then Me.throwErr("expected '#end if', read '" + line + "' " + startRef)
                            'endFound = true
                            endFound = true
                    
                    
                    case "#endif"
                    
                            'endFound = true
                            endFound = true
                    
                    
                    
                    case else
                    
                            '.throwErr "expected '#else/#end if', read '#{line}' #{startRef}"
                            Me.throwErr("expected '#else/#end if', read '" + line + "' " + startRef)
                    
                    'end case
                'else
                    
                
                'if line.charAt(0) is '#' and line.charAt(1) isnt '#' //expected: "#else, #endif #end if"
                
                else
                
                    '// comment line if .compilerVar not defined (or processing #else)
                    '//and this is not a blank line
                    'if not defValue and line, .replaceSourceLine "#{String.spaces(indent)}//#{line}"
                    if Not(defValue) AndAlso line Then Me.replaceSourceLine("" + (String.spaces(indent)) + "//" + line)
                
                End if
                'end if
            'end if
                
            
            End if
            'end if
        'loop until endFound
            
        Loop while NotendFound

        '.replaceSourceLine .line.replaceAll("#end","//end")
        Me.replaceSourceLine(Me.line.replaceAll("#end", "//end"))

        '#rewind position after #ifdef, reprocess lines
        '.sourceLineNum = startSourceLine -1
        Me.sourceLineNum = startSourceLine - 1
        'return true #OK, lines processed
        return true
     end function
     ' ---------------------------
     Public Function getPos ()
        '#return {lineInx:.lineInx, index:.index, sourceLineNum:.sourceLineNum, token:.token, last:.last}
        'return new LexerPos(this)
        return new LexerPos(Me)
     end function
     ' ---------------------------
     Public Function setPos (pos)

        '.lineInx = pos.lineInx
        Me.lineInx = pos.lineInx

        'if .lineInx>=0 and .lineInx<.infoLines.length
        if Me.lineInx >= 0 AndAlso Me.lineInx < Me.infoLines.length Then
        
            '.infoLine = .infoLines[.lineInx]
            Me.infoLine = Me.infoLines(Me.lineInx)
            '.indent = .infoLine.indent
            Me.indent = Me.infoLine.indent
        
        'if .lineInx>=0 and .lineInx<.infoLines.length
        
        else
        
            '.infoLine = null
            Me.infoLine = null
            '.indent = 0
            Me.indent = 0
        
        End if

        '.index = pos.index
        Me.index = pos.index
        '.sourceLineNum = pos.sourceLineNum
        Me.sourceLineNum = pos.sourceLineNum
        '.token = pos.token
        Me.token = pos.token
        '.last = pos.last
        Me.last = pos.last
     end function
     ' ---------------------------
     Public Function posToString ()
'Create a full string with last position. Useful to inform errors

        'if .last, return .last.toString()
        if Me.last Then return Me.last.toString()
        'return .getPos().toString()
        return Me.getPos().toString()
     end function
     ' ---------------------------
     Public Function getPrevIndent ()
        'var inx = .lineInx-1
        Dim inx = Me.lineInx - 1
        'while inx >=0
        Do whileinx >= 0
        
            'if .infoLines[inx].type is LineTypes.CODE
            if Me.infoLines(inx).type = LineTypes.CODE Then
            
                'return .infoLines[inx].indent
                return Me.infoLines(inx).indent
            
            End if
            'inx -= 1
            inx -= 1
        
        Loop

        'return 0
        return 0
     end function
     ' ---------------------------
     Public Function consumeToken ()

'loop until a CODE token is found

        'while true
        Do whiletrue
        

'loop until a valid CODE infoLine is selected

            '.token = null
            Me.token = null
            'while true
            Do whiletrue
            

'if no line selected

                'if not .infoLine
                if Not(Me.infoLine) Then
                

                    '.index = -1
                    Me.index = -1

'get next CODE line

                    'if not .nextCODELine()
                    if Not(Me.nextCODELine()) Then
                    

'if no more CODE lines -> EOF

                        '.infoLine = new InfoLine(this, LineTypes.CODE, -1, '', .lineInx)
                        Me.infoLine = new InfoLine(Me, LineTypes.CODE, -1, "", Me.lineInx)
                        '.token = new Token('EOF')
                        Me.token = new Token("EOF")
                        '.infoLine.tokens = [.token]
                        Me.infoLine.tokens = new ArrayList From {Me.token}
                        '.indent = -1
                        Me.indent = -1
                        'return
                        return
                    
                    End if

'since we moved to the next line, return "NEWLINE" token

                    '.sourceLineNum = .infoLine.sourceLineNum
                    Me.sourceLineNum = Me.infoLine.sourceLineNum
                    '.indent = .infoLine.indent
                    Me.indent = Me.infoLine.indent
                    '.token = new Token('NEWLINE')
                    Me.token = new Token("NEWLINE")
                    'return
                    return
                
                End if

'get next token in the line

                'if no .infoLine.tokens
                if NotMe.infoLine.tokens Then
                
                  'debugger
                  debugger
                
                End if


                '.index += 1
                Me.index += 1
                'if .index < .infoLine.tokens.length
                if Me.index < Me.infoLine.tokens.length Then
                
                    'break #ok, a line with tokens
                    break
                
                End if

'if there was no more tokens, set infoLine to null,
'and continue (get the next line)

                '.infoLine = null
                Me.infoLine = null
            
            Loop

            '#end while

'Here we have a infoLine, where type is CODE
'Get the token

            '.token = .infoLine.tokens[.index]
            Me.token = Me.infoLine.tokens(Me.index)

'if the token is a COMMENT, discard it,
'by continuing the loop (get the next token)

            'if .token.type is 'COMMENT'
            if Me.token.type = "COMMENT" Then
            
                'continue #discard COMMENT
                continue
            
            'if .token.type is 'COMMENT'
            
            else
            
                'break #the loop, CODE token is in lexer.token
                break
            
            End if
            
        
        Loop
        
     end function
     ' ---------------------------
     Public Function nextToken ()

'Save current pos, and get next token

        '.last = .getPos()
        Me.last = Me.getPos()

        '.consumeToken()
        Me.consumeToken()

        '#debug
        'logger.debug ">>>ADVANCE", "#{.sourceLineNum}:#{.token.column or 0} [#{.index}]", .token.toString()
        logger.debug(">>>ADVANCE", "" + Me.sourceLineNum + ":" + (Me.token.column OrElse 0) + " [" + Me.index + "]", Me.token.toString())

        'return true
        return true
     end function
     ' ---------------------------
     Public Function returnToken ()
        '#restore last saved pos (rewind)

        '.setPos .last
        Me.setPos(Me.last)
        'logger.debug '<< Returned:',.token.toString(),'line',.sourceLineNum
        logger.debug("<< Returned:", Me.token.toString(), "line", Me.sourceLineNum)
     end function
     ' ---------------------------
     Public Function nextCODELine ()

        'if .lineInx >= .infoLines.length
        if Me.lineInx >= Me.infoLines.length Then
        
            'return false # no more lines
            return false
        
        End if

'loop until a CODE line is found

        'while true
        Do whiletrue
        

            '.lineInx += 1
            Me.lineInx += 1
            'if .lineInx >= .infoLines.length
            if Me.lineInx >= Me.infoLines.length Then
            
                'return false # no more lines
                return false
            
            End if
'Get line

            '.infoLine = .infoLines[.lineInx]
            Me.infoLine = Me.infoLines(Me.lineInx)

'if it is a CODE line, store in lexer.sourceLineNum, and return true (ok)

            'if .infoLine.type is LineTypes.CODE
            if Me.infoLine.type = LineTypes.CODE Then
            

                '.sourceLineNum = .infoLine.sourceLineNum
                Me.sourceLineNum = Me.infoLine.sourceLineNum
                '.indent = .infoLine.indent
                Me.indent = Me.infoLine.indent
                '.index = -1
                Me.index = -1

                'return true #ok nextCODEline found
                return true
            
            End if
            
        
        Loop
        
     end function
     ' ---------------------------
     Public Function getPrevCODEInfoLineIndex (baseSourceLineNum)

        '//search prev CODE line
        'var inx = baseSourceLineNum
        Dim inx = baseSourceLineNum
        'if inx>=.infoLines.length, inx = .infoLines.length-1
        if inx >= Me.infoLines.length Then inx = Me.infoLines.length - 1

        'do until inx <= 0
        Do whileNot(inx <= 0 OrElse (Me.infoLines(inx).sourceLineNum < baseSourceLineNum AndAlso Me.infoLines(inx).type = LineTypes.CODE))
        

            'inx--
            inx--
        
        Loop

        'return inx
        return inx
     end function
     ' ---------------------------
     Public Function getPrevCODELineNum (baseSourceLineNum)

        'if .getPrevCODEInfoLineIndex(baseSourceLineNum) into var infoLineInx
        Dim infoLineInx as Object
        if Assign(infoLineInx,Me.getPrevCODEInfoLineIndex(baseSourceLineNum)) Then
        
            'return .infoLines[infoLineInx].sourceLineNum
            return Me.infoLines(infoLineInx).sourceLineNum
        
        End if
        
     end function
     ' ---------------------------
     Public Function getInfoLineIndex (sourceLineNum)

        '//search InfoLine where the required source line resides
        'var inx = sourceLineNum //line index is always<sourceLineNum
        Dim inx = sourceLineNum
        'if inx>=.infoLines.length, inx = .infoLines.length-1
        if inx >= Me.infoLines.length Then inx = Me.infoLines.length - 1

        'while inx and .infoLines[inx].sourceLineNum > sourceLineNum
        Do whileinx AndAlso Me.infoLines(inx).sourceLineNum > sourceLineNum
        
            'inx--
            inx--
        
        Loop

        'return inx
        return inx
     end function
     ' ---------------------------
     Public Function say ()
'**say** emit error (but continue compiling)

        'logger.error.apply this,arguments
        logger.error.apply(Me, arguments)
     end function
     ' ---------------------------
     Public Function throwErr (msg)
'**throwErr** add lexer position and emit error (abort compilation)

        'logger.throwControlled "#{.posToString()} #{msg}"
        logger.throwControlled("" + (Me.posToString()) + " " + msg)
     end function
     ' ---------------------------
     Public Function sayErr (msg)
'**sayErr** add lexer position and emit error (but continue compiling)

        'logger.error .posToString(),msg
        logger.error(Me.posToString(), msg)
     end function
     ' ---------------------------
     Public Function warn (msg)
'**warn** add lexer position and emit warning (continue compiling)

        'logger.warning .posToString(),msg
        logger.warning(Me.posToString(), msg)
     end function
     ' ---------------------------
     Public Function splitExpressions (text)
'split on #{expresion} using lexer.stringInterpolationChar

        'var delimiter = .stringInterpolationChar
        Dim delimiter = Me.stringInterpolationChar

'look for #{expression} inside a quoted string
'split expressions

        'if no text then return []
        if Nottext Then return new ArrayList

        '//get quotes
        'var quotes = text.charAt(0)
        Dim quotes = text.charAt(0)
        'if quotes isnt '"' and quotes isnt "'"
        if quotes <> """ AndAlso quotes <> "'" Then
        
            '.throwErr 'splitExpressions: expected text to be a quoted string, quotes included'
            Me.throwErr("splitExpressions: expected text to be a quoted string, quotes included")
        
        End if

        'var delimiterPos, closerPos, itemPos, item:string;
        Dim 
            delimiterPos = Nothing
            , closerPos = Nothing
            , itemPos = Nothing
            , item = Nothing
        'var items=[];
        Dim items = new ArrayList

        '//clear start and end quotes
        'var s:string = text.slice(1,-1)
        Dim s = text.slice(1, -1)

        'var lastDelimiterPos=0;
        Dim lastDelimiterPos = 0

        'do
        Do whiletrue
        

            'delimiterPos = s.indexOf("#{delimiter}{",lastDelimiterPos);
            delimiterPos = s.indexOf("" + delimiter + "{", lastDelimiterPos)
            'if delimiterPos<0 then break
            if delimiterPos < 0 Then break

            '// first part - text upto first delimiter
            'pushAt items, s.slice(lastDelimiterPos,delimiterPos),quotes
            pushAt(items, s.slice(lastDelimiterPos, delimiterPos), quotes)

            'var start = delimiterPos + 1
            Dim start = delimiterPos + 1

            'closerPos = String.findMatchingPair(s,start,"}")
            closerPos = String.findMatchingPair(s, start, "}")

            'if closerPos<0
            if closerPos < 0 Then
            
                '.throwErr "unmatched '#{delimiter}{' at string: #{text}"
                Me.throwErr("unmatched '" + delimiter + "{' at string: " + text)
            
            End if

            'item = s.slice(start+1, closerPos);
            item = s.slice(start + 1, closerPos)

            '// add parens if expression (if not a single number or varname or prop)
            'var singleUnit = PMREX.whileRanges(item,"A-Za-z0-9_$.")
            Dim singleUnit = PMREX.whileRanges(item, "A-Za-z0-9_$.")
            'if item isnt singleUnit, item = '(#{item})';
            if item <> singleUnit Then item = "(" + item + ")"

            'lastDelimiterPos = closerPos + 1
            lastDelimiterPos = closerPos + 1

            'pushAt items, item //push expression
            pushAt(items, item)
        
        Loop

        '// remainder
        'pushAt items, s.slice(lastDelimiterPos),quotes
        pushAt(items, s.slice(lastDelimiterPos), quotes)

        'return items
        return items
     end function
    
    end class 'Lexer



'### end class Lexer

    '// helper internal function
    'helper function pushAt(arr:array, content:string, useQuotes)
    ' ---------------------------
    function pushAt(arr, content, useQuotes)
        'if content
        if content Then
        
            'if useQuotes, content = content.quoted(useQuotes)
            if useQuotes Then content = content.quoted(useQuotes)
            'arr.push content
            arr.push(content)
        
        End if
        
    end function

'----------------------

'The Token Class
'===============

'Each token instance has:
'-a "type" e.g.: NEWLINE,EOF, when the token is a special char
'-a "value": the parsed text
'-the column in the source line in which the token appears

    'class Token
    ' constructor
    Class Token
        Public Property type as String' mainType: String  
        
            Public Property value as String' mainType: String  
        
            Public Property column as Object
    
    Sub New(type, tokenText, column)

            '.type = type
            Me.type = type
            '.value = tokenText or ' ' # no text is represened by ' ', since '' is "falsey" in js
            Me.value = tokenText OrElse " "
            '.column = column
            Me.column = column
        end function
    
        ' ---------------------------
        Public Function toString ()
            'return "'#{.value}'(#{.type})"
            return "'" + Me.value + "'(" + Me.type + ")"
        end function
    
    end class 'Token


'InfoLine Class
'==============

'The lexer turns each input line into a **infoLine**
'A **infoLine** is a clean, tipified, indent computed, trimmed line
'it has a source line number reference, and a tokens[] array if it's a CODE line

'Each "infoLine" has:
'* a line "type" of: `BLANK`, `COMMENT` or `CODE` (LineTypes),
'* a tokens[] array if it's `CODE`
'* sourceLineNum: the original source line number (for SourceMap)
'* indent: the line indent
'* text: the line text (clean, trimmed)

    'class InfoLine
    ' constructor
    Class InfoLine
        Public Property type as Object
          Public Property indent as Object
          Public Property sourceLineNum as Object
          Public Property text as String' mainType: String  
      
          Public Property tokens as Array' mainType: Array  ' itemType: Token
      
    
    Sub New(lexer, type, indent, text, sourceLineNum)
        '.type = type
        Me.type = type
        '.indent = indent
        Me.indent = indent
        '.text = text
        Me.text = text
        '.sourceLineNum = sourceLineNum
        Me.sourceLineNum = sourceLineNum
      end function
    
      ' ---------------------------
      Public Function outAsComment (outCode)

'output this line as a comment

        'if .type is LineTypes.BLANK
        if Me.type = LineTypes.BLANK Then
        
            'outCode.blankLine
            outCode.blankLine()
        
        'if .type is LineTypes.BLANK
        
        else
        
            '//text as comment
            'outCode.ensureNewLine
            outCode.ensureNewLine()
            'outCode.put String.spaces(.indent)
            outCode.put(String.spaces(Me.indent))
            'if .text.slice(0,2) isnt COMMENT_START, outCode.put COMMENT_START
            if Me.text.slice(0, 2) <> COMMENT_START Then outCode.put(COMMENT_START)
            'outCode.put .text
            outCode.put(Me.text)
            'outCode.startNewLine
            outCode.startNewLine()
        
        End if
        
      end function
      ' ---------------------------
      Public Function dump ()

        'if .type is LineTypes.BLANK
        if Me.type = LineTypes.BLANK Then
        
          'logger.debug .sourceLineNum,"(BLANK)"
          logger.debug(Me.sourceLineNum, "(BLANK)")
          'return
          return
        
        End if

        'var type = ""
        Dim type = ""
        'if .type is LineTypes.COMMENT
        if Me.type = LineTypes.COMMENT Then
        
          'type="COMMENT"
          type = "COMMENT"
        
        'if .type is LineTypes.COMMENT
        
        elseif Me.type = LineTypes.CODE Then
        
          'type="CODE"
          type = "CODE"
        
        End if
        End if

        'logger.debug .sourceLineNum, "#{.indent}(#{type})", .text
        logger.debug(Me.sourceLineNum, "" + Me.indent + "(" + type + ")", Me.text)
        'if .tokens
        if Me.tokens Then
        
            'logger.debug('   ',.tokens.join(' '))
            logger.debug("   ", Me.tokens.join(" "))
            'logger.debug()
            logger.debug()
        
        End if
        
      end function
      ' ---------------------------
      Public Function tokenizeLine (lexer)

        'var code = .text
        Dim code = Me.text

        'var words=[]
        Dim words = new ArrayList
        'var result=[]
        Dim result = new ArrayList
        'var colInx = 0
        Dim colInx = 0

        '#debug
        'var msg = ""
        Dim msg = ""

        'while colInx < code.length
        Do whilecolInx < code.length
        

            'var chunk = code.slice(colInx)
            Dim chunk = code.slice(colInx)

'This for loop will try each regular expression in `tokenPatterns`
'against the current head of the code line until one matches.

            'var token = .recognizeToken(chunk)
            Dim token = Me.recognizeToken(chunk)

'If there was no match, this is a bad token and we will abort compilation here.

            'if no token
            if Nottoken Then
            

                '// calc position from line info (we're at post-lexexr)
                'msg = "(#{lexer.filename}:#{.sourceLineNum}:#{colInx+1}) Tokenize patterns: invalid token: #{chunk}"
                msg = "(" + lexer.filename + ":" + Me.sourceLineNum + ":" + (colInx + 1) + ") Tokenize patterns: invalid token: " + chunk
                'logger.error msg
                logger.error(msg)

                'var errPosString=''
                Dim errPosString = ""
                'while errPosString.length<colInx
                Do whileerrPosString.length < colInx
                
                    'errPosString='#{errPosString} '
                    errPosString = "" + errPosString + " "
                
                Loop

                'logger.error code
                logger.error(code)
                'logger.error '#{errPosString}^'
                logger.error("" + errPosString + "^")

                'logger.throwControlled "parsing tokens"
                logger.throwControlled("parsing tokens")
            
            End if

            'end if

'If its 'WHITESPACE' we ignore it.

            'if token.type is 'WHITESPACE'
            

'If its 'WHITESPACE' we ignore it.

            'if token.type is 'WHITESPACE'
            if token.type = "WHITESPACE" Then
            
                'do nothing #ignore it
                Do Nothing
            
            'if token.type is 'WHITESPACE'
            
            else
            

'set token column

                'token.column = .indent + colInx + 1
                token.column = Me.indent + colInx + 1

'store value in a temp array to parse special lexer options

                'words.push(token.value)
                words.push(token.value)

'If its a string constant, and it has `#{`|`${`, process the **Interpolated Expressions**.

                'if token.type is 'STRING' and token.value.length>3 and lexer.stringInterpolationChar & "{" in token.value
                if token.type = "STRING" AndAlso token.value.length > 3 AndAlso token.value.Contains(lexer.stringInterpolationChar & "{") Then
                

                    'declare parsed:Array
                    

                    '#parse the quoted string, splitting at #{...}, return array
                    'var parsed = lexer.splitExpressions(token.value)
                    Dim parsed = lexer.splitExpressions(token.value)

'For C generation, replace string interpolation
'with a call to core function "concat"

                '//ifdef PROD_C

                    '//// code a litescript call to "_concatAny" to handle string interpolation
                    '//// (the producer will add argc)
                    '//var composed = new InfoLine(lexer, LineTypes.CODE, token.column,
                        '//"_concatAny(#{parsed.join(',')})", .sourceLineNum  )

                '//else
                    '//generating JavaScript
                    '//if the first expression isnt a quoted string constant
                    '// we add `"" + ` so we get string concatenation from javascript.
                    '// Also: if the first expression starts with `(`, LiteScript can
                    '// mis-parse the expression as a "function call"
                    'if parsed.length and parsed.tryGet(0).charAt(0) not in "\"\'" // if it do not start with a quote
                    if parsed.length AndAlso Not ("\"\'".Contains(parsed.tryGet(0).charAt(0))) Then
                    
                        'parsed.unshift "''" // prepend '' to concat'd expressions
                        parsed.unshift("''")
                    
                    End if
                    '//join expressions using +, so we have a valid js concat'd expression, evaluating to a string.
                    'var composed = new InfoLine(lexer, LineTypes.CODE, token.column, parsed.join(' + '), .sourceLineNum  )
                    Dim composed = new InfoLine(lexer, LineTypes.CODE, token.column, parsed.join(" + "), Me.sourceLineNum)
                '//end if

                    '#Now we 'tokenize' the new composed expression
                    'composed.tokenizeLine(lexer) #recurse
                    composed.tokenizeLine(lexer)

                    '#And we append the new tokens instead of the original string constant
                    'result = result.concat( composed.tokens )
                    result = result.concat(composed.tokens)
                
                'if token.type is 'STRING' and token.value.length>3 and lexer.stringInterpolationChar & "{" in token.value
                
                else
                

'Else it's a single token. Add the token to result array

                    '//ifndef NDEBUG
                    'msg = "#{msg}#{token.toString()}"
                    msg = "" + msg + (token.toString())
                    '//endif

                    'result.push(token)
                    result.push(token)
                
                End if

                'end if

            'end if WITHESPACE
                
            
            End if

            'end if WITHESPACE

'Advance col index into code line

            'colInx += token.value.length
            

'Advance col index into code line

            'colInx += token.value.length
            colInx += token.value.length
        
        Loop

        'end while text in the line

        '#debug
        '#debug msg

'Store tokenize result in .tokens

        '.tokens = result
        

        '#debug
        '#debug msg

'Store tokenize result in .tokens

        '.tokens = result
        Me.tokens = result

'Special lexer options: string interpolation char
'`lexer options string interpolation char [is] (IDENTIFIER|PUCT|STRING)`
'`lexer options literal (map|object)`

        'if words.tryGet(0) is 'lexer' and words.tryGet(1) is 'options'
        if words.tryGet(0) = "lexer" AndAlso words.tryGet(1) = "options" Then
        
            '.type = LineTypes.COMMENT # is a COMMENT line
            Me.type = LineTypes.COMMENT

            'if words.slice(2,5).join(" ") is "string interpolation char"
            if words.slice(2, 5).join(" ") = "string interpolation char" Then
            
                'var ch:string
                Dim ch = Nothing
                'if words.tryGet(5) into ch is 'is' then ch = words.tryGet(6) #get it (skip optional 'is')
                if Assign(ch,words.tryGet(5)) = "is" Then ch = words.tryGet(6)
                'if ch.charAt(0) in ['"',"'"], ch = ch.slice(1,-1) #optionally quoted, remove quotes
                if new ArrayList From {""", "'"}
                .Contains(ch.charAt(0)) Then ch = ch.slice(1, -1)
                'if no ch then fail with "missing string interpolation char"  #check
                if Notch Then Throw New System.Exception("missing string interpolation char")
                'lexer.stringInterpolationChar = ch
                lexer.stringInterpolationChar = ch
            
            'if words.slice(2,5).join(" ") is "string interpolation char"
            
            else
            
                'fail with "Lexer options, expected: 'literal map'|'literal object'"
                Throw New System.Exception("Lexer options, expected: 'literal map'|'literal object'")
            
            End if
            
        
        End if
        
      end function
      ' ---------------------------
      Public Function recognizeToken (chunk)

            'var remainder
            Dim remainder = Nothing

'Comment lines, start with # or //

            'if chunk.startsWith('#') or chunk.startsWith('//')
            if chunk.startsWith("#") OrElse chunk.startsWith("//") Then
            
                'return new Token('COMMENT',chunk)
                return new Token("COMMENT", chunk)
            
            End if

'Punctuation:
'We include also here punctuation symbols (like `,` `[` `:`) , the arrow `->` and the ellipsis `...`
'Postfix and prefix ++ and -- are considered also 'PUNCT'.
'They're not considered 'operators' since they do no introduce a new operand, ++ and -- are "modifiers" for a variable reference.

  '['PUNCT',/^(\+\+|--|->|\.\.\.)/],
  '['PUNCT',/^[\(\)\[\]\;\,\.\{\}]/],

            'if chunk.slice(0,3) is '...'
            if chunk.slice(0, 3) = "..." Then
            
                'return new Token('PUNCT',chunk.slice(0,3))
                return new Token("PUNCT", chunk.slice(0, 3))
            
            End if
            'if chunk.slice(0,2) in ["++","--","->"]
            if new ArrayList From {"++", "--", "->"}
            .Contains(chunk.slice(0, 2)) Then
            
                'return new Token('PUNCT',chunk.slice(0,2))
                return new Token("PUNCT", chunk.slice(0, 2))
            
            End if
            'if chunk.charAt(0) in "()[]{};,."
            if "()[]{};,.".Contains(chunk.charAt(0)) Then
            
                'return new Token('PUNCT',chunk.slice(0,1))
                return new Token("PUNCT", chunk.slice(0, 1))
            
            End if

'Whitespace is discarded by the lexer, but needs to exist to break up other tokens.
'We recognize ' .' (space+dot) to be able to recognize: 'myFunc .x' as alias to: 'myFunc this.x'
'We recognize ' [' (space+bracket) to be able to diferntiate: 'myFunc [x]' and 'myFunc[x]'

  '['SPACE_DOT',/^\s+\./],
  '['SPACE_BRACKET',/^\s+\[/],
  '['WHITESPACE',/^[\f\r\t\v\u00A0\u2028\u2029 ]+/],

            'if chunk.startsWith(" .")
            if chunk.startsWith(" .") Then
            
                'return new Token('SPACE_DOT',chunk.slice(0,2))
                return new Token("SPACE_DOT", chunk.slice(0, 2))
            
            End if
            'if chunk.startsWith(" [")
            if chunk.startsWith(" [") Then
            
                'return new Token('SPACE_BRACKET',chunk.slice(0,2))
                return new Token("SPACE_BRACKET", chunk.slice(0, 2))
            
            End if
            'if PMREX.whileRanges(chunk," \t\r") into var whiteSpace
            Dim whiteSpace as Object
            if Assign(whiteSpace,PMREX.whileRanges(chunk, " \t\r")) Then
            
                'if chunk.charAt(whiteSpace.length) in '.[', whiteSpace=whiteSpace.slice(0,-1) //allow recognition of SPACE_DOT and SPACE_BRACKET
                if ".[".Contains(chunk.charAt(whiteSpace.length)) Then whiteSpace = whiteSpace.slice(0, -1)
                'return new Token('WHITESPACE',whiteSpace)
                return new Token("WHITESPACE", whiteSpace)
            
            End if

'Strings can be either single or double quoted.

  '['STRING', /^'(?:[^'\\]|\\.)*'/],
  '['STRING', /^"(?:[^"\\]|\\.)*"/],

            'if chunk.startsWith("'") or chunk.startsWith('"')
            if chunk.startsWith("'") OrElse chunk.startsWith(""") Then
            
                'var quotedContent = PMREX.quotedContent(chunk)
                Dim quotedContent = PMREX.quotedContent(chunk)
                'return new Token('STRING',chunk.slice(0,1+quotedContent.length+1)) //include quotes
                return new Token("STRING", chunk.slice(0, 1 + quotedContent.length + 1))
            
            End if

'ASSIGN are symbols triggering the assignment statements.
'In LiteScript, assignment is a *statement* not a *expression*

  '['ASSIGN',/^=/],
  '['ASSIGN',/^[\+\-\*\/\&]=/ ], # = += -= *= /= &=

            'if chunk.startsWith("=")
            if chunk.startsWith("=") Then
            
                'return new Token('ASSIGN',chunk.slice(0,1))
                return new Token("ASSIGN", chunk.slice(0, 1))
            
            End if
            'if chunk.charAt(0) in "+-*/&" and chunk.charAt(1) is "="
            if "+-*/&".Contains(chunk.charAt(0)) AndAlso chunk.charAt(1) = "=" Then
            
                'return new Token('ASSIGN',chunk.slice(0,2))
                return new Token("ASSIGN", chunk.slice(0, 2))
            
            End if

'Regex tokens are regular expressions. The javascript producer, just passes the raw regex to JavaScript.

  '['REGEX', /^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/],

            'if chunk.startsWith('/') and chunk.indexOf('/',1) isnt -1
            if chunk.startsWith("/") AndAlso chunk.indexOf("/", 1) <> -1 Then
            
                'var regexpContents = PMREX.quotedContent(chunk)
                Dim regexpContents = PMREX.quotedContent(chunk)
                'var regexpExpr:string = chunk.slice(0,regexpContents.length+2) //include quote-chars: / & /
                Dim regexpExpr = chunk.slice(0, regexpContents.length + 2)
                'var regexpFlags = PMREX.whileRanges(chunk.slice(regexpExpr.length),"gimy")
                Dim regexpFlags = PMREX.whileRanges(chunk.slice(regexpExpr.length), "gimy")
                'return new Token('REGEX', regexpExpr & regexpFlags)
                return new Token("REGEX", regexpExpr & regexpFlags)
            
            End if


'A "Unary Operator" is a symbol that precedes and transform *one* operand.
'A "Binary Operator" is a  symbol or a word (like `>=` or `+` or `and`),
'that sits between *two* operands in a `Expressions`.

  '['OPER', /^(\*|\/|\%|\+|-|<>|>=|<=|>>|<<|>|<|!==|\~|\^)/],
  '['OPER', /^[\?\:]/], //ternary if
  '//identifier-like operators are handled in the identifier section below
  '['OPER', /^(is|isnt|not|and|but|into|like|or|in|into|instance|instanceof|has|hasnt|bitand|bitor|bitnot)\b/],

            'if chunk.slice(0,3) is '!=='
            if chunk.slice(0, 3) = "!==" Then
            
                'return new Token('OPER',chunk.slice(0,3))
                return new Token("OPER", chunk.slice(0, 3))
            
            End if

            'if "|#{chunk.slice(0,2)}|" in "|<>|>=|<=|>>|<<|!=|"
            if "|<>|>=|<=|>>|<<|!=|".Contains("|" + (chunk.slice(0, 2)) + "|") Then
            
                'return new Token('OPER',chunk.slice(0,2))
                return new Token("OPER", chunk.slice(0, 2))
            
            End if

            'if chunk.charAt(0) in "><+-*/%&~^?:"
            if "><+-*/%&~^?:".Contains(chunk.charAt(0)) Then
            
                'return new Token('OPER',chunk.slice(0,1))
                return new Token("OPER", chunk.slice(0, 1))
            
            End if

'**Numbers** can be either in hex format (like `0xa5b`) or decimal/scientific format (`10`, `3.14159`, or `10.02e23`).
'As in js, all numbers are floating point.

  '['NUMBER',/^0x[a-f0-9]+/i ],
  '['NUMBER',/^[0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?/i],

            'if chunk.startsWith('0x')
            if chunk.startsWith("0x") Then
            
                'var hexContent=PMREX.whileRanges(chunk.slice(2),"a-fA-F0-9")
                Dim hexContent = PMREX.whileRanges(chunk.slice(2), "a-fA-F0-9")
                'return new Token('NUMBER',chunk.slice(0, hexContent.length+2)) //include 0x
                return new Token("NUMBER", chunk.slice(0, hexContent.length + 2))
            
            End if

            'var numberDigits,decPoint="",decimalPart="",expE="",exponent=""
            Dim 
                numberDigits = Nothing
                , decPoint = ""
                , decimalPart = ""
                , expE = ""
                , exponent = ""

            'if PMREX.whileRanges(chunk,"0-9") into numberDigits
            if Assign(numberDigits,PMREX.whileRanges(chunk, "0-9")) Then
            
                'chunk=chunk.slice(numberDigits.length)
                chunk = chunk.slice(numberDigits.length)

                'if chunk.charAt(0) is '.'
                if chunk.charAt(0) = "." Then
                
                    'decPoint = '.'
                    decPoint = "."
                    'chunk=chunk.slice(1)
                    chunk = chunk.slice(1)

                    'decimalPart = PMREX.whileRanges(chunk,"0-9")
                    decimalPart = PMREX.whileRanges(chunk, "0-9")
                    'if no decimalPart, fail with 'missing decimal part after "."'
                    if NotdecimalPart Then Throw New System.Exception("missing decimal part after "."")
                    'chunk=chunk.slice(decimalPart.length)
                    chunk = chunk.slice(decimalPart.length)
                
                End if

                'if chunk.charAt(0) is 'e'
                if chunk.charAt(0) = "e" Then
                
                    'expE = 'e'
                    expE = "e"
                    'chunk=chunk.slice(1)
                    chunk = chunk.slice(1)

                    'exponent=PMREX.whileRanges(chunk,"0-9")
                    exponent = PMREX.whileRanges(chunk, "0-9")
                    'if no exponent, fail with 'missing exponent after "e"'
                    if Notexponent Then Throw New System.Exception("missing exponent after "e"")
                
                End if

                'return new Token('NUMBER',"#{numberDigits}#{decPoint}#{decimalPart}#{expE}#{exponent}")
                return new Token("NUMBER", "" + numberDigits + decPoint + decimalPart + expE + exponent)
            
            End if

'Identifiers (generally variable names), must start with a letter, `$`, or underscore.
'Subsequent characters can also be numbers. Unicode characters are supported in variable names.

'Identifier-like OPERs, as: 'and', 'not', 'is','or' are checked before concluding is an IDENTIFIER

  '['IDENTIFIER',/^[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*/] ]
  '['OPER', /^(is|isnt|not|and|but|into|like|or|in|into|instance|instanceof|has|hasnt|bitand|bitor)\b/],

'a IDENTIFIER starts with A-Z a-z (a unicode codepoint), $ or _
'(Note: we recognized numbers before this)

            'if PMREX.whileRanges(chunk,"A-Za-z0-9\x7F-\xFF$_") into var identifier
            Dim identifier as Object
            if Assign(identifier,PMREX.whileRanges(chunk, "A-Za-z0-9\x7F-\xFF$_")) Then
            

                'if "|#{identifier}|" in "|is|isnt|not|and|but|into|like|or|in|into|instance|instanceof|has|hasnt|bitand|bitor|bitxor|bitnot|"
                if "|is|isnt|not|and|but|into|like|or|in|into|instance|instanceof|has|hasnt|bitand|bitor|bitxor|bitnot|".Contains("|" + identifier + "|") Then
                
                    'return new Token('OPER',identifier)
                    return new Token("OPER", identifier)
                
                End if

                'return new Token('IDENTIFIER',identifier)
                return new Token("IDENTIFIER", identifier)
            
            End if
            
      end function
    
    end class 'InfoLine



'--------------------------

    '    helper class LexerPos
    ' constructor
    Class LexerPos
        Public Property lexer as Object
          Public Property lineInx as Object
          Public Property sourceLineNum as Object
          Public Property index as Object
          Public Property token as Object
          Public Property last as Object
    
    Sub New(lexer)
        '.lexer = lexer
        Me.lexer = lexer
        '.lineInx = lexer.lineInx
        Me.lineInx = lexer.lineInx
        '.index = lexer.index
        Me.index = lexer.index
        '.sourceLineNum = lexer.sourceLineNum
        Me.sourceLineNum = lexer.sourceLineNum
        '.token = lexer.token
        Me.token = lexer.token
        '.last = lexer.last
        Me.last = lexer.last
      end function
    
      ' ---------------------------
      Public Function toString ()
        'if no .token, .token = new Token(type='',tokenText='',column=0)
        if NotMe.token Then Me.token = new Token("", "", 0)
        'return "#{.lexer.filename}:#{.sourceLineNum}:#{(.token.column or 0)+1}"
        return "" + Me.lexer.filename + ":" + Me.sourceLineNum + ":" + ((Me.token.column OrElse 0) + 1)
      end function
    
    end class 'LexerPos


'----------------------------------------------------------------------------------------------

    '    helper class MultilineSection
    ' constructor
    Class MultilineSection
        Public Property pre as String' mainType: String  
      
          Public Property section as Array' mainType: Array  ' itemType: String
      
          Public Property post as String' mainType: String  
      
          Public Property postIndent as Object
    
    Sub New(lexer, line, startCode, endCode)

'check if startCode is in the line, if not found, exit

        'var startCol = line.indexOf(startCode)
        Dim startCol = line.indexOf(startCode)
        'if startCol<0
        if startCol < 0 Then
        
            '#no start code found
            'return
            return
        
        End if

        '// get rid of quoted strings. Still there?
        'if String.replaceQuoted(line,"").indexOf(startCode)<0
        if String.replaceQuoted(line, "").indexOf(startCode) < 0 Then
        
            'return #no
            return
        
        End if

'ok, found startCode, initialize

        'logger.debug "**** START MULTILINE ",startCode
        logger.debug("**** START MULTILINE ", startCode)

        'this.section = []
        Me.section = new ArrayList
        'var startSourceLine = lexer.sourceLineNum
        Dim startSourceLine = lexer.sourceLineNum

'Get and save text previous to startCode

        'this.pre = line.slice(0, startCol).trim()
        Me.pre = line.slice(0, startCol).trim()

'Get text after startCode

        'line = line.slice(startCol+startCode.length).trim()
        line = line.slice(startCol + startCode.length).trim()

'read lines until endCode is found

        'var endCol
        Dim endCol = Nothing
        'do until line.indexOf(endCode) into endCol >= 0 #found end of section
        Do whileNot(Assign(endCol,line.indexOf(endCode)) >= 0)
        

            '# still inside the section
            'this.section.push line
            Me.section.push(line)

            '#get next line
            'if no lexer.nextSourceLine()
            if Notlexer.nextSourceLine() Then
            
                'lexer.sayErr "EOF while processing multiline #{startCode} (started on #{lexer.filename}:#{startSourceLine}:#{startCol})"
                lexer.sayErr("EOF while processing multiline " + startCode + " (started on " + lexer.filename + ":" + startSourceLine + ":" + startCol + ")")
                'return
                return
            
            End if

            'line = lexer.line
            line = lexer.line
        
        Loop

'get text after endCode (is multilineSection.post)

        'this.post = line.slice(endCol+endCode.length)
        Me.post = line.slice(endCol + endCode.length)

'text before endCode, goes into multiline section

        'line = line.slice(0, endCol)
        line = line.slice(0, endCol)
        'if line
        if line Then
        
          'this.section.push line
          Me.section.push(line)
        
        End if

        'this.postIndent = endCol+endCode.length
        Me.postIndent = endCol + endCode.length
      end function
    
    
    end class 'MultilineSection

'------------------------

'Exported Module vars
'------------------------

    '    public namespace LineTypes
    Namespace LineTypes
    
        'properties
            'CODE = 0
            'COMMENT = 1
            'BLANK = 2

    '    public helper class OutCode
            Public Property CODE as Object=0
            Public Property COMMENT as Object=1
            Public Property BLANK as Object=2
        

    '    public helper class OutCode
    ' constructor
    Class OutCode
        Public Property lineNum as Object
         Public Property column as Object
         Public Property currLine as Array' mainType: Array  ' itemType: String
     
         Public Property header as Number' mainType: Number  
     =0
         Public Property fileMode as Boolean' mainType: Boolean  
     =true
         Public Property filenames as Object=new ArrayList From {"", "", ""}
     
         Public Property fileIsOpen as Object=new ArrayList From {false, false, false}
     
         Public Property fHandles as Object=new ArrayList From {null, null, null}
     
         Public Property lines as Array' mainType: Array  
     
         Public Property browser as Boolean' mainType: Boolean  
     
         Public Property exportNamespace as Object
         Public Property orTempVarCount as Object=0
    
    Sub New() 'default constructor
    
     ' ---------------------------
     Public Function start (options)
'Initialize output array

        '.lineNum=1
        Me.lineNum = 1
        '.column=1
        Me.column = 1
        '.currLine = []
        Me.currLine = new ArrayList
        '.lines=[[],[],[]]
        Me.lines = new ArrayList From {new ArrayList
, new ArrayList
, new ArrayList
        }

        '//.lastOriginalCodeComment = 0
        '//.lastOutCommentLine = 0

'if sourceMap option is set, and we're generating .js

        '//ifdef PROD_JS
        '//if options.generateSourceMap, .sourceMap = new SourceMap
        '//else
        'do nothing
        Do Nothing
     end function
     ' ---------------------------
     Public Function setHeader (num)

        '.startNewLine
        Me.startNewLine()
        '.header = num
        Me.header = num
     end function
     ' ---------------------------
     Public Function put (text)
'put a string into produced code

        'if text
        if text Then
        
            '.currLine.push text
            Me.currLine.push(text)
            '.column += text.length
            Me.column += text.length
        
        End if
        
     end function
     ' ---------------------------
     Public Function getIndent ()
        'if no .currLine.length, return 0
        if NotMe.currLine.length Then return 0
        'return .currLine[0].countSpaces()
        return Me.currLine(0).countSpaces()
     end function
     ' ---------------------------
     Public Function startNewLine ()
'Start New Line into produced code

'send the current line

          'if .currLine.length
          if Me.currLine.length Then
          

              'if .fileMode
              if Me.fileMode Then
              

                  'if no .fileIsOpen[.header]
                  if NotMe.fileIsOpen(Me.header) Then
                  
                      '// make sure output dir exists
                      'var filename = .filenames[.header]
                      Dim filename = Me.filenames(Me.header)
                      'mkPath.toFile(filename);
                      mkPath.toFile(filename)
                      '//optn output file
                      '.fHandles[.header]=fs.openSync(filename,'w')
                      Me.fHandles(Me.header) = fs.openSync(filename, "w")
                      '.fileIsOpen[.header] = true
                      Me.fileIsOpen(Me.header) = true
                  
                  End if
                  'end if

                  '//save each string to file
                  'for each part in .currLine
                  

                  '//save each string to file
                  'for each part in .currLine
                  For Each part in Me.currLine
                  
                      'fs.writeSync .fHandles[.header], part
                      fs.writeSync(Me.fHandles(Me.header), part)
                  Next'  each in Me.currLine

                  'fs.writeSync .fHandles[.header], "\n"
                  fs.writeSync(Me.fHandles(Me.header), "\n")
              
              'if .fileMode
              
              else
              
                  '//store in array
                  '.lines[.header].push .currLine.join("")
                  Me.lines(Me.header).push(Me.currLine.join(""))
              
              End if

              'if .header is 0
              if Me.header = 0 Then
              
                  '.lineNum++
                  Me.lineNum++
              
              End if
              
          
          End if
                  '//ifndef NDEBUG
                  '//logger.debug  .lineNum, .currLine.toString()
                  '//endif

'clear current line

          '.currLine.clear
          Me.currLine.clear()
          '.column = 1
          Me.column = 1
     end function
     ' ---------------------------
     Public Function ensureNewLine ()
'if there's something on the line, start a new one

          'if .currLine.length, .startNewLine
          if Me.currLine.length Then Me.startNewLine()
     end function
     ' ---------------------------
     Public Function blankLine ()

          '.startNewLine
          Me.startNewLine()
          '.currLine.push ""
          Me.currLine.push("")
          '.startNewLine
          Me.startNewLine()
     end function
     ' ---------------------------
     Public Function getResult (header)
'get result and clear memory

        'default header = 0
        if ismissing(header) then header=0: end if

        '.header = header
        Me.header = header
        '.startNewLine() #close last line
        Me.startNewLine()
        'return .lines[header]
        return Me.lines(header)
     end function
     ' ---------------------------
     Public Function close ()

        '.startNewLine //save last pending line
        Me.startNewLine()

        'if .fileMode
        if Me.fileMode Then
        

            'for header=0 to 2
            for header As Integer =0header to 2

                'if .fileIsOpen[header]
                if Me.fileIsOpen(header) Then
                

                    'fs.closeSync .fHandles[header]
                    fs.closeSync(Me.fHandles(header))
                    '.fileIsOpen[header] = false
                    Me.fileIsOpen(header) = false
                
                End if
                
            
            Next
            
        
        End if
        
     end function
     ' ---------------------------
     Public Function markSourceMap (indent)

        'var col = .column
        Dim col = Me.column
        'if not .currLine.length, col += indent-1
        if Not(Me.currLine.length) Then col += indent - 1
        'return new SourceMapMark({
                  'col : col
                  'lin :.lineNum-1
                '})
        return new SourceMapMark({{col,col}, {lin,Me.lineNum - 1}})
     end function
     ' ---------------------------
     Public Function addCompleteSourceMap (mark, sourceLin)

        '//ifdef PROD_JS
        '//if .sourceMap
            '//declare on mark
                '//lin,col
            '//.sourceMap.add ( (sourceLin or 1)-1, 0, mark.lin, 0)
            '//// debug: console.log "map source:", (sourceLin or 1), "-> js:",mark.lin
        '//else
        'do nothing
        Do Nothing
     end function
    
    end class 'OutCode
        '//endif


    '    helper class SourceMapMark
    ' constructor
    Class SourceMapMark
        Public Property col as Object
          Public Property lin as Object
    
    Sub New() 'default constructor
    
    
    end class 'SourceMapMark


    '    append to namespace String
    Partial Class String
    

'String.replaceQuoted(text,rep)
'replace every quoted string inside text, by rep

        'method replaceQuoted(text:string, rep:string)
        ' ---------------------------
        Public Function replaceQuoted (text, rep)

            'var p = 0
            Dim p = 0

'look for first quote (single or double?),
'loop until no quotes found

            'var anyQuote = '"' & "'"
            Dim anyQuote = """ & "'"

            'var resultText=""
            Dim resultText = ""

            'do
            do 
            
                'var preQuotes=PMREX.untilRanges(text,anyQuote)
                Dim preQuotes = PMREX.untilRanges(text, anyQuote)

                'resultText &= preQuotes
                resultText &= preQuotes
                'text = text.slice(preQuotes.length)
                text = text.slice(preQuotes.length)
                'if no text, break // all text processed|no quotes found
                if Nottext Then break

                'if text.slice(0,3) is '"""' //ignore triple quotes (valid token)
                if text.slice(0, 3) = """"" Then
                
                    'resultText &= text.slice(0,3)
                    resultText &= text.slice(0, 3)
                    'text = text.slice(3)
                    text = text.slice(3)
                
                'if text.slice(0,3) is '"""' //ignore triple quotes (valid token)
                
                else
                

                    'var quotedContent
                    Dim quotedContent = Nothing

                    'try // accept malformed quoted chunks (do not replace)
                    try 
                    

                         'quotedContent = PMREX.quotedContent(text)
                         quotedContent = PMREX.quotedContent(text)
                         'text = text.slice(1+quotedContent.length+1)
                         text = text.slice(1 + quotedContent.length + 1)
                    
                    Catch err
                        'resultText &= text.slice(0,1) //keep quote
                        resultText &= text.slice(0, 1)
                        'text = text.slice(1) //only remove quote
                        text = text.slice(1)
                    
                    End try
                    
                
                End if
                
            Loop while NotNottext

            'return resultText
            return resultText
        end function
        
    
    End Class 'partial' -----------
' Module code
' -----------
end module
