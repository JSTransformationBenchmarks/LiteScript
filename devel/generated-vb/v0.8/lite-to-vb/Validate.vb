'Generated by LiteScript compiler v0.8.9, source: Validate.lite.md
' -----------
Module Validate
' -----------
'===============

'This module contains helper functions to manage variable,
'function and object property name declaration.

'This module purpose is to make the compiler catch
'mistyped variable and property names at compile time
'(instead of YOU spending hours to debug a subtle bug at run time)

'In order to do name validation we need to construct the scope tree,
'and also register all valid members of all "types" (objects).

'----------
'##Dependencies:

'This module extends Grammar classes, adding 'declare', 'evaluateAssignments', etc.
'methods to validate var & property names.

    'import
        'ASTBase, Grammar
        'Names, Environment
        'logger, UniqueID

    'shim import LiteCore,Map
    'var ASTBase = require('./ASTBase.vb');
    'var Grammar = require('./Grammar.vb');
    'var Names = require('./Names.vb');
    'var Environment = require('./lib/Environment.vb');
    'var logger = require('./lib/logger.vb');
    'var UniqueID = require('./lib/UniqueID.vb');

    'shim import LiteCore,Map
    'var LiteCore = require('./interfaces/LiteCore.vb');
    'var Map = require('./interfaces/Map.vb');

'---------
'Module vars:

    'var project
    Dim project = Nothing

    'var globalScope: Names.Declaration
    Dim globalScope = Nothing
    'var globalObjectProto: Names.Declaration
    Dim globalObjectProto = Nothing

    'var nameAffinity: Names.Declaration
    Dim nameAffinity = Nothing


'##Members & Scope

'A Names.Declaration have a `.members=Map string to NamedDeclaration` property
'`.members={}` is a map to other `Names.Declaration`s which are valid members of this name.

'A 'scope' is a Names.Declaration whose members are the declared vars in the scope.

'For Example: 'console' is stored at 'Global Scope' and has '.log' and '.error' as members

'Project
'|_
   'scope = {
     'name: 'global scope'
     'members: {
        'console: {
          'name:'console'
          'type: Object
          'members:
              'log:
                'name:'log'
                'type: Function
              'error:
                'name: 'error'
                'type: Function
          '}
     '}


''Scopes' are created only for certain AST nodes, such as:
'Module, FunctionDeclaration, ForStatement, Catch/Exception, etc.

'Variables in the scope
'----------------------
'Referenced vars must be in the scope . You are required to explicitly declare your variables
'so you're **unable** to create a global variable by mistipying a name in an assignment.
'The compiler will catch such a misstype as "undeclared variable".

'Object properties access
'------------------------
'Object properties access are another source of subtle bugs in any medium to large javascript project.
'The problem is a mistyped property name results in the property not being found
'in the object nor the prototype chain, and javascript in this case just returns "undefined"
'and goes on. This causes hard to find subtle bugs.

'Example: The following javascript code, **will probably need debugging.**

  'options = options || {};
  'if (options.importantCodeDefaultTrue===undefined) options.importantCodeDefaultTrue=true;
  'if (options.anotherOptionDefaultZero===undefined) options.anotherOptionDefaultZero=0;

  'initFunction(options);
  'prepareDom(options);
  'if (options.importantCodesDefaultTrue) { moreInit(); subtleDomChanges(); }

'The same LiteScript code, but the mistake **will be caught by the compiler**
'The compiler will emit an error during compilation, -no debugging required-.

  'options = options or {}
  'if options.importantCodeDefaultTrue is undefined, options.importantCodeDefaultTrue=true
  'if options.anotherOptionDefaultZero is undefined, options.anotherOptionDefaultZero=0;

  'initFunction options
  'prepareDom options
  'if options.importantCodesDefaultTrue then moreInit(); subtleDomChanges()

'In order to completely check property names, a full type system is neeeded.

'LiteScript, based in js, *is not typed*, but you can add "type annotations"
'to your variable declaration, in order to declare the list of valid members
'to check at compile time.

'The compiler will guess var types from creation, assignment
'and by name affinity. If type cannot be guessed you can also explicitily use a
'`declare on myObj prop1,prop2` statement to dismiss the 'UNDECLARED PROPERTY' warnings.

'Example:
'
'
'  class ClassA
'
'    properties
'      classAProp1, classAProp2
'
'    method methodA
'      this.classAProp1 = 11
'      this.classAProp2 = 12
'
'  class ClassB
'
'    properties
'      classBProp1, classBProp2
'
'    method methodB
'      this.classBProp1 = 21
'
'  var instanceB = new ClassB // implicit type
'
'  instanceB.classBprop1 = 5 // <-- this **will be caught** as "case mismatch" since classBprop1 is defined as classBProp1
'
'  var bObj = instanceB // simple assignment, implicit type
'
'  bObj.classAProp1 = 5 // <-- this **will be caught** as: object 'bObj' has no property 'classAProp1'
'
'  var xObj = callToFn() // unknown type
'
'  xObj.classBProp1 = 5 // <-- this trigger a "classBProp1 IS NOT A DECLARED PROPERTY OF xObj"
'
'  declare on xObj  // <-- this fixes it
'    classBProp1
'
'  xObj.classBProp1 = 5 // <-- this is OK now
'
'  var xObj:ClassB = callToFn() // type annotation, this also fixes it
'
'  bObj.classBProp1 = 5 // <-- this is ok
'


    '    export function execute()
    ' ---------------------------
    function execute()

'We start this validation process after the entire multi-module AST tree has been parsed.

'Start running passes on the AST

'#### Pass 1.0 Declarations
'Walk the tree, and call function 'declare' on every node having it.
''declare' will create scopes, and vars in the scope.
'May inform 'DUPLICATES' and 'CASE MISMATCH' errors.

        'logger.info "- Process Declarations"
        logger.info("- Process Declarations")
        'walkAllNodesCalling 'declare'
        walkAllNodesCalling("declare")

'
'#### Pass 1.1 Declare By Assignment
'Walk the tree, and check assignments looking for: 'module.exports.x=x' and 'x.prototype.y = '.
'Treat them as declarations.
'
'        logger.info "- Declare By Assignment (support .js syntax, .exports.x=..., .prototype.x=...)"
'        walkAllNodesCalling 'declareByAssignment'

'#### Pass 1.2 connectImportRequire

        'logger.info "- Connect Imported"
        logger.info("- Connect Imported")

'validate public exports.
'set module.exports with default export object if set

        'for each moduleNode:Grammar.Module in map project.moduleCache
        for Each item in project.moduleCache
            Dim moduleNode__propName as string = item.key
            Dim moduleNode=item.value
        

            'moduleNode.confirmExports
            moduleNode.confirmExports()

            '//for interfaces, connect alias to vars & props
            '//this is to support jQuery.fn = prototype and "append to namespace jQuery.fn" as alias to "append to namespace jQuery.prototype"
            'if moduleNode.fileInfo.isInterface
            if moduleNode.fileInfo.isInterface Then
            
                'moduleNode.callOnSubTree "connectAlias" //only vardecls have this method
                moduleNode.callOnSubTree("connectAlias")
            
            End if
            
        Next'  for each item in map

'handle: `import x` and `global declare x`
'Make var x point to imported module 'x' exports

        'for each moduleNode:Grammar.Module in map project.moduleCache
        for Each item in project.moduleCache
          Dim moduleNode__propName as string = item.key
          Dim moduleNode=item.value
        

          'for each node in moduleNode.requireCallNodes
          For Each node in moduleNode.requireCallNodes
          

            'if node.importedModule
            if node.importedModule Then
            

              'var parent: ASTBase
              Dim parent = Nothing
              'var referenceNameDecl: Names.Declaration //var where to import exported module members
              Dim referenceNameDecl = Nothing

              'declare valid parent.nameDecl
              

'1st, more common: if node is Grammar.ImportStatementItem

              'if node instance of Grammar.ImportStatementItem
              if TypeOf node is Grammar.ImportStatementItem Then
              
                  'declare node:Grammar.ImportStatementItem
                  
                  'referenceNameDecl = node.nameDecl
                  referenceNameDecl = node.nameDecl

'if we process a 'global declare' command (interface)
'all exported should go to the global scope.

'If the imported module exports a class, e.g.: "export default class OptionsParser",
''importedModule.exports' points to the class 'prototype'.

                  'if node.getParent(Grammar.DeclareStatement) isnt undefined //is a "global declare"
                  if node.getParent(Grammar.DeclareStatement) <> undefined Then
                  

                        'if not node.importedModule.movedToGlobal //already processed
                        if Not(node.importedModule.movedToGlobal) Then
                        
                            'var moveWhat = node.importedModule.exports
                            Dim moveWhat = node.importedModule.exports
                            '#if the module has a export-only class, move to global with class name
                            'if moveWhat.findOwnMember('prototype') into var protoExportNameDecl
                            Dim protoExportNameDecl as Object
                            if Assign(protoExportNameDecl,moveWhat.findOwnMember("prototype")) Then
                            
                                '//if it has a 'prototype'
                                '//replace 'prototype' (on module.exports) with the class name, and add as the class
                                'protoExportNameDecl.name = protoExportNameDecl.parent.name
                                protoExportNameDecl.name = protoExportNameDecl.parent.name
                                'project.rootModule.addToScope protoExportNameDecl
                                project.rootModule.addToScope(protoExportNameDecl)
                            
                            'if moveWhat.findOwnMember('prototype') into var protoExportNameDecl
                            
                            else
                            
                                '// a "declare global x", but "x.lite.md" do not export a class
                                '// move all exported (namespace members) to global scope
                                'for each nameDecl in map moveWhat.members
                                for Each item in moveWhat.members
                                    Dim nameDecl__propName as string = item.key
                                    Dim nameDecl=item.value
                                
                                    'project.rootModule.addToScope nameDecl
                                    project.rootModule.addToScope(nameDecl)
                                Next'  for each item in map
                                
                            
                            End if

                            '//mark as processed
                            'node.importedModule.movedToGlobal = true
                            node.importedModule.movedToGlobal = true
                        
                        End if

                        '//we moved all to the global scope, e.g.:"declare global jQuery" do not assign to referenceNameDecl
                        'referenceNameDecl = undefined
                        referenceNameDecl = undefined
                  
                  End if
                  
              
              End if

                  '//else
                      '//commented: is valid that some modules to export nothing
                      '// e.g.: module "shims" and a main module
                      '//if node.importedModule.exports.members.size is 0
                      '//    node.warn "nothing exported in #{node.importedModule.fileInfo.filename}"

'
'
'else is a "require" call (VariableRef).
'Get parent node.
'
'              else
'                  parent = node.parent
'                  if parent instance of Grammar.Operand
'                     parent = node.parent.parent.parent # varRef->operand->Expression->Expression Parent
'
'get referece where import module is being assigned to
'
'                  if parent instance of Grammar.AssignmentStatement
'                      var opt = new Names.NameDeclOptions
'                      opt.informError = true
'                      declare valid parent.lvalue.tryGetReference
'                      referenceNameDecl = parent.lvalue.tryGetReference(opt)
'
'                  else if parent instance of Grammar.VariableDecl
'                      referenceNameDecl = parent.nameDecl
'
'              end if

'After determining referenceNameDecl where imported items go,
'make referenceNameDecl point to importedModule.exports

              'if referenceNameDecl
              if referenceNameDecl Then
              
                  'referenceNameDecl.makePointTo node.importedModule.exports
                  referenceNameDecl.makePointTo(node.importedModule.exports)
              
              End if
              
            
            End if
            
          Next'  each in moduleNode.requireCallNodes
          
        Next'  for each item in map
                  '// if it has a 'prototype' => it's a Function-Class
                  '// else we assume all exported from module is a namespace
                  '//referenceNameDecl.isNamespace = no referenceNameDecl.findOwnMember('prototype')


'#### Pass 1.3 Process "Append To" Declarations
'Since 'append to [class|object] x.y.z' statement can add to any object, we delay
'"Append To" declaration to this point, where 'x.y.z' can be analyzed and a reference obtained.
'Walk the tree, and check "Append To" Methods & Properties Declarations

        'logger.info "- Processing Append-To, extends"
        logger.info("- Processing Append-To, extends")
        'walkAllNodesCalling 'processAppendToExtends'
        walkAllNodesCalling("processAppendToExtends")


'#### Pass 2.0 Apply Name Affinity

        'logger.info "- Apply Name Affinity"
        logger.info("- Apply Name Affinity")

        '#first, try to assign type by "name affinity"
        '#(only applies when type is not specified)
        'for each nameDecl in Names.allNameDeclarations
        For Each nameDecl in Names.allNameDeclarations
        
            'nameDecl.assignTypebyNameAffinity()
            nameDecl.assignTypebyNameAffinity()
        Next'  each in Names.allNameDeclarations

'#### Pass 2.1 Convert Types
'for each Names.Declaration try to find the declared 'type' (string) in the scope.
'Repeat until no conversions can be made.

        'logger.info "- Converting Types"
        logger.info("- Converting Types")

        '#now try de-referencing types
        'var pass=0, sumConverted=0, sumFailures=0, lastSumFailures=0
        Dim 
            pass = 0
            , sumConverted = 0
            , sumFailures = 0
            , lastSumFailures = 0
        '#repeat until all converted
        'do
        do 
        

            'lastSumFailures = sumFailures
            lastSumFailures = sumFailures
            'sumFailures = 0
            sumFailures = 0
            'sumConverted = 0
            sumConverted = 0

            '#process all, sum conversion failures
            'for each nameDecl in Names.allNameDeclarations
            For Each nameDecl in Names.allNameDeclarations
            
                'var result = nameDecl.processConvertTypes()
                Dim result = nameDecl.processConvertTypes()
                'sumFailures += result.failures
                sumFailures += result.failures
                'sumConverted += result.converted
                sumConverted += result.converted
            Next'  each in Names.allNameDeclarations
            'end for

            'pass++
            

            'pass++
            pass++
        Loop while Not(sumFailures = lastSumFailures)

'Inform unconverted types as errors

        'if sumFailures #there was failures, inform al errors
        if sumFailures Then
        
            'for each nameDecl in Names.allNameDeclarations
            For Each nameDecl in Names.allNameDeclarations
            
                'nameDecl.processConvertTypes({informError:true})
                nameDecl.processConvertTypes({{informError,true}})
            Next'  each in Names.allNameDeclarations
            
        
        End if

'#### Pass 3 Evaluate Assignments
'Walk the scope tree, and for each assignment,
'IF L-value has no type, try to guess from R-value's result type

        'logger.info "- Evaluating Assignments"
        logger.info("- Evaluating Assignments")
        'walkAllNodesCalling 'evaluateAssignments'
        walkAllNodesCalling("evaluateAssignments")

'#### Pass 4 -Final- Validate Property Access
'Once we have all vars declared and typed, walk the AST,
'and for each VariableRef validate property access.
'May inform 'UNDECLARED PROPERTY'.

        'logger.info "- Validating Property Access"
        logger.info("- Validating Property Access")
        'walkAllNodesCalling 'validatePropertyAccess'
        walkAllNodesCalling("validatePropertyAccess")

'Inform forward declarations not fulfilled, as errors

        'for each nameDecl in Names.allNameDeclarations
        For Each nameDecl in Names.allNameDeclarations
        

            'if nameDecl.isForward and not nameDecl.isDummy
            if nameDecl.isForward AndAlso Not(nameDecl.isDummy) Then
            

                'nameDecl.warn "forward declared, but never found"
                nameDecl.warn("forward declared, but never found")
                'var container = nameDecl.nodeDeclared.getParent(Grammar.ClassDeclaration)
                Dim container = nameDecl.nodeDeclared.getParent(Grammar.ClassDeclaration)
                'if container
                if container Then
                
                  'declare container:Grammar.ClassDeclaration
                  
                  'declare valid container.varRef.toString
                  
                  'if container.varRef, logger.warning "#{container.positionText()} more info: '#{nameDecl.name}' of '#{container.varRef.toString()}'"
                  if container.varRef Then logger.warning("" + (container.positionText()) + " more info: '" + nameDecl.name + "' of '" + (container.varRef.toString()) + "'")
                
                End if
                
            
            End if
            
        Next'  each in Names.allNameDeclarations
        
    end function

    '    export function walkAllNodesCalling(methodName:string)
    ' ---------------------------
    function walkAllNodesCalling(methodName)

        'var methodSymbol = LiteCore.getSymbol(methodName)
        Dim methodSymbol = LiteCore.getSymbol(methodName)

        'if project.moduleCache.size is 0
        if project.moduleCache.size = 0 Then
        
            'throw new Error("walkAllNodes: no modules in moduleCache")
            Throw new Error("walkAllNodes: no modules in moduleCache")
        
        End if

'For all modules, for each node, if the specific AST node has methodName, call it

        'for each moduleNode:Grammar.Module in map project.moduleCache
        for Each item in project.moduleCache
            Dim moduleNode__propName as string = item.key
            Dim moduleNode=item.value
        
            'moduleNode.callOnSubTree methodSymbol
            moduleNode.callOnSubTree(methodSymbol)
        Next'  for each item in map
        
    end function


    '    export function initialize(aProject)
    ' ---------------------------
    function initialize(aProject)

'Initialize module vars

        'project = aProject
        project = aProject

        '#clear global Names.Declaration list
        'Names.allNameDeclarations = []
        Names.allNameDeclarations = new ArrayList

'initialize NameAffinity

        '# project-wide name affinity for classes
        'nameAffinity = new Names.Declaration('Name Affinity',{
            'normalizeModeKeepFirstCase:true #nameAffinity members are stored: [0].Toupper()+slice(1).toLower()
            'nodeClass: Grammar.VariableDecl
            '});
        nameAffinity = new Names.Declaration("Name Affinity", {{normalizeModeKeepFirstCase,true}, {nodeClass,Grammar.VariableDecl}})

        '//populateGlobalScope(aProject)

'The "scope" of rootNode is the global scope.

        'globalScope = project.rootModule.createScope()
        globalScope = project.rootModule.createScope()

'Initialize global scope
'a)non-instance values

        'var opt = new Names.DeclarationOptions
        Dim opt = new Names.DeclarationOptions()
        'opt.nodeClass = Grammar.VariableDecl
        opt.nodeClass = Grammar.VariableDecl
        'globalScope.addMember 'undefined',opt
        globalScope.addMember("undefined", opt)
        'opt.value = null
        opt.value = null
        'globalScope.addMember 'null',opt
        globalScope.addMember("null", opt)
        'opt.value = true
        opt.value = true
        'globalScope.addMember 'true',opt
        globalScope.addMember("true", opt)
        'opt.value = false
        opt.value = false
        'globalScope.addMember 'false',opt
        globalScope.addMember("false", opt)
        'opt.value = NaN
        opt.value = NaN
        'globalScope.addMember 'NaN',opt
        globalScope.addMember("NaN", opt)
        'opt.value = Infinity
        opt.value = Infinity
        'globalScope.addMember 'Infinity',opt
        globalScope.addMember("Infinity", opt)

'b) pre-create core classes, to allow the interface.md file to declare property types and return values

        'AddGlobalClasses
            ''Object', 'Function', 'Array'
            ''String', 'Number', 'Boolean'

'In JS the global environment (global|window) is a *Object*, and as such it
'*has* Object.prototype in its prototype chain, which means
'*all properties in Object.prototype are also in the global scope*

'Get hold of Object.prototype since we're using it as "parent" (__proto__) of the global scope.

        'globalObjectProto = tryGetGlobalPrototype('Object')
        AddGlobalClasses("Object", "Function", "Array", "String", "Number", "Boolean")

'In JS the global environment (global|window) is a *Object*, and as such it
'*has* Object.prototype in its prototype chain, which means
'*all properties in Object.prototype are also in the global scope*

'Get hold of Object.prototype since we're using it as "parent" (__proto__) of the global scope.

        'globalObjectProto = tryGetGlobalPrototype('Object')
        globalObjectProto = tryGetGlobalPrototype("Object")

'Allow use of "__proto__" getter/setter on any object

        'globalObjectProto.addMember '__proto__',{nodeClass:Grammar.VariableDecl}
        globalObjectProto.addMember("__proto__", {{nodeClass,Grammar.VariableDecl}})

'note: 'Map' and 'NameValuePair' are declared at GlobalScopeX.interface.md

'b) create special types

'-"any" default type for vars

        'globalScope.addMember 'any',{nodeClass:Grammar.ClassDeclaration} // used for "map string to any" - Dictionaries
        globalScope.addMember("any", {{nodeClass,Grammar.ClassDeclaration}})

'-arguments:any*

'"arguments:any*" - arguments, type: pointer to any

''arguments' is a local var to all functions, representing a pseudo-array witj all the arguments.
''arguments' has only one method: `arguments.toArray()`

'we declare here the type:"pointer to any" - "any*"

        'var argumentsType = globalScope.addMember('any*',{nodeClass:Grammar.ClassDeclaration}) //  any pointer, type for "arguments"
        Dim argumentsType = globalScope.addMember("any*", {{nodeClass,Grammar.ClassDeclaration}})

'-"arguments" have only one method: "toArray()"

        'argumentsType.addMember('toArray',{
              'type:       globalPrototype('Function')
              'returnType: globalPrototype('Array')
              'nodeClass:  Grammar.FunctionDeclaration
          '})
        argumentsType.addMember("toArray", {{type,globalPrototype("Function")}, {returnType,globalPrototype("Array")}, {nodeClass,Grammar.FunctionDeclaration}})

'b.2) Lite-C: the Lexer replaces string interpolation with calls to `_concatAny`

        'globalScope.addMember '_concatAny',{ //used for string interpolation
              'type:       globalPrototype('Function')
              'returnType: globalPrototype('String')
              'nodeClass:  Grammar.FunctionDeclaration
        '}
        globalScope.addMember("_concatAny", {{type,globalPrototype("Function")}, {returnType,globalPrototype("String")}, {nodeClass,Grammar.FunctionDeclaration}})

        'globalScope.addMember 'parseFloat',{
              'type:       globalPrototype('Function')
              'returnType: globalPrototype('Number')
              'nodeClass:  Grammar.FunctionDeclaration
              '}
        globalScope.addMember("parseFloat", {{type,globalPrototype("Function")}, {returnType,globalPrototype("Number")}, {nodeClass,Grammar.FunctionDeclaration}})

        'globalScope.addMember 'parseInt',{
              'type:       globalPrototype('Function')
              'returnType: globalPrototype('Number')
              'nodeClass:  Grammar.FunctionDeclaration
              '}
        globalScope.addMember("parseInt", {{type,globalPrototype("Function")}, {returnType,globalPrototype("Number")}, {nodeClass,Grammar.FunctionDeclaration}})

        'globalScope.addMember '__dirname',{ // current module dir (node.js)
              'type:       globalPrototype('String')
              'nodeClass:  Grammar.VariableDecl
              '}
        globalScope.addMember("__dirname", {{type,globalPrototype("String")}, {nodeClass,Grammar.VariableDecl}})

'Process the global scope declarations interface file
'by parsing the file: "interfaces/GlobalScope(JS|C|NODE|BROWSER).interface.md"

        'processInterfaceFile 'GlobalScope#{project.options.target.toUpperCase()}'
        processInterfaceFile("GlobalScope" + (project.options.target.toUpperCase()))

'if we're compiling for node.js, add extra node global core objects, e.g: process, Buffer
'if we're compiling for the browser, add window, document the DOM, localStorage,etc

        'if project.options.target is 'js'
        if project.options.target = "js" Then
        
            'if project.options.browser
            if project.options.browser Then
            
                'processInterfaceFile 'GlobalScopeBROWSER'
                processInterfaceFile("GlobalScopeBROWSER")
            
            'if project.options.browser
            
            else
            
                'processInterfaceFile 'GlobalScopeNODE'
                processInterfaceFile("GlobalScopeNODE")
            
            End if
            
        
        End if

'Initial NameAffinity, err|xxxErr => type:Error

        'if tryGetGlobalPrototype('Error') into var errProto:Names.Declaration
        Dim errProto as Object
        if Assign(errProto,tryGetGlobalPrototype("Error")) Then
        
            'nameAffinity.members.set 'Err',errProto.parent // err|xxxErr => type:Error
            nameAffinity.members.set("Err", errProto.parent)
        
        End if
        
    end function

    '    helper function processInterfaceFile(globalInterfaceFile)
    ' ---------------------------
    function processInterfaceFile(globalInterfaceFile)

'Process the global scope declarations interface file: GlobalScope(JS|C|NODE).interface.md

        'logger.info 'Declare global scope using #{globalInterfaceFile}.interface.md'
        logger.info("Declare global scope using " + globalInterfaceFile + ".interface.md")
        'var globalInterfaceModule = project.compileFile(globalInterfaceFile)
        Dim globalInterfaceModule = project.compileFile(globalInterfaceFile)
        '//logger.info '    from:',globalInterfaceModule.fileInfo.relFilename

'call "declare" on each item of the GlobalScope interface file, to create the Names.Declaration
'(normally in the global scope)

        'globalInterfaceModule.callOnSubTree LiteCore.getSymbol('declare')
        globalInterfaceModule.callOnSubTree(LiteCore.getSymbol("declare"))
    end function

'move all exported from the interface file, to project.rootModule global scope
'
'        for each nameDecl in map globalInterfaceModule.exports.members
'            project.rootModule.addToSpecificScope globalScope, nameDecl

'----------

'## Module Helper Functions

    '    helper function tryGetGlobalPrototype(name)
    ' ---------------------------
    function tryGetGlobalPrototype(name)
'gets a var from global scope

      'if globalScope.findOwnMember(name) into var nameDecl
      Dim nameDecl as Object
      if Assign(nameDecl,globalScope.findOwnMember(name)) Then
      
          'return nameDecl.members.get("prototype")
          return nameDecl.members.get("prototype")
      
      End if
      
    end function

    '    public helper function globalPrototype(name)
    ' ---------------------------
    function globalPrototype(name)
'gets a var from global scope

      'if name instanceof Names.Declaration, return name #already converted type
      if TypeOf name is Names.Declaration Then return name

      'if not globalScope.findOwnMember(name) into var nameDecl
      Dim nameDecl as Object
      if Not(Assign(nameDecl,globalScope.findOwnMember(name))) Then
      
        'fail with "no '#{name}' in global scope"
        Throw New System.Exception("no '" + name + "' in global scope")
      
      End if

      'if no nameDecl.findOwnMember("prototype") into var protoNameDecl
      Dim protoNameDecl as Object
      if Not(Assign(protoNameDecl,nameDecl.findOwnMember("prototype"))) Then
      
        'fail with "global scope type '#{name}' must have a 'prototype' property"
        Throw New System.Exception("global scope type '" + name + "' must have a 'prototype' property")
      
      End if

      'return protoNameDecl
      return protoNameDecl
    end function


    '    helper function addBuiltInClass(name,node) returns Names.Declaration
    ' ---------------------------
    function addBuiltInClass(name, node)
'Add a built-in class to global scope, return class prototype

      'var nameDecl = new Names.Declaration( name, {nodeClass:Grammar.ClassDeclaration} ,node )
      Dim nameDecl = new Names.Declaration(name, {{nodeClass,Grammar.ClassDeclaration}}, node)
      'globalScope.addMember nameDecl
      globalScope.addMember(nameDecl)

      'nameDecl.getMembersFromObjProperties Environment.getGlobalObject(name)
      nameDecl.getMembersFromObjProperties(Environment.getGlobalObject(name))

      'if no nameDecl.findOwnMember("prototype") into var classProto:Names.Declaration
      Dim classProto as Object
      if Not(Assign(classProto,nameDecl.findOwnMember("prototype"))) Then
      
          'throw new Error("addBuiltInClass '#{name}, expected to have a prototype")
          Throw new Error("addBuiltInClass '" + name + ", expected to have a prototype")
      
      End if

      'nameDecl.setMember '**proto**', globalPrototype('Function')
      nameDecl.setMember("**proto**", globalPrototype("Function"))
      '// commented v0.8: classes can not be used as functions.
      '// nameDecl.setMember '**return type**', classProto

      'return classProto
      return classProto
    end function


    '    helper function addBuiltInObject(name,node) returns Names.Declaration
    ' ---------------------------
    function addBuiltInObject(name, node)
'Add a built-in object to global scope, return object

      'var nameDecl = new Names.Declaration(name, {nodeClass:Grammar.NamespaceDeclaration}, node)
      Dim nameDecl = new Names.Declaration(name, {{nodeClass,Grammar.NamespaceDeclaration}}, node)
      'globalScope.addMember nameDecl
      globalScope.addMember(nameDecl)
      'nameDecl.getMembersFromObjProperties Environment.getGlobalObject(name)
      nameDecl.getMembersFromObjProperties(Environment.getGlobalObject(name))

      'if nameDecl.findOwnMember("prototype")
      if nameDecl.findOwnMember("prototype") Then
      
          'throw new Error("addBuiltObject '#{name}, expected *Object* to have not a prototype")
          Throw new Error("addBuiltObject '" + name + ", expected *Object* to have not a prototype")
      
      End if

      'return nameDecl
      return nameDecl
    end function

'---------------------------------------
'----------------------------------------
'----------------------------------------

    '    append to namespace Names
    Partial Class Names
    

      'class ConvertResult
      ' constructor
      Class ConvertResult
          Public Property converted as Number' mainType: Number  
        =0
            Public Property failures as Number' mainType: Number  
        =0
      
      Sub New() 'default constructor
      
      
      end class 'ConvertResult
      
    
    End Class 'partial

'##Additions to Names.Declaration. Helper methods to do validation

    '    append to class Names.Declaration
    Partial Class Names.Declaration
    

     '     helper method findMember(name) returns Names.Declaration
     ' ---------------------------
     Public Function findMember (name)
'this method looks for a name in Names.Declaration members,
'it also follows the **proto** chain (same mechanism as js __proto__ chain)

        'var actual = this
        Dim actual = Me
        'var count=0
        Dim count = 0

        'do while actual instance of Names.Declaration
        Do whileTypeOf actual is Names.Declaration
        

            'if actual.findOwnMember(name) into var result
            Dim result as Object
            if Assign(result,actual.findOwnMember(name)) Then
            
               'return result
               return result
            
            End if

'We use a member named '**proto**' on NameDeclarations, mapping run-time proto chain.
'We follow the chain to validate property names.

            'var nextInChain = actual.findOwnMember('**proto**')
            Dim nextInChain = actual.findOwnMember("**proto**")

'As last option in the chain, we always use 'Object.prototype'

            'if no nextInChain and actual isnt globalObjectProto
            if NotnextInChain AndAlso actual <> globalObjectProto Then
            
              'nextInChain = globalObjectProto
              nextInChain = globalObjectProto
            
            End if

            'actual = nextInChain
            actual = nextInChain

            'if count++ > 50 #assume circular
            if count++ > 50 Then
            
                '.warn "circular type reference"
                Me.warn("circular type reference")
                'return
                return
            
            End if
            
        
        Loop
        
     end function


     '     helper method hasProto(name) returns boolean
     ' ---------------------------
     Public Function hasProto (name)
'this method looks for a name in Names.Declaration members **proto**->prototype->parent
'it also follows the **proto** chain (same mechanism as js __proto__ chain)

        'var actual = this
        Dim actual = Me
        'var count=0
        Dim count = 0

        'do while actual instance of Names.Declaration
        Do whileTypeOf actual is Names.Declaration
        

            'if actual.name is 'prototype' and actual.parent.name is name
            if actual.name = "prototype" AndAlso actual.parent.name = name Then
            
                'return true
                return true
            
            End if

'We use a member named '**proto**' on NameDeclarations, mapping run-time proto chain.
'We follow the chain to validate property names.

            'var nextInChain = actual.findOwnMember('**proto**')
            Dim nextInChain = actual.findOwnMember("**proto**")

'As last option in the chain, we always use 'Object.prototype'

            'if no nextInChain and actual isnt globalObjectProto
            if NotnextInChain AndAlso actual <> globalObjectProto Then
            
                'nextInChain = globalObjectProto
                nextInChain = globalObjectProto
            
            End if

            'actual = nextInChain
            actual = nextInChain

            'if count++ > 50 #assume circular
            if count++ > 50 Then
            
                '.warn "circular type reference"
                Me.warn("circular type reference")
                'return
                return
            
            End if
            
        
        Loop
        
     end function

     '     helper method getMembersFromObjProperties(obj) #Recursive
     ' ---------------------------
     Public Function getMembersFromObjProperties (obj)
'Recursively converts a obj properties in NameDeclarations.
'it's used when a pure.js module is imported by 'require'
'to convert required 'exports' to LiteScript compiler usable NameDeclarations
'Also to load the global scope with built-in objects

        '//ifdef TARGET_C
        '//return
        '//else
        'var newMember:Names.Declaration
        Dim newMember = Nothing

        'if obj instanceof Object or obj is Object.prototype
        if TypeOf obj is Object OrElse obj = Object.prototype Then
        
            'declare obj:array //to allow js's property access []
            
            'for each prop in Object.getOwnPropertyNames(obj) #even not enumerables
            var _list3=Object.getOwnPropertyNames(obj)
            For Each prop in _list3
            if Not (new ArrayList From {"__proto__", "arguments", "caller"}
                .Contains(prop)) Then
            

                    'var type =  Grammar.autoCapitalizeCoreClasses(typeof obj[prop])
                    Dim type = Grammar.autoCapitalizeCoreClasses(TypeOf obj(prop))
                    'type = tryGetGlobalPrototype(type) #core classes: Function, Object, String
                    type = tryGetGlobalPrototype(type)
                    'if type is this, type = undefined #avoid circular references
                    if type = Me Then type = undefined

                    'newMember = .addMember(prop,{type:type})
                    newMember = Me.addMember(prop, {{type,type}})

'on 'prototype' member or
'if member is a Function-class - dive into

                    'declare valid Object.hasOwnProperty.call
                    
                    'if prop isnt 'constructor'
                    if prop <> "constructor" Then
                    
                        'if  prop is 'prototype'
                        if prop = "prototype" OrElse (TypeOf obj(prop) = "function" AndAlso obj(prop).hasOwnProperty("prototype") AndAlso Not(Me.isInParents(prop))) OrElse (TypeOf obj(prop) = "object" AndAlso Not(Me.isInParents(prop))) Then
                        
                              'newMember.getMembersFromObjProperties(obj[prop]) #recursive
                              newMember.getMembersFromObjProperties(obj(prop))
                              'if prop is 'super_' # used in node's core modules: http, EventEmitter, etc.
                              if prop = "super_" Then
                              
                                  'if newMember.findOwnMember('prototype') into var superProtopNameDecl
                                  Dim superProtopNameDecl as Object
                                  if Assign(superProtopNameDecl,newMember.findOwnMember("prototype")) Then
                                  
                                    'var protopNameDecl = .findOwnMember('prototype') or .addMember('prototype')
                                    Dim protopNameDecl = Me.findOwnMember("prototype") OrElse Me.addMember("prototype")
                                    'protopNameDecl.setMember '**proto**', superProtopNameDecl #put super's proto in **proto** of prototype
                                    protopNameDecl.setMember("**proto**", superProtopNameDecl)
                                  
                                  End if
                                  
                              
                              End if
                              
                        
                        End if
                        
                    
                    End if
                    
            End if
            Next'  each in Object.getOwnPropertyNames(obj)
            
        
        End if
        
     end function

        '//end if



     '     helper method isInParents(name)
     ' ---------------------------
     Public Function isInParents (name)
'return true if a property name is in the parent chain.
'Used to avoid recursing circular properties

        'var nameDecl = this.parent
        Dim nameDecl = Me.parent
        'while nameDecl
        Do whilenameDecl
        
          'if nameDecl.findOwnMember(name), return true
          if nameDecl.findOwnMember(name) Then return true
          'nameDecl = nameDecl.parent
          nameDecl = nameDecl.parent
        
        Loop
        
     end function


     '     helper method processConvertTypes(options:Names.DeclarationOptions) returns Names.ConvertResult
     ' ---------------------------
     Public Function processConvertTypes (options)
'convert possible types stored in Names.Declaration,
'from string/varRef to other NameDeclarations in the scope

        'var result = new Names.ConvertResult
        Dim result = new Names.ConvertResult()

        '.convertType '**proto**',result,options  #try convert main type
        Me.convertType("**proto**", result, options)
        '.convertType '**return type**',result,options  #a Function can have **return type**
        Me.convertType("**return type**", result, options)
        '.convertType '**item type**',result,options  #an Array can have **item type** e.g.: 'var list: string array'
        Me.convertType("**item type**", result, options)

        'return result
        return result
     end function


     '     helper method convertType(internalName, result: Names.ConvertResult, options: Names.DeclarationOptions)
     ' ---------------------------
     Public Function convertType (internalName, result, options)
'convert type from string to NameDeclarations in the scope.
'returns 'true' if converted, 'false' if it has to be tried later

        'if no .findOwnMember(internalName) into var typeRef
        Dim typeRef as Object
        if Not(Assign(typeRef,Me.findOwnMember(internalName))) Then
        
            '#nothing to process
            'return
            return
        
        End if

        'if typeRef instance of Names.Declaration
        if TypeOf typeRef is Names.Declaration Then
        
            '#already converted, nothing to do
            'return
            return
        
        End if

        'if typeRef instance of Grammar.TypeDeclaration
        if TypeOf typeRef is Grammar.TypeDeclaration Then
        
            'declare valid typeRef.mainType
            
            'typeRef = typeRef.mainType
            typeRef = typeRef.mainType
        
        End if

        'var converted:Names.Declaration
        Dim converted = Nothing

        '# if the typeRef is a varRef, get reference
        'if typeRef instanceof Grammar.VariableRef
        if TypeOf typeRef is Grammar.VariableRef Then
        
            'declare typeRef:Grammar.VariableRef
            
            'converted = typeRef.tryGetReference()
            converted = typeRef.tryGetReference()
        
        'if typeRef instanceof Grammar.VariableRef
        
        elseif TypeOf typeRef = "string" Then
        

            'if no .nodeDeclared #converting typeRef for a var not declared in code
            if NotMe.nodeDeclared Then
            
              'converted = globalPrototype(typeRef)
              converted = globalPrototype(typeRef)
            
            'if no .nodeDeclared #converting typeRef for a var not declared in code
            
            else
            
              'converted = .nodeDeclared.findInScope(typeRef)
              converted = Me.nodeDeclared.findInScope(typeRef)
            
            End if
            'end if

        'else
            
        
        'else if typeof typeRef is 'string' #built-in class or local var
        
        else
        
            'declare valid typeRef.constructor.name
            
            '.sayErr "INTERNAL ERROR: convertType UNRECOGNIZED type of:'#{typeof typeRef}' on #{internalName}: '#{typeRef}' [#{typeRef.constructor.name}]"
            Me.sayErr("INTERNAL ERROR: convertType UNRECOGNIZED type of:'" + (TypeOf typeRef) + "' on " + internalName + ": '" + typeRef + "' [" + typeRef.constructor.name + "]")
            'return
            return
        
        End if
        End if

        'end if #check instance of "typeRef"


        'if converted
        


        'if converted
        if converted Then
        
            '#move to prototype if referenced is a class
            'if converted.findOwnMember("prototype") into var prototypeNameDecl
            Dim prototypeNameDecl as Object
            if Assign(prototypeNameDecl,converted.findOwnMember("prototype")) Then
            
                'converted = prototypeNameDecl
                converted = prototypeNameDecl
            
            End if
            '#store converted
            '.setMember(internalName,converted)
            Me.setMember(internalName, converted)
            'result.converted++
            result.converted++
        
        'if converted
        
        else
        
            'result.failures++
            result.failures++
            'if options and options.informError, .sayErr "Undeclared type: '#{typeRef.toString()}'"
            if options AndAlso options.informError Then Me.sayErr("Undeclared type: '" + (typeRef.toString()) + "'")
        
        End if
        'end if

        'return
        

        'return
        return
     end function


     '     helper method assignTypeFromValue(value)
     ' ---------------------------
     Public Function assignTypeFromValue (value)
'if we can determine assigned value type, set var type

      'declare valid value.getResultType:function
      
      'var valueNameDecl = value.getResultType()
      Dim valueNameDecl = value.getResultType()

'now set var type (unless is "null" or "undefined", because they destroy type info)

      'if valueNameDecl instance of Names.Declaration
      if TypeOf valueNameDecl is Names.Declaration AndAlso Not (new ArrayList From {"undefined", "null"}
        .Contains(valueNameDecl.name)) Then
      

            'var theType
            Dim theType = Nothing
            'if valueNameDecl.name is 'prototype' # getResultType returns a class prototype
            if valueNameDecl.name = "prototype" Then
            
                '// use the class as type
                'theType = valueNameDecl
                theType = valueNameDecl
            
            'if valueNameDecl.name is 'prototype' # getResultType returns a class prototype
            
            else
            
                '//we assume valueNameDecl is a simple var, then we try to get **proto**
                'theType = valueNameDecl.findOwnMember('**proto**') or valueNameDecl
                theType = valueNameDecl.findOwnMember("**proto**") OrElse valueNameDecl
            
            End if
            'end if

            '// assign type: now both nameDecls points to same type
            '.setMember '**proto**', theType
            

            '// assign type: now both nameDecls points to same type
            '.setMember '**proto**', theType
            Me.setMember("**proto**", theType)
      
      End if
      
     end function



     '     helper method assignTypebyNameAffinity()
     ' ---------------------------
     Public Function assignTypebyNameAffinity ()
'Auto-assign type by name affinity.
'If no type specified, check project.nameAffinity

        'if .nodeDeclared and not String.isCapitalized(.name) and .name isnt 'prototype'
        if Me.nodeDeclared AndAlso Not(String.isCapitalized(Me.name)) AndAlso Me.name <> "prototype" Then
        

            'if not .findOwnMember('**proto**')
            if Not(Me.findOwnMember("**proto**")) Then
            

                'var possibleClassRef:Names.Declaration
                Dim possibleClassRef = Nothing
                '# possibleClassRef is a Names.Declaration whose .nodeDeclared is a ClassDeclaration

                '#should look as className. Also when searching with "endsWith",
                '# nameAffinity declarations are stored capitalized
                'var asClassName = .name.capitalized()
                Dim asClassName = Me.name.capitalized()

                '# look in name affinity map
                'if no nameAffinity.members.get(.name) into possibleClassRef
                if Not(Assign(possibleClassRef,nameAffinity.members.get(Me.name))) Then
                
                    '# make first letter uppercase, e.g.: convert 'lexer' to 'Lexer'
                    '# try with name, 1st letter capitalized
                    'possibleClassRef = nameAffinity.members.get(asClassName)
                    possibleClassRef = nameAffinity.members.get(asClassName)
                
                End if
                'end if

                '# check 'ends with' if name is at least 6 chars in length
                'if not possibleClassRef and .name.length>=6
                

                '# check 'ends with' if name is at least 6 chars in length
                'if not possibleClassRef and .name.length>=6
                if Not(possibleClassRef) AndAlso Me.name.length >= 6 Then
                
                    'for each affinityName,classRef in map nameAffinity.members
                    for Each item in nameAffinity.members
                        Dim affinityName as string = item.key
                        Dim classRef=item.value
                    
                        'if asClassName.endsWith(affinityName)
                        if asClassName.endsWith(affinityName) Then
                        
                            'possibleClassRef = classRef
                            possibleClassRef = classRef
                            'break
                            break
                        
                        End if
                        
                    Next'  for each item in map
                    
                
                End if

                '#if there is a candidate class, check of it has a defined prototype
                'if possibleClassRef and possibleClassRef.findOwnMember("prototype") into var prototypeNameDecl
                Dim prototypeNameDecl as Object
                if possibleClassRef AndAlso Assign(prototypeNameDecl,possibleClassRef.findOwnMember("prototype")) Then
                
                      '.setMember '**proto**', prototypeNameDecl
                      Me.setMember("**proto**", prototypeNameDecl)
                      'return true
                      return true
                
                End if
                
            
            End if
            
        
        End if
        
     end function
     
    
    End Class 'partial


'--------------------------------
'## Helper methods added to AST Tree

    '    append to class ASTBase
    Partial Class ASTBase
    

     '     properties
        'scope: Names.Declaration //for nodes with scope

     '     helper method declareName(name, options:Names.DeclarationOptions)
         Public Property scope as Names.Declaration' mainType: Names.Declaration  
     

     '     helper method declareName(name, options:Names.DeclarationOptions)
     ' ---------------------------
     Public Function declareName (name, options)
'declareName creates a new Names.Declaration, *referecing source as nodeDeclared (AST node)*

        'return new Names.Declaration(name, options, this)
        return new Names.Declaration(name, options, Me)
     end function

     '     method addMemberTo(nameDecl, memberName, options:Names.DeclarationOptions)  returns Names.Declaration
     ' ---------------------------
     Public Function addMemberTo (nameDecl, memberName, options)
'a Helper method ASTBase.*addMemberTo*
'Adds a member to a NameDecl, referencing this node as nodeDeclared

        'return nameDecl.addMember(memberName, options, this)
        return nameDecl.addMember(memberName, options, Me)
     end function

     '     helper method tryGetMember(nameDecl, name:string, options:Names.DeclarationOptions)
     ' ---------------------------
     Public Function tryGetMember (nameDecl, name, options)
'this method looks for a specific member, optionally declare as forward
'or inform error. We need this AST node, to correctly report error.

        'default options = new Names.DeclarationOptions
        if ismissing(options) then options=new Names.DeclarationOptions(): end if

        'var found = nameDecl.findMember(name)
        Dim found = nameDecl.findMember(name)

        'if found and name.slice(0,2) isnt '**'
        if found AndAlso name.slice(0, 2) <> "**" Then
        
          'found.caseMismatch name,this
          found.caseMismatch(name, Me)
        
        'if found and name.slice(0,2) isnt '**'
        
        else
        

          'if options.informError
          if options.informError Then
          
                'logger.warning "#{.positionText()}. No member named '#{name}' on #{nameDecl.info()}"
                logger.warning("" + (Me.positionText()) + ". No member named '" + name + "' on " + (nameDecl.info()))
                'if nameDecl.nodeDeclared, nameDecl.nodeDeclared.warn "declaration is here"
                if nameDecl.nodeDeclared Then nameDecl.nodeDeclared.warn("declaration is here")
          
          End if

          'if options.isForward, found = .addMemberTo(nameDecl,name,options)
          if options.isForward Then found = Me.addMemberTo(nameDecl, name, options)
        
        End if

        'return found
        return found
     end function


     '     helper method getScopeNode(stopAtAppendTo:boolean)
     ' ---------------------------
     Public Function getScopeNode (stopAtAppendTo)

'**getScopeNode** method return the parent 'scoped' node in the hierarchy.
'It looks up until found a node with .scope

'Start at this node

        'var node = this
        Dim node = Me

        'while node
        Do whilenode
        

          'if node.scope or (stopAtAppendTo and node.constructor is Grammar.AppendToDeclaration)
          if node.scope OrElse (stopAtAppendTo AndAlso node.constructor = Grammar.AppendToDeclaration) Then
          
              'return node # found a node with scope | Grammar.AppendToDeclaration
              return node
          
          End if

          'node = node.parent # move up
          node = node.parent
        
        Loop

        '#loop

        'return null
        return null
     end function


     '     method findInScope(name) returns Names.Declaration
     ' ---------------------------
     Public Function findInScope (name)
'this method looks for the original place
'where a name was defined (function,method,var)
'Returns the Identifier node from the original scope
'It's used to validate variable references to be previously declared names

'Start at this node

        'var node = this
        Dim node = Me
        'var found
        Dim found = Nothing

'Look for the declaration in this scope

        'while node
        Do whilenode
        

          'if node.scope
          if node.scope Then
          

              'if node.scope.findOwnMember(name) into found
              if Assign(found,node.scope.findOwnMember(name)) Then
              
                  'return found
                  return found
              
              End if
              
          
          End if

'move up in scopes

          'node = node.parent
          node = node.parent
        
        Loop

        '#loop

'In JS the global environment (global|window) is a *Object*, and as such it
'*has* Object.prototype in its prototype chain, which means
'*all properties in Object.prototype are also in the global scope*

'**To emulate JS (quirky) behavior, if a name is not found in any scope up to global scope,
'we must search also Object.prototype (since is __proto__ of global scope object).
'This help alleviating subtle bugs in js, if tou dare to add something to Object.prototype.

        'if globalObjectProto.findOwnMember(name) into found
        if Assign(found,globalObjectProto.findOwnMember(name)) Then
        
            'return found
            return found
        
        End if
        
     end function


     '     method tryGetFromScope(name, options:Names.DeclarationOptions) returns Names.Declaration
     ' ---------------------------
     Public Function tryGetFromScope (name, options)
'a Helper method: *ASTBase.tryGetFromScope(name)*, this method looks for the original declaration
'in the scope. if the declaration is not found, an error is emmited and a -pseudo- var is created
'in the scope in order to continue compilation

'Check if the name is declared. Retrieve the original declaration

'if it's already a Names.Declaration, no need to search

        'if name instanceof Names.Declaration, return name
        if TypeOf name is Names.Declaration Then return name

'Search the scope

        'if .findInScope(name) into var found
        Dim found as Object
        if Assign(found,Me.findInScope(name)) Then
        

'Declaration found, we check the upper/lower case to be consistent
'If the found item has a different case than the name we're looking for, emit error

            'if found.caseMismatch(name, this)
            if found.caseMismatch(name, Me) Then
            
                'return found
                return found
            
            End if
            'end if

'if it is not found,check options: a) inform error. b) declare foward.

        'else
            
        
        'if .findInScope(name) into var found
        
        else
        
            'if options and options.informError
            if options AndAlso options.informError Then
            
                '.sayErr "UNDECLARED NAME: '#{name}'"
                Me.sayErr("UNDECLARED NAME: '" + name + "'")
            
            End if

            'if options and options.isForward
            if options AndAlso options.isForward Then
            
                'found = .addToScope(name,options)
                found = Me.addToScope(name, options)
                'if options.isDummy and String.isCapitalized(name) #let's assume is a class
                if options.isDummy AndAlso String.isCapitalized(name) Then
                
                    '.addMemberTo(found,'prototype',options)
                    Me.addMemberTo(found, "prototype", options)
                
                End if
                
            
            End if
            
        
        End if

        '#end if - check declared variables

        'return found
        return found
     end function


     '     method addToScope(item, options:Names.DeclarationOptions) returns Names.Declaration
     ' ---------------------------
     Public Function addToScope (item, options)
'a Helper method ASTBase.*addToScope*
'Search for parent Scope, adds passed name to scope.members
'Reports duplicated.
'return: Names.Declaration

        'if no item, return # do nothing on undefined params
        if Notitem Then return

        'var scope:Names.Declaration = .getScopeNode().scope
        Dim scope = Me.getScopeNode().scope

        'return .addToSpecificScope(scope, item, options)
        return Me.addToSpecificScope(scope, item, options)
     end function

'First search it to report duplicates, if found in the scope.
'If the found item has a different case than the name we're adding, emit error & return

     '     method addToSpecificScope(scope:Names.Declaration, item, options:Names.DeclarationOptions) returns Names.Declaration
     ' ---------------------------
     Public Function addToSpecificScope (scope, item, options)

        'declare valid item.name
        
        'var name = type of item is 'string'? item : item.name
        Dim name = TypeOf item = "string" ? item : item.name

        'logger.debug "addToScope: '#{name}' to '#{scope.name}'" #[#{.constructor.name}] name:
        logger.debug("addToScope: '" + name + "' to '" + scope.name + "'")

        'if .findInScope(name) into var found
        Dim found as Object
        if Assign(found,Me.findInScope(name)) Then
        

            'if found.caseMismatch(name, this)
            if found.caseMismatch(name, Me) Then
            
                '#case mismatch informed
                'do nothing
                Do Nothing
            
            'if found.caseMismatch(name, this)
            
            elseif found.isForward Then
            
                'found.isForward = false
                found.isForward = false
                'found.nodeDeclared = this
                found.nodeDeclared = Me
                'if item instanceof Names.Declaration
                if TypeOf item is Names.Declaration Then
                
                    'found.replaceForward item
                    found.replaceForward(item)
                
                End if
                
            
            'else if found.isForward
            
            else
            
                'var errPosNode:ASTBase = item instanceof Names.Declaration? item else this
                Dim errPosNode = TypeOf item is Names.Declaration ? item : Me
                'errPosNode.sayErr "DUPLICATED name in scope: '#{name}'"
                errPosNode.sayErr("DUPLICATED name in scope: '" + name + "'")
                'logger.error found.originalDeclarationPosition() #add extra information line
                logger.error(found.originalDeclarationPosition())
            
            End if
            End if

            'return found
            return found
        
        End if

        '#end if

'else, not found, add it to the scope

        'var nameDecl
        Dim nameDecl = Nothing
        'if item instanceof Names.Declaration
        if TypeOf item is Names.Declaration Then
        
          'nameDecl = item
          nameDecl = item
        
        'if item instanceof Names.Declaration
        
        else
        
          'nameDecl = .declareName(name,options)
          nameDecl = Me.declareName(name, options)
        
        End if

        'scope.addMember nameDecl
        scope.addMember(nameDecl)

        'return nameDecl
        return nameDecl
     end function


     '     method selectAndAddToScope(nameDecl)
     ' ---------------------------
     Public Function selectAndAddToScope (nameDecl)

'if has adjective "global" add to global scope

        'if .hasAdjective('global')
        if Me.hasAdjective("global") Then
        
            'globalScope.addMember nameDecl
            globalScope.addMember(nameDecl)
        
        'if .hasAdjective('global')
        
        else
        
            'var container = .parent.getScopeNode(stopAtAppendTo=true)
            Dim container = Me.parent.getScopeNode(true)

'if it is declared inside a namespace, it is added to namespace scope, so inside a namespace,
'namespace functions and properties can be accessed directly.
'*AFTER* it is added as a item of the namespace (as a Object).
'This need to be done *after* so the nameDecl.parent ends up being the namespace rather than "namespace scope"

            'if container.constructor is Grammar.NamespaceDeclaration
            if container.constructor = Grammar.NamespaceDeclaration Then
            
                'declare container: Grammar.NamespaceDeclaration
                
                '.addToSpecificScope container.scope, nameDecl //1st
                Me.addToSpecificScope(container.scope, nameDecl)
                'container.nameDecl.addMember nameDecl //2nd - order is important (to set parent)
                container.nameDecl.addMember(nameDecl)
            
            'if container.constructor is Grammar.NamespaceDeclaration
            
            elseif container.constructor = Grammar.AppendToDeclaration Then
            
                'do nothing //will be handled later in processAppendToExtends()
                Do Nothing
            
            'else if container.constructor is Grammar.AppendToDeclaration
            
            else
            
                '//else, another kind of container,
                '// it could be a internal-function inside a function, a module-level class|namespace|fn|var.
                '//Add to parent scope
                '.addToSpecificScope container.scope, nameDecl
                Me.addToSpecificScope(container.scope, nameDecl)
            
            End if
            End if

'export:
'if has adjective public/export, add to module.exports

            'if .hasAdjective('export')
            if Me.hasAdjective("export") Then
            
                'if container.constructor isnt Grammar.Module, .sayErr "only module-level objects can be exported. '#{nameDecl}' is contained in #{container} '#{container.name}'."
                if container.constructor <> Grammar.Module Then Me.sayErr("only module-level objects can be exported. '" + nameDecl + "' is contained in " + container + " '" + container.name + "'.")
                'var moduleNode:Grammar.Module = .getParent(Grammar.Module)
                Dim moduleNode = Me.getParent(Grammar.Module)
                'moduleNode.addToExport nameDecl
                moduleNode.addToExport(nameDecl)
            
            End if
            
        
        End if
        
     end function


     '     helper method createScope()
     ' ---------------------------
     Public Function createScope ()
'initializes an empty scope in this node

        'if no .scope
        if NotMe.scope Then
        

            'var scopeName = .name is '*Global Scope*'? .name else "[#{.constructor.name} #{.name} Scope]"
            Dim scopeName = Me.name = "*Global Scope*" ? Me.name : "[" + Me.constructor.name + " " + Me.name + " Scope]"

            '.scope = .declareName(scopeName, {
                  'normalizeModeKeepFirstCase:true
                  'nodeClass: Grammar.VariableDecl
                  '})
            Me.scope = Me.declareName(scopeName, {{normalizeModeKeepFirstCase,true}, {nodeClass,Grammar.VariableDecl}})

            '.scope.isScope = true
            Me.scope.isScope = true
        
        End if

        'return .scope
        return Me.scope
     end function

     '     helper method tryGetOwnerNameDecl( informError ) returns Names.Declaration
     ' ---------------------------
     Public Function tryGetOwnerNameDecl (informError)

'Returns namedeclaration where this node should be.
'Used for properties & methods declarations.
'If the parent is Append-To, search for the referenced clas/namespace.

'returns owner.nameDecl or nothing

        'var toNamespace
        Dim toNamespace = Nothing
        'var ownerDecl
        Dim ownerDecl = Nothing

        '# get parent ClassDeclaration/Append-to/Namespace
        'var parent:Grammar.ClassDeclaration = .getParent(Grammar.ClassDeclaration)
        Dim parent = Me.getParent(Grammar.ClassDeclaration)

        'if no parent
        if Notparent Then
        
           'if informError, .throwError "declaration is outside 'class/namespace/append to'. Check indent"
           if informError Then Me.throwError("declaration is outside 'class/namespace/append to'. Check indent")
           'return
           return
        
        End if

'Append to class|namespace

        'if parent instance of Grammar.AppendToDeclaration
        if TypeOf parent is Grammar.AppendToDeclaration Then
        

            '#get varRefOwner from AppendToDeclaration
            'declare parent:Grammar.AppendToDeclaration
            

            'toNamespace = parent.toNamespace #if it was 'append to namespace'
            toNamespace = parent.toNamespace

            '#get referenced class/namespace
            'if no parent.varRef.tryGetReference() into ownerDecl
            if Not(Assign(ownerDecl,parent.varRef.tryGetReference())) Then
            
                'if informError
                if informError Then
                
                    '.sayErr "Append to: '#{parent.varRef}'. Reference is not fully declared"
                    Me.sayErr("Append to: '" + parent.varRef + "'. Reference is not fully declared")
                
                End if
                'return //if no ownerDecl found
                return
            
            End if
            
        
        'if parent instance of Grammar.AppendToDeclaration
        
        else
        

            'toNamespace = parent.constructor is Grammar.NamespaceDeclaration
            toNamespace = parent.constructor = Grammar.NamespaceDeclaration

            'ownerDecl = parent.nameDecl
            ownerDecl = parent.nameDecl
            'if no ownerDecl
            if NotownerDecl Then
            

                'if parent.hasAdjective('shim') // it was a shim class|namespace
                if parent.hasAdjective("shim") Then
                
                    'ownerDecl = .findInScope(parent.name) //get pre-existent
                    ownerDecl = Me.findInScope(parent.name)
                
                End if

                'if no ownerDecl
                if NotownerDecl Then
                
                    'return .sayErr("cannot get parent name declaration")
                    return Me.sayErr("cannot get parent name declaration")
                
                End if
                
            
            End if
            
        
        End if

        'end if


'check if owner is class (namespace) or class.prototype (class)


        'if toNamespace
        


'check if owner is class (namespace) or class.prototype (class)


        'if toNamespace
        if toNamespace Then
        
            '#'append to namespace'/'namespace x'. Members are added directly to owner
            'return ownerDecl
            return ownerDecl
        
        'if toNamespace
        
        else
        
            '# Class: members are added to the prototype
            '# move to class prototype
            'if no ownerDecl.findOwnMember("prototype") into var ownerDeclProto
            Dim ownerDeclProto as Object
            if Not(Assign(ownerDeclProto,ownerDecl.findOwnMember("prototype"))) Then
            
                'if informError, .sayErr "Class '#{ownerDecl}' has no .prototype"
                if informError Then Me.sayErr("Class '" + ownerDecl + "' has no .prototype")
                'return
                return
            
            End if

            '# Class: members are added to the prototype
            'return ownerDeclProto
            return ownerDeclProto
        
        End if

        'end if


     '     helper method callOnSubTree(methodSymbol,excludeClass) # recursive
        
     end function


     '     helper method callOnSubTree(methodSymbol,excludeClass) # recursive
     ' ---------------------------
     Public Function callOnSubTree (methodSymbol, excludeClass)

'This is instance has the method, call the method on the instance

      '//logger.debugGroup "callOnSubTree #{.constructor.name}.#{LiteCore.getSymbolName(methodSymbol)}() - '#{.name}'"

      'if this.tryGetMethod(methodSymbol) into var theFunction:Function
      Dim theFunction as Object
      if Assign(theFunction,Me.tryGetMethod(methodSymbol)) Then
      
            'logger.debug "calling #{.constructor.name}.#{LiteCore.getSymbolName(methodSymbol)}() - '#{.name}'"
            logger.debug("calling " + Me.constructor.name + "." + (LiteCore.getSymbolName(methodSymbol)) + "() - '" + Me.name + "'")
            'theFunction.call(this)
            theFunction.call(Me)
      
      End if

      'if excludeClass and this is instance of excludeClass, return #do not recurse on filtered's childs
      if excludeClass AndAlso TypeOf Me is excludeClass Then return

'recurse on all properties (exclude 'parent' and 'importedModule' and others, shortcut-references)

      'for each property name,value in this
      var value=undefined;
      for ( var name in Me){value=Me[name];
            if Not (new ArrayList From {"constructor", "parent", "importedModule", "requireCallNodes", "constructorDeclaration"}
        .Contains(name)) Then
            {

            'if value instance of ASTBase
            if TypeOf value is ASTBase Then
            
                'declare value:ASTBase
                
                'value.callOnSubTree methodSymbol,excludeClass #recurse
                value.callOnSubTree(methodSymbol, excludeClass)
            
            'if value instance of ASTBase
            
            elseif TypeOf value is Array Then
            
                'declare value:array
                
                '//logger.debug "callOnSubArray #{.constructor.name}.#{name}[]"
                'for each item in value where item instance of ASTBase
                For Each item in value
                if TypeOf item is ASTBase Then
                
                    'declare item:ASTBase
                    
                    'item.callOnSubTree methodSymbol,excludeClass
                    item.callOnSubTree(methodSymbol, excludeClass)
                End if
                Next'  each in value
                
            
            End if
            End if
            
            }
            
            }' end for each property
      'end for

      '//logger.debugGroupEnd



    '    append to class Grammar.Module ###
      
     end function
     
    
    End Class 'partial

      '//logger.debugGroupEnd



    '    append to class Grammar.Module ###
    Partial Class Grammar.Module
    

     '     helper method addToExport(exportedNameDecl)
     ' ---------------------------
     Public Function addToExport (exportedNameDecl)

'Add to parentModule.exports, but *preserve parent*

      '#just add to actual exports, but preserve parent
      'var saveParent = exportedNameDecl.parent
      Dim saveParent = exportedNameDecl.parent

      '.exports.addMember(exportedNameDecl)
      Me.exports.addMember(exportedNameDecl)

      'exportedNameDecl.parent = saveParent
      exportedNameDecl.parent = saveParent
     end function


     '     helper method confirmExports()
     ' ---------------------------
     Public Function confirmExports ()

'Check that:
'- if we have a "default export" (a class/namespace named as the module)
  '- we cannot have other vars or functions declared public/export
  '- replace module.exports with the default export object

      'var exportDefaultNameDecl
      Dim exportDefaultNameDecl = Nothing

'search for a export default object (a class/namespace named as the module)

      'for each nameDecl in map .exports.members
      for Each item in Me.exports.members
          Dim nameDecl__propName as string = item.key
          Dim nameDecl=item.value
      
          'if nameDecl.nodeDeclared and nameDecl.nodeDeclared.hasAdjective('only export')
          if nameDecl.nodeDeclared AndAlso nameDecl.nodeDeclared.hasAdjective("only export") Then
          
              'exportDefaultNameDecl = nameDecl
              exportDefaultNameDecl = nameDecl
              'break
              break
          
          End if
          
      Next'  for each item in map

      'if exportDefaultNameDecl
      if exportDefaultNameDecl Then
      

          'if .exports.getMemberCount() > 1
          if Me.exports.getMemberCount() > 1 Then
          
              '//only one "export-only" allowed
              'for each nameDecl in map .exports.members
              for Each item in Me.exports.members
                  Dim nameDecl__propName as string = item.key
                  Dim nameDecl=item.value
              if nameDecl <> exportDefaultNameDecl AndAlso nameDecl.parent <> exportDefaultNameDecl Then
              
                  'nameDecl.warn 'only export: cannot have "public functions/vars" and also a *only export* class/namespace'
                  nameDecl.warn("only export: cannot have "public functions/vars" and also a *only export* class/namespace")
              End if
              Next'  for each item in map
              
          
          End if

          '//set as namespace & replace module.exports
          '.exports.makePointTo exportDefaultNameDecl
          Me.exports.makePointTo(exportDefaultNameDecl)
          '.exports.name = exportDefaultNameDecl.name
          Me.exports.name = exportDefaultNameDecl.name
          '.exportsReplaced = true
          Me.exportsReplaced = true
      
      End if
      
     end function
     
    
    End Class 'partial


'----
'## Methods added to specific Grammar Classes to handle scope, var & members declaration

    '    append to class Grammar.VariableDecl ###
    Partial Class Grammar.VariableDecl
    

'`VariableDecl: Identifier (':' dataType-IDENTIFIER) ('=' assignedValue-Expression)`

'variable name, optional type anotation and optionally assign a value

'VariableDecls are used in:
'1. `var` statement
'2. function *parameter declaration*
'3. class *properties declaration*

'Examples:
  '`var a : string = 'some text'`
  '`function x ( a : string = 'some text', b, c=0)`

      'properties nameDecl
          Public Property nameDecl as Object

      'helper method createNameDeclaration()
      ' ---------------------------
      Public Function createNameDeclaration ()
        'declare .type: Grammar.TypeDeclaration
        
        'return .declareName(.name,{type:.type})
        return Me.declareName(Me.name, {{type,Me.type}})
      end function

      'helper method declareInScope()
      ' ---------------------------
      Public Function declareInScope ()
          '.nameDecl = .addToScope(.createNameDeclaration())
          Me.nameDecl = Me.addToScope(Me.createNameDeclaration())
      end function

      'helper method connectAlias()
      ' ---------------------------
      Public Function connectAlias ()
          'if .aliasVarRef
          if Me.aliasVarRef Then
          
              '//Example: "public var $ = jQuery" => declare alias $ for jQuery
              'if .aliasVarRef.tryGetReference({informError:true}) into var ref
              Dim ref as Object
              if Assign(ref,Me.aliasVarRef.tryGetReference({{informError,true}})) Then
              
                  '# aliases share .members
                  '.nameDecl.members = ref.members
                  Me.nameDecl.members = ref.members
              
              End if
              
          
          End if
          
      end function

      'helper method getTypeFromAssignedValue()
      ' ---------------------------
      Public Function getTypeFromAssignedValue ()

          '// if it has an assigned value
          'if .nameDecl and .assignedValue and .nameDecl.name isnt 'prototype'
          if Me.nameDecl AndAlso Me.assignedValue AndAlso Me.nameDecl.name <> "prototype" Then
          

              'if .assignedValue instanceof Grammar.Expression
              Dim type as Object
              if TypeOf Me.assignedValue is Grammar.Expression AndAlso new ArrayList From {Grammar.StringLiteral, Grammar.NumberLiteral}
                .Contains(Me.assignedValue.root.name.constructor) Then
              
                    'var theLiteral = .assignedValue.root.name
                    Dim theLiteral = Me.assignedValue.root.name
                    '// if it is assigning a literal, force type to string|number|array
                    '.nameDecl.setMember('**proto**', globalPrototype(theLiteral.type))
                    Me.nameDecl.setMember("**proto**", globalPrototype(theLiteral.type))
              
              'if .assignedValue instanceof Grammar.Expression
              
              elseif Not(Assign(type,Me.nameDecl.findOwnMember("**proto**"))) Then
              
                  'if .assignedValue.getResultType() into var result #get assignedValue type
                  Dim result as Object
                  if Assign(result,Me.assignedValue.getResultType()) Then
                  
                      '.nameDecl.setMember('**proto**', result) #assign to this.nameDecl
                      Me.nameDecl.setMember("**proto**", result)
                  
                  End if
                  
              
              End if
              End if
              
          
          End if
          
      end function
      
    
    End Class 'partial


    '    append to class Grammar.VarStatement ###
    Partial Class Grammar.VarStatement
    

     'method declare()  # pass 1
     ' ---------------------------
     Public Function declare ()

        'var moduleNode:Grammar.Module = .getParent(Grammar.Module)
        Dim moduleNode = Me.getParent(Grammar.Module)
        'var isPublic = .hasAdjective("export")
        Dim isPublic = Me.hasAdjective("export")
        'var isGlobal = .hasAdjective("global")
        Dim isGlobal = Me.hasAdjective("global")

        'for each varDecl in .list
        For Each varDecl in Me.list
        

            'if isGlobal
            if isGlobal Then
            
                'varDecl.nameDecl = varDecl.createNameDeclaration()
                varDecl.nameDecl = varDecl.createNameDeclaration()
                'globalScope.addMember varDecl.nameDecl
                globalScope.addMember(varDecl.nameDecl)
            
            'if isGlobal
            
            else
            
                'varDecl.declareInScope
                varDecl.declareInScope()

                'if isPublic
                if isPublic Then
                

                    'moduleNode.addToExport varDecl.nameDecl
                    moduleNode.addToExport(varDecl.nameDecl)

                    '//mark as isPublicVar to prepend "module.exports.x" when referenced in module body
                    '// except interfaces (no body & vars are probably aliases. case: public var $=jQuery)
                    'if not moduleNode.fileInfo.isInterface
                    if Not(moduleNode.fileInfo.isInterface) Then
                    
                          'varDecl.nameDecl.isExported = true
                          varDecl.nameDecl.isExported = true
                    
                    End if
                    
                
                End if
                
            
            End if
            
        Next'  each in Me.list
        
     end function


     'method evaluateAssignments() # pass 4, determine type from assigned value
     ' ---------------------------
     Public Function evaluateAssignments ()
        'for each varDecl in .list
        For Each varDecl in Me.list
        
            'varDecl.getTypeFromAssignedValue
            varDecl.getTypeFromAssignedValue()
        Next'  each in Me.list
        
     end function
     
    
    End Class 'partial


    '    append to class Grammar.WithStatement ###
    Partial Class Grammar.WithStatement
    

      'properties nameDecl
          Public Property nameDecl as Object

      'method declare()  # pass 1
      ' ---------------------------
      Public Function declare ()
         '.nameDecl = .addToScope(.declareName(.name))
         Me.nameDecl = Me.addToScope(Me.declareName(Me.name))
      end function

      'method evaluateAssignments() # pass 4, determine type from assigned value
      ' ---------------------------
      Public Function evaluateAssignments ()
        '.nameDecl.assignTypeFromValue .varRef
        Me.nameDecl.assignTypeFromValue(Me.varRef)
      end function
      
    
    End Class 'partial


    '    append to class Grammar.ImportStatementItem ###
    Partial Class Grammar.ImportStatementItem
    

      'properties nameDecl
          Public Property nameDecl as Object

      'method declare #pass 1: declare name choosen for imported(required) contents as a scope var
      ' ---------------------------
      Public Function declare ()

        'if no .getParent(Grammar.DeclareStatement) #except for 'global declare'
        if NotMe.getParent(Grammar.DeclareStatement) Then
        

            'if .hasAdjective('shim') and .findInScope(.name), return // do not import if shim and already declared
            if Me.hasAdjective("shim") AndAlso Me.findInScope(Me.name) Then return

            '.nameDecl = .addToScope(.name)
            Me.nameDecl = Me.addToScope(Me.name)
        
        End if
        
      end function
      
    
    End Class 'partial


'----------------------
    '    append to class Grammar.ClassDeclaration
    Partial Class Grammar.ClassDeclaration
    
'derived classes are:  AppendToDeclaration and NamespaceDeclaration

     '     properties
      'nameDecl

     '     method declare() # class
         Public Property nameDecl as Object

     '     method declare() # class
     ' ---------------------------
     Public Function declare ()

'if is a class adjectivated "shim", do not declare if already exists

        'if .hasAdjective('shim')
        if Me.hasAdjective("shim") Then
        
            'if .tryGetFromScope(.name)
            if Me.tryGetFromScope(Me.name) Then
            
                'return
                return
            
            End if
            
        
        End if

        '.nameDecl = .declareName(.name, {type:globalPrototype('Function')} ) //class
        Me.nameDecl = Me.declareName(Me.name, {{type,globalPrototype("Function")}})

        '.selectAndAddToScope .nameDecl
        Me.selectAndAddToScope(Me.nameDecl)

'we create 'Class.prototype' member
'Class's properties & methods will be added to 'prototype' as valid member members.
''prototype' starts with 'constructor' which is a pointer to the class-funcion itself

        'var prtypeNameDecl = .nameDecl.findOwnMember('prototype') or .addMemberTo(.nameDecl,'prototype')
        Dim prtypeNameDecl = Me.nameDecl.findOwnMember("prototype") OrElse Me.addMemberTo(Me.nameDecl, "prototype")
        'if .varRefSuper
        if Me.varRefSuper Then
        
            'prtypeNameDecl.setMember('**proto**',.varRefSuper)
            prtypeNameDecl.setMember("**proto**", Me.varRefSuper)
        
        End if
        '//else
        '//    prtypeNameDecl.setMember('**proto**',globalObjectProto)

        'prtypeNameDecl.addMember('constructor',{pointsTo:.nameDecl})
        prtypeNameDecl.addMember("constructor", {{pointsTo,Me.nameDecl}})

'return type of the class-function, is the prototype

        '.nameDecl.setMember '**return type**',prtypeNameDecl
        Me.nameDecl.setMember("**return type**", prtypeNameDecl)

'add to nameAffinity

        'if not nameAffinity.members.has(.name)
        if Not(nameAffinity.members.has(Me.name)) Then
        
            'nameAffinity.members.set .name, .nameDecl
            nameAffinity.members.set(Me.name, Me.nameDecl)
        
        End if
        
     end function


     '     method validatePropertyAccess()
     ' ---------------------------
     Public Function validatePropertyAccess ()

'in the pass "Validating Property Access", for a "ClassDeclaration"
'we check for duplicate property names in the super-class-chain

        'if .constructor isnt Grammar.ClassDeclaration, return // exclude derived classes
        if Me.constructor <> Grammar.ClassDeclaration Then return

        'var prt:Names.Declaration = .nameDecl.ownMember('prototype')
        Dim prt = Me.nameDecl.ownMember("prototype")
        'for each propNameDecl in map prt.members where propNameDecl.nodeClass is Grammar.VariableDecl
        for Each item in prt.members
                Dim propNameDecl__propName as string = item.key
                Dim propNameDecl=item.value
        if propNameDecl.nodeClass = Grammar.VariableDecl Then
        
                'propNameDecl.checkSuperChainProperties .nameDecl.superDecl
                propNameDecl.checkSuperChainProperties(Me.nameDecl.superDecl)
        End if
        Next'  for each item in map
        
     end function
     
    
    End Class 'partial


    '    append to class Grammar.NamespaceDeclaration
    Partial Class Grammar.NamespaceDeclaration
    
     '     method declare()
     ' ---------------------------
     Public Function declare ()

        'if .hasAdjective('shim')
        if Me.hasAdjective("shim") Then
        
            'if .tryGetFromScope(.name)
            if Me.tryGetFromScope(Me.name) Then
            
                'return
                return
            
            End if
            
        
        End if

'declare the namespace. namespaces also create a scope

        '.nameDecl = .declareName(.name)
        Me.nameDecl = Me.declareName(Me.name)
        '.createScope
        Me.createScope()

        '.selectAndAddToScope .nameDecl
        Me.selectAndAddToScope(Me.nameDecl)
     end function
     
    
    End Class 'partial


    '    append to class Grammar.AppendToDeclaration
    Partial Class Grammar.AppendToDeclaration
    
     '     method declare()
     ' ---------------------------
     Public Function declare ()
'AppendToDeclarations do not "declare" anything at this point.

'AppendToDeclarations add to a existing classes or namespaces.
'The adding is delayed until pass:"processAppendToExtends",
'where append-To var reference is searched in the scope
'and methods and properties are added.
'This need to be done after all declarations.

      'do nothing
      Do Nothing
     end function
     
    
    End Class 'partial

'----------------------------

    '    append to class Grammar.ArrayLiteral ###
    Partial Class Grammar.ArrayLiteral
    

     'properties nameDecl
         Public Property nameDecl as Object

     'method declare
     ' ---------------------------
     Public Function declare ()

'When producing C-code, an ArrayLiteral creates a "new(Array" at module level

        'if project.options.target isnt 'js'
        if project.options.target <> "js" Then
        
            '.nameDecl = .declareName(UniqueID.getVarName('_literalArray'))
            Me.nameDecl = Me.declareName(UniqueID.getVarName("_literalArray"))
            '.getParent(Grammar.Module).addToScope .nameDecl
            Me.getParent(Grammar.Module).addToScope(Me.nameDecl)
        
        End if
        
     end function

     'method getResultType
     ' ---------------------------
     Public Function getResultType ()
          'return tryGetGlobalPrototype('Array')
          return tryGetGlobalPrototype("Array")
     end function
     
    
    End Class 'partial


    '    append to class Grammar.ObjectLiteral ###
    Partial Class Grammar.ObjectLiteral
    

     'properties nameDecl
         Public Property nameDecl as Object

     'method declare
     ' ---------------------------
     Public Function declare ()

'When producing js-code, an ObjectLiteral declares a new ad-hoc "type".
'The var is assigned this ad-hoc "type"

'When producing c-code, an ObjectLiteral creates a "Map string to any" on the fly,
'so *it does not declare a type with members*

        'if project.options.target is 'js'
        if project.options.target = "js" Then
        

'if the .parent has a .nameDecl we copy that so members get added there.
'if it does not, create a new one (we're a interal LiteralObject, 'value'
'of a name:value pair)

          '.nameDecl = .parent.tryGetProperty('nameDecl')
          Me.nameDecl = Me.parent.tryGetProperty("nameDecl")

          'if no .nameDecl
          if NotMe.nameDecl Then
          
              '.nameDecl = .declareName(UniqueID.getVarName('*ObjectLiteral*'))
              Me.nameDecl = Me.declareName(UniqueID.getVarName("*ObjectLiteral*"))
          
          End if
          
        
        End if
        
     end function

'When producing the LiteScript-to-C compiler, a ObjectLiteral's return type is 'Map string to any'

'When producing js-code is the ad-hoc type created for the ObjectLiteral

     'method getResultType
     ' ---------------------------
     Public Function getResultType ()

        'if project.options.target isnt 'js'
        if project.options.target <> "js" Then
        
            'return tryGetGlobalPrototype('Map')
            return tryGetGlobalPrototype("Map")
        
        'if project.options.target isnt 'js'
        
        else
        
            'return  .nameDecl
            return Me.nameDecl
        
        End if
        
     end function
     
    
    End Class 'partial


    '    append to class Grammar.NameValuePair ###
    Partial Class Grammar.NameValuePair
    

     'properties nameDecl
         Public Property nameDecl as Object

     'method declare
     ' ---------------------------
     Public Function declare ()

'When producing C-code, a ObjectLiteral creates a "Map string to any" on the fly,
'but it does not declare a valid type/class.

        'if project.options.target isnt 'js', return
        if project.options.target <> "js" Then return

'Add this name as member of the parent ObjectLiteral/Value

        'declare .parent: Grammar.ObjectLiteral
        
        'if no .parent.nameDecl
        if NotMe.parent.nameDecl Then
        
          '.sayErr "cannot add #{.name}, no parent.nameDecl. Parent=#{.parent}"
          Me.sayErr("cannot add " + Me.name + ", no parent.nameDecl. Parent=" + Me.parent)
        
        'if no .parent.nameDecl
        
        else
        
          '.nameDecl = .addMemberTo(.parent.nameDecl, .name)
          Me.nameDecl = Me.addMemberTo(Me.parent.nameDecl, Me.name)
        
        End if

'check if we can determine type from value

        'if .type
        if Me.type Then
        
            '.nameDecl.setMember '**proto**', .type
            Me.nameDecl.setMember("**proto**", Me.type)
        
        'if .type
        
        elseif Me.value Then
        
            '.nameDecl.assignTypeFromValue .value
            Me.nameDecl.assignTypeFromValue(Me.value)
        
        End if
        End if
        
     end function
     
    
    End Class 'partial

    '    append to class Grammar.FunctionDeclaration ###
    Partial Class Grammar.FunctionDeclaration
    
'`FunctionDeclaration: '[export][generator] (function|method|constructor) [name] '(' FunctionParameterDecl* ')' Block`

     'properties
        'nameDecl
        'declared:boolean

     '     method declare() ## function, methods and constructors
         Public Property nameDecl as Object
         Public Property declared as Boolean' mainType: Boolean  
     

     '     method declare() ## function, methods and constructors
     ' ---------------------------
     Public Function declare ()

      'var ownerNameDecl
      Dim ownerNameDecl = Nothing
      'var isMethod = .constructor is Grammar.MethodDeclaration
      Dim isMethod = Me.constructor = Grammar.MethodDeclaration
      'var isFunction = .constructor is Grammar.FunctionDeclaration
      Dim isFunction = Me.constructor = Grammar.FunctionDeclaration

'1st: Grammar.FunctionDeclaration

'if not anonymous, add function name to parent scope,

      'if isFunction
      if isFunction Then
      
          'if .name
          if Me.name Then
          
              '.nameDecl = .declareName(.name)
              Me.nameDecl = Me.declareName(Me.name)
              '.selectAndAddToScope .nameDecl
              Me.selectAndAddToScope(Me.nameDecl)
          
          End if
          
      
      End if

'2nd: Methods & constructors

'Try to determine ownerNameDecl, to declare the memeber and to set scope var "this"'s **proto**.
'if ownerNameDecl *can* be determined at this point, declare method as member.

      'ownerNameDecl = .tryGetOwnerNameDecl()
      ownerNameDecl = Me.tryGetOwnerNameDecl()

      'if isMethod and .name and ownerNameDecl
      if isMethod AndAlso Me.name AndAlso ownerNameDecl Then
      

          '.addMethodToOwnerNameDecl ownerNameDecl
          Me.addMethodToOwnerNameDecl(ownerNameDecl)
      
      End if

      'end if // function or method

'Note: following JS design, constructors are the body of the function-class itself,
'so the "constructor" is not a member function

'Define function's return type from parsed text

      'var returnType = .createReturnType()
      

'Note: following JS design, constructors are the body of the function-class itself,
'so the "constructor" is not a member function

'Define function's return type from parsed text

      'var returnType = .createReturnType()
      Dim returnType = Me.createReturnType()

'Functions (methods and constructors also), have a 'scope'.
'It captures al vars declared in its body.
'We now create function's scope and add the special var 'this'.
'The 'type' of 'this' is normally a class prototype,
'which contains other methods and properties from the class.
'We also add 'arguments.length'

'Scope starts populated by 'this' and 'arguments'.

      'var scope = .createScope()
      Dim scope = Me.createScope()

      '.addMemberTo scope,'arguments', {type:'any*', nodeClass:Grammar.VariableDecl}
      Me.addMemberTo(scope, "arguments", {{type,"any*"}, {nodeClass,Grammar.VariableDecl}})


      '// NOTE: in js there's a "this" everywhere. In browser mode,
      '// "this" on a global function is normally used when such function is registered as
      '// a DOM node event handler (this=DOM node triggering the event)

      'var typeOfThis
      Dim typeOfThis = Nothing

      'if isFunction
      if isFunction Then
      
          '//for "functions" add a "this" without type
          'do nothing
          Do Nothing
      
      'if isFunction
      
      else
      
          '//for "methods", "this" :type is the class prototype

          'if no .getParent(Grammar.ClassDeclaration) into var containerClassDeclaration //also append-to & NamespaceDeclaration
          Dim containerClassDeclaration as Object
          if Not(Assign(containerClassDeclaration,Me.getParent(Grammar.ClassDeclaration))) Then
          
              '.sayErr "method outside class|namespace|apeend-to"
              Me.sayErr("method outside class|namespace|apeend-to")
              'return
              return
          
          End if

          'if containerClassDeclaration.constructor is Grammar.ClassDeclaration
          if containerClassDeclaration.constructor = Grammar.ClassDeclaration Then
          
              'typeOfThis = ownerNameDecl
              typeOfThis = ownerNameDecl
          
          'if containerClassDeclaration.constructor is Grammar.ClassDeclaration
          
          elseif containerClassDeclaration.constructor = Grammar.AppendToDeclaration Then
          
              'declare containerClassDeclaration:Grammar.AppendToDeclaration
              
              'typeOfThis = containerClassDeclaration.varRef
              typeOfThis = containerClassDeclaration.varRef
          
          End if
          End if
          
      
      End if

      'end if //select typeOfThis

      '.addMemberTo(scope,'this',{type:typeOfThis,nodeClass:Grammar.VariableDecl})
      

      '.addMemberTo(scope,'this',{type:typeOfThis,nodeClass:Grammar.VariableDecl})
      Me.addMemberTo(scope, "this", {{type,typeOfThis}, {nodeClass,Grammar.VariableDecl}})

'Note: only class methods have 'this' as parameter

'add parameters to function's scope

      'if .paramsDeclarations
      if Me.paramsDeclarations Then
      
          'for each varDecl in .paramsDeclarations.list
          For Each varDecl in Me.paramsDeclarations.list
          
              'varDecl.declareInScope
              varDecl.declareInScope()
          Next'  each in Me.paramsDeclarations.list
          
      
      End if
      
     end function


     '     helper method addMethodToOwnerNameDecl(owner:Names.Declaration)  ## methods
     ' ---------------------------
     Public Function addMethodToOwnerNameDecl (owner)

      'var actual = owner.findOwnMember(.name)
      Dim actual = owner.findOwnMember(Me.name)

      'if actual and .hasAdjective('shim') #shim for an exising method, do nothing
      if actual AndAlso Me.hasAdjective("shim") Then
      
        'return
        return
      
      End if

'Add to owner, type is 'Function'

      'if no .nameDecl
      if NotMe.nameDecl Then
      
          '.nameDecl = .declareName(.name,{type:globalPrototype('Function')})
          Me.nameDecl = Me.declareName(Me.name, {{type,globalPrototype("Function")}})
      
      End if

      '.declared = true
      Me.declared = true

      '.addMemberTo owner, .nameDecl
      Me.addMemberTo(owner, Me.nameDecl)
     end function


     '     method createReturnType() ## functions & methods
     ' ---------------------------
     Public Function createReturnType ()

      'if no .nameDecl, return #nowhere to put definitions
      if NotMe.nameDecl Then return

      '.nameDecl.setMember "**proto**", globalPrototype('Function')
      Me.nameDecl.setMember("**proto**", globalPrototype("Function"))

'Define function's return type from parsed text

      'if .type and .type.itemType
      if Me.type AndAlso Me.type.itemType Then
      

'if there's a "itemType", it means type is: `array of [itemType]`
'We create a intermediate type for `Array of itemType`
'and set this new nameDecl as function's **return type**

          'var composedName = 'Array of #{.type.itemType.toString()}'
          Dim composedName = "Array of " + (Me.type.itemType.toString())

'check if it already exists, if not found, create one. Type is 'Array'

          'if not globalScope.findMember(composedName) into var intermediateNameDecl
          Dim intermediateNameDecl as Object
          if Not(Assign(intermediateNameDecl,globalScope.findMember(composedName))) Then
          
              'intermediateNameDecl = globalScope.addMember(composedName, {
                    'type:globalPrototype('Array')
                    'nodeClass:Grammar.ClassDeclaration
                    '})
              intermediateNameDecl = globalScope.addMember(composedName, {{type,globalPrototype("Array")}, {nodeClass,Grammar.ClassDeclaration}})
          
          End if

'item type, is each array member's type

          'intermediateNameDecl.setMember "**item type**", .type.itemType
          intermediateNameDecl.setMember("**item type**", Me.type.itemType)

          '.nameDecl.setMember '**return type**', intermediateNameDecl
          Me.nameDecl.setMember("**return type**", intermediateNameDecl)
      
      'if .type and .type.itemType
      
      else
      

          'if .type, .nameDecl.setMember('**return type**', .type)
          if Me.type Then Me.nameDecl.setMember("**return type**", Me.type)
      
      End if
      
     end function
     
    
    End Class 'partial


    '    append to class Grammar.AppendToDeclaration ###
    Partial Class Grammar.AppendToDeclaration
    

     '     method processAppendToExtends()
     ' ---------------------------
     Public Function processAppendToExtends ()

'get referenced class/namespace

      'if no .varRef.tryGetReference() into var ownerDecl
      Dim ownerDecl as Object
      if Not(Assign(ownerDecl,Me.varRef.tryGetReference())) Then
      
          '.sayErr "Append to: '#{.varRef}'. Reference is not fully declared"
          Me.sayErr("Append to: '" + Me.varRef + "'. Reference is not fully declared")
          'return //if no ownerDecl found
          return
      
      End if

      'if not .toNamespace
      if Not(Me.toNamespace) Then
      
          '//if is "append to class"
          'if no ownerDecl.findOwnMember('prototype') into var prt
          Dim prt as Object
          if Not(Assign(prt,ownerDecl.findOwnMember("prototype"))) Then
          
              '.throwError "Append to: class '#{ownerDecl}' has no prototype"
              Me.throwError("Append to: class '" + ownerDecl + "' has no prototype")
          
          End if

          'ownerDecl=prt // append to class, adds to prototype
          ownerDecl = prt
      
      End if

      '//if project.options.target is 'c'
      '//    if .toNamespace and prt
      '//        .sayErr "Append to: '#{.varRef}'. For C production, cannot append to class as namespace."

      'for each item in .body.statements
      For Each item in Me.body.statements
      

          'case item.specific.constructor
          select item.specific.constructor
          case Grammar.PropertiesDeclaration
          
                  'declare item.specific:Grammar.PropertiesDeclaration
                  
                  'if not item.specific.declared, item.specific.declare(informError=true)
                  if Not(item.specific.declared) Then item.specific.declare(true)
          
          
          case Grammar.MethodDeclaration
          
                  'var m:Grammar.MethodDeclaration = item.specific
                  Dim m = item.specific
                  'if m.declared, continue
                  if m.declared Then continue

'Now that we have 'owner' we can set **proto** for scope var 'this',
'so we can later validate `.x` in `this.x = 7`

                  'm.addMethodToOwnerNameDecl ownerDecl
                  m.addMethodToOwnerNameDecl(ownerDecl)

                  'if m.scope.findOwnMember("this") into var scopeThis
                  Dim scopeThis as Object
                  if Assign(scopeThis,m.scope.findOwnMember("this")) Then
                  
                      'scopeThis.setMember '**proto**',ownerDecl
                      scopeThis.setMember("**proto**", ownerDecl)
                      '#set also **return type**
                      'm.createReturnType
                      m.createReturnType()
                  
                  End if
                  
          
          
          case Grammar.ClassDeclaration
          
                  'declare item.specific:Grammar.ClassDeclaration
                  
                  'ownerDecl.addMember item.specific.nameDecl
                  ownerDecl.addMember(item.specific.nameDecl)
          
          
          case Grammar.EndStatement
          
                  'do nothing
                  Do Nothing
          
          
          
          case else
          
                  '.sayErr 'unexpected "#{item.specific.constructor.name}" inside Append-to Declaration'
                  Me.sayErr("unexpected "" + item.specific.constructor.name + "" inside Append-to Declaration")
          
          
      Next'  each in Me.body.statements
      
     end function
     
    
    End Class 'partial


    '    append to class Names.Declaration ###
    Partial Class Names.Declaration
    
     '     properties
      'superDecl : Names.Declaration //nameDecl of the super class

     '     method checkSuperChainProperties(superClassNameDecl)
         Public Property superDecl as Names.Declaration' mainType: Names.Declaration  
     

     '     method checkSuperChainProperties(superClassNameDecl)
     ' ---------------------------
     Public Function checkSuperChainProperties (superClassNameDecl)

        'if no superClassNameDecl, return
        if NotsuperClassNameDecl Then return

'Check for duplicate class properties in the super class

        'if superClassNameDecl.findOwnMember('prototype') into var superPrt:Names.Declaration
        Dim superPrt as Object
        if Assign(superPrt,superClassNameDecl.findOwnMember("prototype")) Then
        

            'if superPrt.findOwnMember(.name) into var originalNameDecl
            Dim originalNameDecl as Object
            if Assign(originalNameDecl,superPrt.findOwnMember(Me.name)) Then
            
                '.sayErr "Duplicated property. super class [#{superClassNameDecl}] already has a property '#{this}'"
                Me.sayErr("Duplicated property. super class [" + superClassNameDecl + "] already has a property '" + Me + "'")
                'originalNameDecl.sayErr "for reference, original declaration."
                originalNameDecl.sayErr("for reference, original declaration.")
            
            End if

'recurse with super's super. Here we're using recursion as a loop device à la Haskell
'(instead of a simpler "while .superDecl into node" loop. Just to be fancy)

            '.checkSuperChainProperties superClassNameDecl.superDecl
            Me.checkSuperChainProperties(superClassNameDecl.superDecl)
        
        End if
        
     end function
     
    
    End Class 'partial

    '    append to class Grammar.ClassDeclaration ###
    Partial Class Grammar.ClassDeclaration
    

     '     method processAppendToExtends()
     ' ---------------------------
     Public Function processAppendToExtends ()
'In Class's processAppendToExtends we try to get a reference to the superclass
'and then store the superclass nameDecl in the class nameDecl

'get referenced super class

      'if .varRefSuper
      if Me.varRefSuper Then
      
          'if no .varRefSuper.tryGetReference() into var superClassNameDecl
          Dim superClassNameDecl as Object
          if Not(Assign(superClassNameDecl,Me.varRefSuper.tryGetReference())) Then
          
              '.sayErr "class #{.name} extends '#{.varRefSuper}'. Reference is not fully declared"
              Me.sayErr("class " + Me.name + " extends '" + Me.varRefSuper + "'. Reference is not fully declared")
              'return //if no superClassNameDecl found
              return
          
          End if

          '.nameDecl.superDecl = superClassNameDecl
          Me.nameDecl.superDecl = superClassNameDecl
      
      End if
      
     end function
     
    
    End Class 'partial

    '    append to class Grammar.PropertiesDeclaration ###
    Partial Class Grammar.PropertiesDeclaration
    

     'properties
        'nameDecl
        'declared:boolean

     '     method declare(informError)
         Public Property nameDecl as Object
         Public Property declared as Boolean' mainType: Boolean  
     

     '     method declare(informError)
     ' ---------------------------
     Public Function declare (informError)
'Add all properties as members of its owner object (normally: class.prototype)

        'if .tryGetOwnerNameDecl(informError) into var ownerNameDecl
        Dim ownerNameDecl as Object
        if Assign(ownerNameDecl,Me.tryGetOwnerNameDecl(informError)) Then
        

            'for each varDecl in .list
            For Each varDecl in Me.list
            
                'varDecl.nameDecl = varDecl.addMemberTo(ownerNameDecl,varDecl.name,{type:varDecl.type})
                varDecl.nameDecl = varDecl.addMemberTo(ownerNameDecl, varDecl.name, {{type,varDecl.type}})
            Next'  each in Me.list
            'end for

            '.declared = true
            

            '.declared = true
            Me.declared = true
        
        End if
        
     end function

     '     method evaluateAssignments() # determine type from assigned value on properties declaration
     ' ---------------------------
     Public Function evaluateAssignments ()

        'for each varDecl in .list
        For Each varDecl in Me.list
        
            'varDecl.getTypeFromAssignedValue
            varDecl.getTypeFromAssignedValue()
        Next'  each in Me.list
        
     end function
     
    
    End Class 'partial



    '    append to class Grammar.ForStatement ###
    Partial Class Grammar.ForStatement
    

     '     method declare()
     ' ---------------------------
     Public Function declare ()

'a ForStatement has a 'Scope', keyIndexVar & valueVar belong to the scope

        '.createScope
        Me.createScope()
     end function
     
    
    End Class 'partial

    '    append to class Grammar.ForEachProperty ###
    Partial Class Grammar.ForEachProperty
    

     '     method declare()
     ' ---------------------------
     Public Function declare ()

        'if .iterable.type
        if Me.iterable.type Then
        
            'default .valueVar.type = .iterable.type.itemType
            if ismissing(Me.valueVar.type) then Me.valueVar.type=Me.iterable.type.itemType: end if
            
        
        End if

        '.valueVar.declareInScope
        Me.valueVar.declareInScope()

        'if .keyIndexVar, .keyIndexVar.declareInScope
        if Me.keyIndexVar Then Me.keyIndexVar.declareInScope()
     end function

     '     method evaluateAssignments()
     ' ---------------------------
     Public Function evaluateAssignments ()

'ForEachProperty: index is: string for js (property name) and number for C (symbol)

        'if .keyIndexVar
        if Me.keyIndexVar Then
        

            'var indexType = project.options.target is 'js'? 'String':'Number'
            Dim indexType = project.options.target = "js" ? "String" : "Number"
            '.keyIndexVar.nameDecl.setMember('**proto**',globalPrototype(indexType))
            Me.keyIndexVar.nameDecl.setMember("**proto**", globalPrototype(indexType))
        
        End if
        
     end function
     
    
    End Class 'partial

    '    append to class Grammar.ForEachInArray ###
    Partial Class Grammar.ForEachInArray
    

     '     method declare()
     ' ---------------------------
     Public Function declare ()

        'if .iterable.type
        if Me.iterable.type Then
        
            'default .valueVar.type = .iterable.type.itemType
            if ismissing(Me.valueVar.type) then Me.valueVar.type=Me.iterable.type.itemType: end if
            
        
        End if

        '.valueVar.declareInScope
        Me.valueVar.declareInScope()

        'if .keyIndexVar, .keyIndexVar.declareInScope
        if Me.keyIndexVar Then Me.keyIndexVar.declareInScope()

        'if .intIndexVar, .intIndexVar.declareInScope
        if Me.intIndexVar Then Me.intIndexVar.declareInScope()
     end function

     '     method evaluateAssignments()
     ' ---------------------------
     Public Function evaluateAssignments ()

'ForEachInArray:
'If no valueVar.type, guess type from iterable's itemType

        'if no .valueVar.nameDecl.findOwnMember('**proto**')
        if NotMe.valueVar.nameDecl.findOwnMember("**proto**") Then
        
            'var iterableType:Names.Declaration = .iterable.getResultType()
            Dim iterableType = Me.iterable.getResultType()
            'if iterableType and iterableType.findOwnMember('**item type**')  into var itemType
            Dim itemType as Object
            if iterableType AndAlso Assign(itemType,iterableType.findOwnMember("**item type**")) Then
            
                '.valueVar.nameDecl.setMember('**proto**',itemType)
                Me.valueVar.nameDecl.setMember("**proto**", itemType)
            
            End if
            
        
        End if
        
     end function

     '     method validatePropertyAccess()
     ' ---------------------------
     Public Function validatePropertyAccess ()
'ForEachInArray: check if the iterable has a .length property.

        'if .isMap, return
        if Me.isMap Then return

        'var iterableType:Names.Declaration = .iterable.getResultType()
        Dim iterableType = Me.iterable.getResultType()

        'if no iterableType
        if NotiterableType Then
        
            '#.sayErr "ForEachInArray: no type declared for: '#{.iterable}'"
            'do nothing
            Do Nothing
        
        'if no iterableType
        
        elseif NotiterableType.findMember("length") Then
        
            '.sayErr "ForEachInArray: no .length property declared in '#{.iterable}' type:'#{iterableType.toString()}'"
            Me.sayErr("ForEachInArray: no .length property declared in '" + Me.iterable + "' type:'" + (iterableType.toString()) + "'")
            'logger.error iterableType.originalDeclarationPosition()
            logger.error(iterableType.originalDeclarationPosition())
        
        End if
        End if
        
     end function
     
    
    End Class 'partial

    '    append to class Grammar.ForIndexNumeric ###
    Partial Class Grammar.ForIndexNumeric
    

     '     method declare()
     ' ---------------------------
     Public Function declare ()

        '.keyIndexVar.declareInScope
        Me.keyIndexVar.declareInScope()
     end function
     
    
    End Class 'partial


    '    append to class Grammar.ExceptionBlock
    Partial Class Grammar.ExceptionBlock
    
'`ExceptionBlock: (exception|catch) catchVar-IDENTIFIER Body [finally Body]`

      'method declare()
      ' ---------------------------
      Public Function declare ()

'Exception blocks have a scope

        '.createScope
        Me.createScope()
        '.addToScope .catchVar,{type:globalPrototype('Error')}
        Me.addToScope(Me.catchVar, {{type,globalPrototype("Error")}})
      end function
      
    
    End Class 'partial


    '    append to class Grammar.VariableRef ### Helper methods
    Partial Class Grammar.VariableRef
    

'`VariableRef: ['--'|'++']Identifier[Accessors]['--'|'++']`

'`VariableRef` is a Variable Reference.

     '     method validatePropertyAccess()
     ' ---------------------------
     Public Function validatePropertyAccess ()

        'if .parent is instance of Grammar.DeclareStatement
        if TypeOf Me.parent is Grammar.DeclareStatement Then
        
            'declare valid .parent.specifier
            
            'if .parent.specifier is 'valid'
            if Me.parent.specifier = "valid" Then
            
                  'return #declare valid xx.xx.xx
                  return
            
            End if
            
        
        End if

'Start with main variable name, to check property names

        'var actualVar = .tryGetFromScope(.name, {
                                'informError:true
                                'isForward:true
                                'isDummy:true
                                'nodeClass: Grammar.VariableDecl
                          '})
        Dim actualVar = Me.tryGetFromScope(Me.name, {{informError,true}, {isForward,true}, {isDummy,true}, {nodeClass,Grammar.VariableDecl}})

'now follow each accessor

        'if no actualVar or no .accessors, return
        if NotactualVar OrElse NotMe.accessors Then return

        'for each ac in .accessors
        For Each ac in Me.accessors
        
            'declare valid ac.name
            

'for PropertyAccess, check if the property name is valid

            'if ac instanceof Grammar.PropertyAccess
            if TypeOf ac is Grammar.PropertyAccess Then
            
                'actualVar = .tryGetMember(actualVar, ac.name, {
                                'informError:true
                                'isDummy:true
                                'nodeClass: Grammar.VariableDecl
                          '})
                actualVar = Me.tryGetMember(actualVar, ac.name, {{informError,true}, {isDummy,true}, {nodeClass,Grammar.VariableDecl}})
            
            'if ac instanceof Grammar.PropertyAccess
            
            elseif TypeOf ac is Grammar.IndexAccess Then
            
                'actualVar = actualVar.findMember('**item type**')
                actualVar = actualVar.findMember("**item type**")
            
            'else if ac instanceof Grammar.IndexAccess
            
            elseif TypeOf ac is Grammar.FunctionAccess Then
            
                'declare ac:Grammar.FunctionAccess
                

                'if no actualVar.findMember('call') and no actualVar.findMember('prototype')
                if NotactualVar.findMember("call") AndAlso NotactualVar.findMember("prototype") Then
                
                '//if actualVar.findOwnMember('**proto**') into var prt
                '//    if prt.name is 'prototype', prt=prt.parent
                '//    if prt.name isnt 'Function'
                        '//.warn "function call. '#{actualVar}' is class '#{prt.name}', not 'Function'"
                        '.warn "function call. #{actualVar.info()} has no method 'call' nor 'prototype', it is not type:Function or Class"
                        Me.warn("function call. " + (actualVar.info()) + " has no method 'call' nor 'prototype', it is not type:Function or Class")
                
                End if

'Validate arguments against function parameters declaration

                'if actualVar.nodeDeclared instanceof Grammar.FunctionDeclaration
                if TypeOf actualVar.nodeDeclared is Grammar.FunctionDeclaration OrElse actualVar.nodeDeclared.constructor = Grammar.ClassDeclaration Then
                
                        'ac.composeArgumentsList actualVar
                        ac.composeArgumentsList(actualVar)
                
                End if

                'actualVar = actualVar.findMember('**return type**')
                actualVar = actualVar.findMember("**return type**")
            
            End if
            End if
            End if

'if actualVar is a VarRef, find type in scope

            'if actualVar instanceof Grammar.VariableRef
            if TypeOf actualVar is Grammar.VariableRef Then
            
                '.sayErr  "actualVar instanceof Grammar.VariableRef: #{actualVar.toString()}"
                Me.sayErr("actualVar instanceof Grammar.VariableRef: " + (actualVar.toString()))
                'declare actualVar:Grammar.VariableRef
                
                'actualVar = actualVar.tryGetReference({
                                'informError:true
                                'isForward:true
                                'isDummy:true
                                'nodeClass: Grammar.VariableDecl
                          '})
                actualVar = actualVar.tryGetReference({{informError,true}, {isForward,true}, {isDummy,true}, {nodeClass,Grammar.VariableDecl}})
            
            End if

            'if no actualVar, break
            if NotactualVar Then break
        Next'  each in Me.accessors

        'end for #each accessor

        'return actualVar
        

        'return actualVar
        return actualVar
     end function


     '     helper method tryGetReference(options:Names.DeclarationOptions) returns Names.Declaration
     ' ---------------------------
     Public Function tryGetReference (options)

'evaluate this VariableRef.
'Try to determine referenced NameDecl.
'if we can reach a reference, return reference.
'For classes, return ClassDeclaration.nameDecl (not ClassDeclaration.nameDecl.prototype)

        'default options= new Names.DeclarationOptions
        if ismissing(options) then options=new Names.DeclarationOptions(): end if

'Start with main variable name

        'var actualVar = .tryGetFromScope(.name, options)
        Dim actualVar = Me.tryGetFromScope(Me.name, options)
        'if no actualVar, return
        if NotactualVar Then return

'now check each accessor

        'if no .accessors, return actualVar
        if NotMe.accessors Then return actualVar

        'var partial = .name
        Dim partial = Me.name

        'for each ac in .accessors
        For Each ac in Me.accessors
        
            'declare valid ac.name
            

'for PropertyAccess

            'if ac instanceof Grammar.PropertyAccess
            if TypeOf ac is Grammar.PropertyAccess Then
            
                'actualVar = .tryGetMember(actualVar, ac.name, options)
                actualVar = Me.tryGetMember(actualVar, ac.name, options)
            
            'if ac instanceof Grammar.PropertyAccess
            
            elseif TypeOf ac is Grammar.IndexAccess Then
            
                'actualVar = .tryGetMember(actualVar, '**item type**')
                actualVar = Me.tryGetMember(actualVar, "**item type**")
            
            'else if ac instanceof Grammar.IndexAccess
            
            elseif TypeOf ac is Grammar.FunctionAccess Then
            
                'actualVar = .tryGetMember(actualVar, '**return type**')
                actualVar = Me.tryGetMember(actualVar, "**return type**")
            
            End if
            End if
            End if

'check if we can continue on the chain

            'if actualVar isnt instance of Names.Declaration
            if Not (TypeOf actualVar is Names.Declaration) Then
            
              'actualVar = undefined
              actualVar = undefined
              'break
              break
            
            'if actualVar isnt instance of Names.Declaration
            
            else
            
              'partial += ac.toString()
              partial += ac.toString()
            
            End if
            
        Next'  each in Me.accessors

        'end for #each accessor

        'if no actualVar and options.informError
        

        'if no actualVar and options.informError
        if NotactualVar AndAlso options.informError Then
        
            '.sayErr "'#{this}'. Reference can not be analyzed further than '#{partial}'"
            Me.sayErr("'" + Me + "'. Reference can not be analyzed further than '" + partial + "'")
        
        End if

        'return actualVar
        return actualVar
     end function

     '     helper method getResultType() returns Names.Declaration
     ' ---------------------------
     Public Function getResultType ()

      'return .tryGetReference()
      return Me.tryGetReference()
     end function
     
    
    End Class 'partial


    '    append to class Grammar.FunctionAccess
    Partial Class Grammar.FunctionAccess
    

      '      helper method composeArgumentsList(actualVar:Names.Declaration) returns array
      ' ---------------------------
      Public Function composeArgumentsList (actualVar)

        'var argsLength = .args? .args.length else 0
        Dim argsLength = Me.args ? Me.args.length : 0

        'var actualArgs=new Array(argsLength)
        Dim actualArgs = new Array(argsLength)
        'var argumentSet=new Array(argsLength)
        Dim argumentSet = new Array(argsLength)
        'var isClass: boolean
        Dim isClass = Nothing
        'var funcDecl: Grammar.FunctionDeclaration
        Dim funcDecl = Nothing
        'var fnParams: Grammar.FunctionParameters
        Dim fnParams = Nothing

        'var typeAny: Names.Declaration = .findInScope('any');
        Dim typeAny = Me.findInScope("any")

'locate the FunctionDeclaration for the function we're calling

        'if actualVar and actualVar.nodeDeclared
        if actualVar AndAlso actualVar.nodeDeclared Then
        

            'if actualVar.nodeDeclared instanceof Grammar.FunctionDeclaration
            if TypeOf actualVar.nodeDeclared is Grammar.FunctionDeclaration Then
            
                'funcDecl = actualVar.nodeDeclared
                funcDecl = actualVar.nodeDeclared
            
            'if actualVar.nodeDeclared instanceof Grammar.FunctionDeclaration
            
            elseif actualVar.nodeDeclared.constructor = Grammar.ClassDeclaration Then
            

                'isClass = true
                isClass = true
                'var classNameDecl = actualVar, classDecl: Grammar.ClassDeclaration
                Dim classNameDecl = actualVar, classDecl = Nothing
                '// search upward in the hierarchy looking for a declared constructor
                'do while classNameDecl.nodeDeclared into classDecl
                Do whileAssign(classDecl,classNameDecl.nodeDeclared)
                
                    'if classDecl.constructorDeclaration into funcDecl, break //has a explicit constructor, got it
                    if Assign(funcDecl,classDecl.constructorDeclaration) Then break
                    'if no classDecl.varRefSuper, break //no super => super is Object => no explicit constructor
                    if NotclassDecl.varRefSuper Then break
                    'classNameDecl = classDecl.varRefSuper.tryGetReference({informError:true}) //jump to super name declaration
                    classNameDecl = classDecl.varRefSuper.tryGetReference({{informError,true}})
                
                Loop
                
            
            End if
            End if
            
        
        End if

'If we can't locate function declaration, we assume variadic and all types matching / default constructor

        'if no funcDecl
        if NotfuncDecl Then
        

            'if argsLength is 0
            if argsLength = 0 Then
            
                'return actualArgs // a call with no arguments
                return actualArgs
            
            End if

            'if isClass //no funcDecl & isClass => calling a *default* constructor
            if isClass Then
            

                'var firstArg = .args[0]
                Dim firstArg = Me.args(0)

                'if argsLength > 1
                if argsLength > 1 OrElse firstArg.expression.operandCount <> 1 OrElse Not (TypeOf firstArg.expression.root.name is Grammar.ObjectLiteral) Then
                
                        '.sayErr "class [#{actualVar}] default constructor accepts only one argument: a instance literal"
                        Me.sayErr("class [" + actualVar + "] default constructor accepts only one argument: a instance literal")
                
                End if

                '// compose a call with _fastNew - single arg
                'actualArgs[0] = firstArg.calcParam(actualVar,0)
                actualArgs(0) = firstArg.calcParam(actualVar, 0)
                'return actualArgs
                return actualArgs
            
            End if

            '//calling an unknown function
            'for each inx,arg in .args
            Dim inx as Integer =0
            For Each arg in Me.args
            
                'if arg.name, .sayErr "cannot determine function being called => cannot use named arguments"
                if arg.name Then Me.sayErr("cannot determine function being called => cannot use named arguments")
                'actualArgs[inx] = arg.calcParam(typeAny,0)
                actualArgs(inx) = arg.calcParam(typeAny, 0)
            Next'  each in Me.args

            'return actualArgs
            return actualArgs
        
        End if

        'end if no funcDecl

'Here we have located a funcDecl, we:
'- check parameter count / variadic fn
'- reorder named arguments if present
'- call _fastNew on instance literals

        'var funcParamsLength = funcDecl.paramsDeclarations.list.length
        

'Here we have located a funcDecl, we:
'- check parameter count / variadic fn
'- reorder named arguments if present
'- call _fastNew on instance literals

        'var funcParamsLength = funcDecl.paramsDeclarations.list.length
        Dim funcParamsLength = funcDecl.paramsDeclarations.list.length
        'var paramPosition, paramNamesSet=[], namedParamOptionUsed:boolean
        Dim 
            paramPosition = Nothing
            , paramNamesSet = new ArrayList
            , namedParamOptionUsed = Nothing

        'if argsLength
        if argsLength Then
        

            'for each inx,arg in .args
            Dim inx as Integer =0
            For Each arg in Me.args
            

                'paramPosition = inx
                paramPosition = inx
                'if arg.name //named argument: e.g: `server.listen(port=30371)`
                if arg.name Then
                
                    'namedParamOptionUsed = true
                    namedParamOptionUsed = true
                    'var found
                    Dim found = Nothing
                    'for each paramInx,param in funcDecl.paramsDeclarations.list
                    Dim paramInx as Integer =0
                    For Each param in funcDecl.paramsDeclarations.list
                    
                        'if param.name is arg.name
                        if param.name = arg.name Then
                        
                            'found = true
                            found = true
                            'paramPosition = paramInx
                            paramPosition = paramInx
                            'if param.name in paramNamesSet, .sayErr "duplicated parameter '#{param.name}'"
                            if paramNamesSet.Contains(param.name) Then Me.sayErr("duplicated parameter '" + param.name + "'")
                            'paramNamesSet.push param.name
                            paramNamesSet.push(param.name)
                            'break
                            break
                        
                        End if
                        
                    Next'  each in funcDecl.paramsDeclarations.list
                    'end for
                    'if not found
                    
                    'if not found
                    if Not(found) Then
                    
                        '.sayErr "invalid parameter name: '#{arg.name}'"
                        Me.sayErr("invalid parameter name: '" + arg.name + "'")
                        'funcDecl.sayErr "function declaration is here"
                        funcDecl.sayErr("function declaration is here")
                    
                    End if
                    
                
                'if arg.name //named argument: e.g: `server.listen(port=30371)`
                
                else
                
                    '//positional argument
                    'if namedParamOptionUsed, .sayErr "cannot include positional arguments after named arguments"
                    if namedParamOptionUsed Then Me.sayErr("cannot include positional arguments after named arguments")
                    'if paramPosition < funcParamsLength
                    if paramPosition < funcParamsLength Then
                    
                        'paramNamesSet.push funcDecl.paramsDeclarations.list[paramPosition].name
                        paramNamesSet.push(funcDecl.paramsDeclarations.list(paramPosition).name)
                    
                    End if
                    
                
                End if

                '//try to get param declared type
                'var paramType:Names.Declaration
                Dim paramType = Nothing

                'if paramPosition >= funcParamsLength
                if paramPosition >= funcParamsLength Then
                
                    '// past the declared parameters
                    'if no funcDecl.paramsDeclarations.variadic
                    if NotfuncDecl.paramsDeclarations.variadic Then
                    
                        '.sayErr "function accepts #{funcParamsLength? 'only #{funcParamsLength}':'no'} arguments."
                        Me.sayErr("function accepts " + (funcParamsLength ? "only " + funcParamsLength : "no") + " arguments.")
                        'funcDecl.sayErr "function declaration is here. (add '...' to declare as variadic)"
                        funcDecl.sayErr("function declaration is here. (add '...' to declare as variadic)")
                        'return actualArgs
                        return actualArgs
                    
                    End if

                    'paramType = typeAny
                    paramType = typeAny
                
                'if paramPosition >= funcParamsLength
                
                else
                
                    '//get param declared type
                    'paramType = funcDecl.paramsDeclarations.list[paramPosition].nameDecl.findOwnMember('**proto**')
                    paramType = funcDecl.paramsDeclarations.list(paramPosition).nameDecl.findOwnMember("**proto**")
                    'if paramType
                    if paramType Then
                    
                        'if paramType.name is 'prototype'
                        if paramType.name = "prototype" Then
                        
                            'isClass = true
                            isClass = true
                            'paramType = paramType.parent // class
                            paramType = paramType.parent
                        
                        End if
                        
                    
                    'if paramType
                    
                    else
                    
                        'paramType = typeAny
                        paramType = typeAny
                    
                    End if
                    
                
                End if

                'end if

                '//set argument
                'actualArgs[paramPosition] = arg.calcParam(paramType,inx,funcDecl)
                

                '//set argument
                'actualArgs[paramPosition] = arg.calcParam(paramType,inx,funcDecl)
                actualArgs(paramPosition) = arg.calcParam(paramType, inx, funcDecl)
                'argumentSet[paramPosition] = true
                argumentSet(paramPosition) = true
            Next'  each in Me.args

            'end for each arg

        'end if arguments
            
        
        End if

        'end if arguments

'make sure all the required parameters are set

        'for each inx,param in funcDecl.paramsDeclarations.list
        

'make sure all the required parameters are set

        'for each inx,param in funcDecl.paramsDeclarations.list
        Dim inx as Integer =0
        For Each param in funcDecl.paramsDeclarations.list
        
            'if param.required and param.name not in paramNamesSet
            if param.required AndAlso Not (paramNamesSet.Contains(param.name)) Then
            
                '.sayErr "parameter ##{inx+1},'#{param.name}' is required"
                Me.sayErr("parameter #" + (inx + 1) + ",'" + param.name + "' is required")
                'funcDecl.sayErr "function declaration is here"
                funcDecl.sayErr("function declaration is here")
            
            End if
            
        Next'  each in funcDecl.paramsDeclarations.list
        'end for

'return array with arguements

        'return actualArgs
        

'return array with arguements

        'return actualArgs
        return actualArgs
      end function
      
    
    End Class 'partial


    '    append to class Grammar.FunctionArgument
    Partial Class Grammar.FunctionArgument
    

      '      helper method calcParam(typeNameDecl:Names.Declaration,inx,funcDecl:Grammar.FunctionDeclaration) returns array
      ' ---------------------------
      Public Function calcParam (typeNameDecl, inx, funcDecl)
'inx and funcDecl are included to enhance error reporting

        'var expr = .expression
        Dim expr = Me.expression

'if we're producing C, a instance literal {...} as parameter
'gets converted to a _fastNew() call, initializing the instance with the provided values.

'We're supporting a common practice in JS: pass a LiteralObject in place of a class

        'if project.options.target isnt 'js'
        if project.options.target <> "js" Then
        

            'if expr.operandCount is 1 and expr.root.name instanceof Grammar.ObjectLiteral
            if expr.operandCount = 1 AndAlso TypeOf expr.root.name is Grammar.ObjectLiteral Then
            

                '//Here we have a ObjectLiteral argument
                'var objLit:Grammar.ObjectLiteral = expr.root.name
                Dim objLit = expr.root.name

                'if typeNameDecl.name isnt 'any' and no typeNameDecl.findOwnMember('prototype')
                if typeNameDecl.name <> "any" AndAlso NottypeNameDecl.findOwnMember("prototype") Then
                
                    '.sayErr "Argument ##{inx+1}: passing a instance literal {...}, but the function expects: #{typeNameDecl}"
                    Me.sayErr("Argument #" + (inx + 1) + ": passing a instance literal {...}, but the function expects: " + typeNameDecl)
                    'if funcDecl, funcDecl.sayErr "function declaration is here. To be able to pass a instance literal, define parameter type as a class"
                    if funcDecl Then funcDecl.sayErr("function declaration is here. To be able to pass a instance literal, define parameter type as a class")
                
                'if typeNameDecl.name isnt 'any' and no typeNameDecl.findOwnMember('prototype')
                
                else
                
                    'return objLit.calcFastNew(typeNameDecl.getComposedName())
                    return objLit.calcFastNew(typeNameDecl.getComposedName())
                
                End if
                
            
            End if
            
        
        End if

'else, just return argument expression

        'return [expr]
        return new ArrayList From {expr}
        
      end function
      
    
    End Class 'partial


    '    append to class Grammar.AssignmentStatement ###
    Partial Class Grammar.AssignmentStatement
    

     '     method evaluateAssignments() ## Grammar.AssignmentStatement
     ' ---------------------------
     Public Function evaluateAssignments ()

'check if we've got a a clear reference.

      'var reference = .lvalue.tryGetReference()
      Dim reference = Me.lvalue.tryGetReference()
      'if reference isnt instanceof Names.Declaration, return
      if Not (TypeOf reference is Names.Declaration) Then return

'if it is assigning string or number literal, force type

      'if .rvalue instanceof Grammar.Expression
      if TypeOf Me.rvalue is Grammar.Expression Then
      
          'if .rvalue.root.name.constructor in [Grammar.StringLiteral,Grammar.NumberLiteral]
          if new ArrayList From {Grammar.StringLiteral, Grammar.NumberLiteral}
          .Contains(Me.rvalue.root.name.constructor) Then
          
              'var theLiteral = .rvalue.root.name
              Dim theLiteral = Me.rvalue.root.name
              '// if it is assigning a literal, force type to string|number|array
              'reference.setMember('**proto**', globalPrototype(theLiteral.type))
              reference.setMember("**proto**", globalPrototype(theLiteral.type))
              'return
              return
          
          End if
          
      
      End if

      'if reference.findOwnMember('**proto**'), return #has a type already
      if reference.findOwnMember("**proto**") Then return

'check if we've got a clear rvalue.
'if we do, set type for lvalue (unless is "null" or "undefined", they destroy type info)

      'reference.assignTypeFromValue .rvalue
      reference.assignTypeFromValue(Me.rvalue)
     end function
     
    
    End Class 'partial


'
'#### method declareByAssignment()
'
'Here we check for lvalue VariableRef in the form:
'
'`exports.x = xx`, `module.exports.x = xx` and `xx.prototype.yy =`
'
'We consider this assignments as 'declarations' of members rather than variable references to check.
'
'Start with main variable name
'
'        var varRef = .lvalue
'
'        var keywordFound
'
'        if varRef.name is 'exports' #start with 'exports'
'            keywordFound = varRef.name
'
'        if no varRef.accessors
'
'          if keywordFound # is: `exports = x`, it does not work in node-js
'              .sayErr "'exports = x', does not work. You need to do: 'module.exports = x'"
'
'          return # no accessors to check
'
'        var actualVar = .findInScope(varRef.name)
'        if no actualVar, return
'
'now check each accessor
'
'        var createName
'
'        for each index,ac in varRef.accessors
'            declare valid ac.name
'
'for PropertyAccess
'
'            if ac instanceof Grammar.PropertyAccess
'
'              #if we're after 'exports|prototype' keyword and this is the last accessor,
'              #then this is the name to create
'              if keywordFound and index is varRef.accessors.length-1
'                  createName = ac.name
'                  break
'
'check for 'exports' or 'prototype', after that, last accessor is property declaration
'
'              if ac.name in ['exports','prototype']
'                keywordFound = ac.name
'
'              actualVar =  actualVar.findMember(ac.name)
'              if no actualVar, break
'
'else, if IndexAccess or function access, we exit analysis
'
'            else
'              return #exit
'
'        end for #each accessor in lvalue, look for module.exports=...
'
'if we found 'exports' or 'prototype', and we reach a valid reference
'
'        if keywordFound and actualVar
'
'            if createName # module.exports.x =... create a member
'              actualVar = .addMemberTo(actualVar,createName) # create x on module.exports
'
'            #try to execute assignment, so exported var points to content
'            var content = .rvalue.getResultType()
'            if content instanceof Names.Declaration
'                actualVar.makePointTo content

    '    append to class Grammar.Expression ###
    Partial Class Grammar.Expression
    

     '     helper method getResultType() returns Names.Declaration
     ' ---------------------------
     Public Function getResultType ()
'Try to get return type from a simple Expression

        'declare valid .root.getResultType:function
        
        'return .root.getResultType() # .root is Grammar.Oper or Grammar.Operand
        return Me.root.getResultType()
     end function
     
    
    End Class 'partial


    '    append to class Grammar.Oper ###
    Partial Class Grammar.Oper
    

'for 'into var x' oper, we declare the var, and we deduce type

     '     method declare()
     ' ---------------------------
     Public Function declare ()

        'if .intoVar is '*r' # is a into-assignment operator with 'var' declaration
        if Me.intoVar = "*r" Then
        

            'var varRef = .right.name
            Dim varRef = Me.right.name
            'if varRef isnt instance of Grammar.VariableRef
            if Not (TypeOf varRef is Grammar.VariableRef) Then
            
                '.throwError "Expected 'variable name' after 'into var'"
                Me.throwError("Expected 'variable name' after 'into var'")
            
            End if

            'if varRef.accessors
            if varRef.accessors Then
            
                '.throwError "Expected 'simple variable name' after 'into var'"
                Me.throwError("Expected 'simple variable name' after 'into var'")
            
            End if

            '.addToScope .declareName(varRef.name,{
                                        'type:varRef.type
                                        'nodeClass:Grammar.VariableDecl
                                      '})
            Me.addToScope(Me.declareName(varRef.name, {{type,varRef.type}, {nodeClass,Grammar.VariableDecl}}))
        
        End if
        
     end function

     '     method evaluateAssignments()
     ' ---------------------------
     Public Function evaluateAssignments ()

'for into-assignment operator

      'if .name is 'into' # is a into-assignment operator
      if Me.name = "into" Then
      

'check if we've got a clear reference (into var x)

          'if .right.name instance of Grammar.VariableRef
          if TypeOf Me.right.name is Grammar.VariableRef Then
          

              'declare valid .right.name.tryGetReference:function
              
              'var nameDecl = .right.name.tryGetReference()
              Dim nameDecl = Me.right.name.tryGetReference()

              'if nameDecl isnt instanceof Names.Declaration, return
              if Not (TypeOf nameDecl is Names.Declaration) Then return
              'if nameDecl.findOwnMember('**proto**'), return #has a type already
              if nameDecl.findOwnMember("**proto**") Then return

'check if we've got a clear .left (value to be assigned) type
'if we do, set type for .rigth ('into var x') (unless is "null" or "undefined", they destroy type info)

              'nameDecl.assignTypeFromValue .left
              nameDecl.assignTypeFromValue(Me.left)
          
          End if
          
      
      End if
      
     end function


     '     helper method getResultType() returns Names.Declaration
     ' ---------------------------
     Public Function getResultType ()
'Try to get return type from this Oper (only for 'new' unary oper)

        'declare valid .right.getResultType
        

        'if .name is 'new'
        if Me.name = "new" Then
        
            'return .right.getResultType() #.right is Grammar.Operand
            return Me.right.getResultType()
        
        End if
        
     end function
     
    
    End Class 'partial


    '    append to class Grammar.Operand ###
    Partial Class Grammar.Operand
    

     '     helper method getResultType() returns Names.Declaration
     ' ---------------------------
     Public Function getResultType ()
'Try to get return type from this Operand

        'declare valid .name.type
        
        'declare valid .name.getResultType
        
        'declare valid .name.tryGetReference
        

        'if .name instance of Grammar.ObjectLiteral
        if TypeOf Me.name is Grammar.ObjectLiteral Then
        
            'return .name.getResultType()
            return Me.name.getResultType()
        
        'if .name instance of Grammar.ObjectLiteral
        
        elseif TypeOf Me.name is Grammar.Literal Then
        
            'return globalPrototype(.name.type)
            return globalPrototype(Me.name.type)
        
        'else if .name instance of Grammar.Literal
        
        elseif TypeOf Me.name is Grammar.VariableRef Then
        
            'return .name.tryGetReference()
            return Me.name.tryGetReference()
        
        'else if .name instance of Grammar.VariableRef
        
        elseif TypeOf Me.name is Grammar.FunctionDeclaration Then
        
            'return globalPrototype('Function')
            return globalPrototype("Function")
        
        End if
        End if
        End if
        End if
        
     end function
     
    
    End Class 'partial

    '    append to class Grammar.DeclareStatement
    Partial Class Grammar.DeclareStatement
    
     '     method declare() # pass 1, declare as props
     ' ---------------------------
     Public Function declare ()

'declare [all] x:type
'declare [global] var x
'declare on x
'declare valid x.y.z


      'if .specifier is 'on'
      if Me.specifier = "on" Then
      

          'var reference = .tryGetFromScope(.name,{isForward:true})
          Dim reference = Me.tryGetFromScope(Me.name, {{isForward,true}})

          'if String.isCapitalized(reference.name) //let's assume is a Class
          if String.isCapitalized(reference.name) Then
          
              'if no reference.findOwnMember('prototype'), reference.addMember('prototype')
              if Notreference.findOwnMember("prototype") Then reference.addMember("prototype")
              'reference=reference.findOwnMember('prototype')
              reference = reference.findOwnMember("prototype")
          
          End if

          'for each varDecl in .names
          For Each varDecl in Me.names
          
              '.addMemberTo reference, varDecl.createNameDeclaration()
              Me.addMemberTo(reference, varDecl.createNameDeclaration())
          Next'  each in Me.names
          
      
      'if .specifier is 'on'
      
      elseif new ArrayList From {"affinity", "var"}
      .Contains(Me.specifier) Then
      

          'for each varDecl in .names
          For Each varDecl in Me.names
          

            'varDecl.nameDecl = varDecl.createNameDeclaration()
            varDecl.nameDecl = varDecl.createNameDeclaration()

            'if .specifier is 'var'
            if Me.specifier = "var" Then
            
                'if .globVar
                if Me.globVar Then
                
                    'project.rootModule.addToScope varDecl.nameDecl
                    project.rootModule.addToScope(varDecl.nameDecl)
                
                'if .globVar
                
                else
                
                    '.addToScope varDecl.nameDecl
                    Me.addToScope(varDecl.nameDecl)
                
                End if
                
            
            'if .specifier is 'var'
            
            elseif Me.specifier = "affinity" Then
            
                'var classDecl = .getParent(Grammar.ClassDeclaration)
                Dim classDecl = Me.getParent(Grammar.ClassDeclaration)
                'if no classDecl
                if NotclassDecl Then
                
                    '.sayErr "'declare name affinity' must be included in a class declaration"
                    Me.sayErr("'declare name affinity' must be included in a class declaration")
                    'return
                    return
                
                End if
                '#add as member to nameAffinity, referencing class decl (.nodeDeclared)
                'varDecl.nameDecl.nodeDeclared = classDecl
                varDecl.nameDecl.nodeDeclared = classDecl
                'declare varDecl.name:string
                
                'nameAffinity.members.set varDecl.name.capitalized(), classDecl.nameDecl
                nameAffinity.members.set(varDecl.name.capitalized(), classDecl.nameDecl)
            
            End if
            End if
            
          Next'  each in Me.names
          
      
      End if
      End if
      
     end function

'if .specifier is 'on-the-fly', the type will be converted on next passes over the created Names.Declaration.
'On the method validatePropertyAccess(), types will be switched "on the fly"
'while checking property access.

     '     method evaluateAssignments() # Grammar.DeclareStatement ###
     ' ---------------------------
     Public Function evaluateAssignments ()
'Assign specific type to varRef - for the entire compilation

      'if .specifier is 'type'
      if Me.specifier = "type" Then
      
          'if .varRef.tryGetReference({informError:true}) into var actualVar
          Dim actualVar as Object
          if Assign(actualVar,Me.varRef.tryGetReference({{informError,true}})) Then
          
              '.setTypes actualVar
              Me.setTypes(actualVar)
          
          End if
          
      
      End if
      
     end function

     '     helper method setTypes(actualVar:Names.Declaration) # Grammar.DeclareStatement ###
     ' ---------------------------
     Public Function setTypes (actualVar)
'Assign types if it was declared

      '#create type on the fly, overwrite existing type

      'if .type
      if Me.type Then
      
        '.setSubType actualVar,.type.mainType,'**proto**'
        Me.setSubType(actualVar, Me.type.mainType, "**proto**")
        '.setSubType actualVar,.type.itemType,'**item type**'
        Me.setSubType(actualVar, Me.type.itemType, "**item type**")
      
      End if
      
     end function

     '     helper method setSubType(actualVar:Names.Declaration, toSet, propName )
     ' ---------------------------
     Public Function setSubType (actualVar, toSet, propName)
'Assign type if it was declared

      'if toSet #create type on the fly
      if toSet Then
      
          '//var act=actualVar.findMember(propName)
          '//print "set *type* was #{act} set to #{toSet}"
          'actualVar.setMember propName, toSet
          actualVar.setMember(propName, toSet)
          'var result = actualVar.processConvertTypes()
          Dim result = actualVar.processConvertTypes()
          'if result.failures, .sayErr "can't find type '#{toSet}' in scope"
          if result.failures Then Me.sayErr("can't find type '" + toSet + "' in scope")
      
      End if
      
     end function

     '     method validatePropertyAccess() # Grammar.DeclareStatement ###
     ' ---------------------------
     Public Function validatePropertyAccess ()

'declare members on the fly, with optional type

      'var actualVar:Names.Declaration
      Dim actualVar = Nothing

      'case .specifier
      select Me.specifier
      case "valid"
      

            'actualVar = .tryGetFromScope(.varRef.name,{informError:true})
            actualVar = Me.tryGetFromScope(Me.varRef.name, {{informError,true}})
            'if no actualVar, return
            if NotactualVar Then return

            'for each ac in .varRef.accessors
            For Each ac in Me.varRef.accessors
            
                'declare valid ac.name
                

                'if ac isnt instance of Grammar.PropertyAccess
                if Not (TypeOf ac is Grammar.PropertyAccess) Then
                
                    'actualVar = undefined
                    actualVar = undefined
                    'break
                    break
                
                End if

                'if ac.name is 'prototype'
                if ac.name = "prototype" Then
                
                    'actualVar = actualVar.findOwnMember(ac.name) or .addMemberTo(actualVar, ac.name)
                    actualVar = actualVar.findOwnMember(ac.name) OrElse Me.addMemberTo(actualVar, ac.name)
                
                'if ac.name is 'prototype'
                
                else
                
                    'actualVar = actualVar.findMember(ac.name) or .addMemberTo(actualVar, ac.name)
                    actualVar = actualVar.findMember(ac.name) OrElse Me.addMemberTo(actualVar, ac.name)
                
                End if
                
            Next'  each in Me.varRef.accessors

            'end for

            'if actualVar, .setTypes actualVar
            

            'if actualVar, .setTypes actualVar
            if actualVar Then Me.setTypes(actualVar)
      
      
      case "on-the-fly"
      
            '#set type on-the-fly, from here until next type-assignment
            '#we allow more than one "declare x:type" on the same block
            'if .varRef.tryGetReference({informError:true}) into actualVar
            if Assign(actualVar,Me.varRef.tryGetReference({{informError,true}})) Then
            
                '.setTypes actualVar
                Me.setTypes(actualVar)
            
            End if
            
      
      
      
     end function
     
    
    End Class 'partial


    '    helper function AddGlobalClasses(...)
    ' ---------------------------
    function AddGlobalClasses()

        'var nameDecl
        Dim nameDecl = Nothing

        'for each name in arguments.toArray()
        var _list4=arguments.toArray()
        For Each name in _list4
        

            'nameDecl = globalScope.addMember(name,{nodeClass:Grammar.ClassDeclaration})
            nameDecl = globalScope.addMember(name, {{nodeClass,Grammar.ClassDeclaration}})

            'var prtypeNameDecl = nameDecl.addMember('prototype',{nodeClass:Grammar.VariableDecl})
            Dim prtypeNameDecl = nameDecl.addMember("prototype", {{nodeClass,Grammar.VariableDecl}})

            'nameDecl.setMember '**return type**',prtypeNameDecl
            nameDecl.setMember("**return type**", prtypeNameDecl)

            '// add to name affinity
            'if not nameAffinity.members.has(name)
            if Not(nameAffinity.members.has(name)) Then
            
                'nameAffinity.members.set name, nameDecl
                nameAffinity.members.set(name, nameDecl)
            
            End if
            
        Next'  each in arguments.toArray()
        
    end function

'----------------------------
    '    append to class Names.Declaration ###
    Partial Class Names.Declaration
    

     '     helper method calcComposedPrefix returns Array
     ' ---------------------------
     Public Function calcComposedPrefix ()

'if this node is member of a namespace, goes up the parent chain
'composing the prefix. e.g. a property x in module Foo, namespace Bar => `Foo_Bar_`

        'var result = []
        Dim result = new ArrayList

        'if .nodeDeclared instanceof Grammar.ImportStatementItem
        if TypeOf Me.nodeDeclared is Grammar.ImportStatementItem Then
        
            '// imported modules create a local var, but act as global var
            '//since all others import of the same name, return the same content
            '// no prefix for "import" module declared vars
            'return result
            return result
        
        End if

        'var lastWasExported = .isExported
        Dim lastWasExported = Me.isExported

        'var node = this.parent
        Dim node = Me.parent

        'while node
        Do whilenode
        

            'if node.isScope and node.nodeDeclared isnt instance of Grammar.NamespaceDeclaration
            if node.isScope AndAlso Not (TypeOf node.nodeDeclared is Grammar.NamespaceDeclaration) Then
            
                'break // end composing when a scope is reached. Except for NamespaceDeclaration
                break
            
            End if
                '// NamespaceDeclaration scope exists only to be able to use namespace items
                '// without namespace prefix inside the namespace declaration,
                '// but it is not a real scope at execution time

            'if node.name isnt 'prototype' //skip .prototype. in C
            if node.name <> "prototype" Then
            
                'result.unshift node.name
                result.unshift(node.name)
                'lastWasExported = node.isExported
                lastWasExported = node.isExported
            
            End if

            'node = node.parent
            node = node.parent
        
        Loop

        'end while loop

'if we reached module scope, (and not Global Scope)
'then it's a var|fn|class declared at module scope.
'If the object is 'public|exported' we add module.fileinfo.base to the name
'(to use always it's "global" name)

        'if lastWasExported and node and node.isScope and node.nodeDeclared.constructor is Grammar.Module
        

'if we reached module scope, (and not Global Scope)
'then it's a var|fn|class declared at module scope.
'If the object is 'public|exported' we add module.fileinfo.base to the name
'(to use always it's "global" name)

        'if lastWasExported and node and node.isScope and node.nodeDeclared.constructor is Grammar.Module
        if lastWasExported AndAlso node AndAlso node.isScope AndAlso node.nodeDeclared.constructor = Grammar.Module Then
        
            'var scopeModule = node.nodeDeclared
            Dim scopeModule = node.nodeDeclared
            'if scopeModule.name isnt '*Global Scope*' //except for global scope
            if scopeModule.name <> "*Global Scope*" Then
            
                  'result.unshift scopeModule.fileInfo.base
                  result.unshift(scopeModule.fileInfo.base)
            
            End if
            
        
        End if


        'return result
        return result
     end function


     '     helper method getComposedPrefix() returns string
     ' ---------------------------
     Public Function getComposedPrefix ()

        'return .calcComposedPrefix().join("_")
        return Me.calcComposedPrefix().join("_")
     end function

     '     helper method getComposedName() returns string
     ' ---------------------------
     Public Function getComposedName ()

        'var result = .calcComposedPrefix()
        Dim result = Me.calcComposedPrefix()

        'if .name isnt 'prototype' //skip .prototype. in C
        if Me.name <> "prototype" Then
        
            'result.push .name
            result.push(Me.name)
        
        End if

        'return result.join("_")
        return result.join("_")
     end function
     
    
    End Class 'partial' -----------
' Module code
' -----------

    'end function validate

    '    export function walkAllNodesCalling(methodName:string)
    
end module
