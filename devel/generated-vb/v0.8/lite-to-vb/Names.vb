'Generated by LiteScript compiler v0.8.9, source: Names.lite.md
' -----------
Module Names
' -----------
'Dependencies
'------------

    'import ASTBase,Grammar,logger
    'var ASTBase = require('./ASTBase.vb');
    'var Grammar = require('./Grammar.vb');
    'var logger = require('./lib/logger.vb');

    'shim import LiteCore,Map
    'var LiteCore = require('./interfaces/LiteCore.vb');
    'var Map = require('./interfaces/Map.vb');

'Module vars

    'public var allNameDeclarations: Declaration array = [] #array with all NameDeclarations created
    Dim allNameDeclarations = new ArrayList


    '    public class Declaration
    ' constructor
    Class Declaration
        Public Property name as String' mainType: String  
     
         Public Property members as new Dictionary(Of String, Declaration)
     
         Public Property parent as Declaration' mainType: Declaration  
     
         Public Property nodeDeclared as ASTBase' mainType: ASTBase  
     
         Public Property nodeClass as Object
         Public Property normalizeModeKeepFirstCase as Boolean' mainType: Boolean  
     
         Public Property isScope as Boolean' mainType: Boolean  
     
         Public Property isExported as Boolean' mainType: Boolean  
     
         Public Property type as Object
         Public Property itemType as Object
         Public Property value as Object
         Public Property isForward as Object
         Public Property isDummy as Object
    
    Sub New(name, options, node)

      '.name = name.toString()
      Me.name = name.toString()
      '.members = new Map //string to Declaration //contained Declarations
      Me.members = new Map()

'try to determine nodeClass from node.nodeDeclared

      '.nodeDeclared = node
      Me.nodeDeclared = node
      'if node
      if node Then
      
          '.nodeClass = node.constructor
          Me.nodeClass = node.constructor
          'case .nodeClass
          select Me.nodeClass
          case Grammar.ImportStatementItem,Grammar.DeclareStatement,Grammar.WithStatement,Grammar.ArrayLiteral,Grammar.ExceptionBlock
          
                    '.nodeClass = Grammar.VariableDecl
                    Me.nodeClass = Grammar.VariableDecl
          
          
          case Grammar.ObjectLiteral,Grammar.FreeObjectLiteral
          
                    '.nodeClass = Grammar.NameValuePair
                    Me.nodeClass = Grammar.NameValuePair
          
          
          case Grammar.FunctionDeclaration,Grammar.ClassDeclaration,Grammar.NamespaceDeclaration,Grammar.VarStatement
          
                    '.isExported = node.hasAdjective('export') and not node.hasAdjective('only')
                    Me.isExported = node.hasAdjective("export") AndAlso Not(node.hasAdjective("only"))
          
          
          
      
      End if


      'end if


      'if options
      


      'if options
      if options Then
      

          'if options.nodeClass, .nodeClass = options.nodeClass
          if options.nodeClass Then Me.nodeClass = options.nodeClass

          'if options.normalizeModeKeepFirstCase, .normalizeModeKeepFirstCase=true
          if options.normalizeModeKeepFirstCase Then Me.normalizeModeKeepFirstCase = true

'if it 'points' to another namedecl, it uses other nameDecl's '.members={}'
'effectively working as a pointer

          'if options.pointsTo
          if options.pointsTo Then
          
              '.members = options.pointsTo.members
              Me.members = options.pointsTo.members
          
          'if options.pointsTo
          
          else
          

              'if options.type instanceof Grammar.TypeDeclaration
              if TypeOf options.type is Grammar.TypeDeclaration Then
              
                  '.setMember('**proto**',options.type.mainType)
                  Me.setMember("**proto**", options.type.mainType)
                  'if options.type.itemType, .setMember('**item type**',options.type.itemType)
                  if options.type.itemType Then Me.setMember("**item type**", options.type.itemType)
              
              'if options.type instanceof Grammar.TypeDeclaration
              
              elseif options.type Then
              
                  '.setMember('**proto**',options.type)
                  Me.setMember("**proto**", options.type)
              
              End if
              End if

              'if options.returnType
              if options.returnType Then
              
                  '.setMember('**return type**',options.returnType)
                  Me.setMember("**return type**", options.returnType)
              
              End if

              'if options.value, .setMember('**value**',options.value)
              if options.value Then Me.setMember("**value**", options.value)
          
          End if

          'if options.isForward, .isForward = true
          if options.isForward Then Me.isForward = true
          'if options.isDummy, .isDummy = true
          if options.isDummy Then Me.isDummy = true

          'if options.isForward or options.isDummy and no .nodeClass, .nodeClass = Grammar.VariableDecl
          if options.isForward OrElse options.isDummy AndAlso NotMe.nodeClass Then Me.nodeClass = Grammar.VariableDecl
      
      End if


'Check for a valid nodeclass

      'if no .nodeClass
      if NotMe.nodeClass OrElse Not (new ArrayList From {Grammar.NamespaceDeclaration, Grammar.ClassDeclaration, Grammar.PropertiesDeclaration, Grammar.NameValuePair, Grammar.FunctionDeclaration, Grammar.MethodDeclaration, Grammar.VariableDecl}
          .Contains(Me.nodeClass)) Then
      

            'fail with "new Declaration, nodeClass is undefined or invalid: #{.nodeClass? .nodeClass.name:.nodeClass}"
            Throw New System.Exception("new Declaration, nodeClass is undefined or invalid: " + (Me.nodeClass ? Me.nodeClass.name : Me.nodeClass))
      
      End if

'set .isFunction flag

'if .nodeClass instanceof Grammar.FunctionDeclaration, .isFunction = true //fn, method & constructors
'
'      if .nodeClass instanceof Grammar.FunctionDeclaration, .isFunction = true //fn, method & constructors
'
'      case .nodeClass
'          when Grammar.NamespaceDeclaration: .isNamespace = true
'          when Grammar.ClassDeclaration: .isClass = true
'    

'keep a list of all NameDeclarations

      'allNameDeclarations.push this
      allNameDeclarations.push(Me)
     end function
    
     ' ---------------------------
     Public Function normalize (name)
        'if .normalizeModeKeepFirstCase
        if Me.normalizeModeKeepFirstCase Then
        
            'return normalizeKeepFirst(name) //first letter keeps its case
            return normalizeKeepFirst(name)
        
        'if .normalizeModeKeepFirstCase
        
        else
        
            'return normalizeToLower(name) //all lowercase
            return normalizeToLower(name)
        
        End if
        
     end function
     ' ---------------------------
     Public Function setMember (name, value)
'force set a member

        'if name is '**proto**'
        if name = "**proto**" Then
        
            '# walk all the **proto** chain to avoid circular references
            'var nameDecl = value
            Dim nameDecl = value
            'do
            do 
            
                'if nameDecl isnt instance of Declaration, break #a nameDecl with a string yet to be de-reference
                if Not (TypeOf nameDecl is Declaration) Then break
                'if nameDecl is this, return #circular ref, abort setting
                if nameDecl = Me Then return
            Loop while Assign(nameDecl,nameDecl.members.get(name))
            
        
        End if

        'end if #avoid circular references

        '#set member
        '.members.set .normalize(name), value
        

        '#set member
        '.members.set .normalize(name), value
        Me.members.set(Me.normalize(name), value)
     end function
     ' ---------------------------
     Public Function findOwnMember (name)
'this method looks for 'name' in Declaration members

        'return .members.get(.normalize(name))
        return Me.members.get(Me.normalize(name))
     end function
     ' ---------------------------
     Public Function ownMember (name)
'this method looks for a specific member, throws if not found

        'if no .findOwnMember(name) into var result
        Dim result as Object
        if Not(Assign(result,Me.findOwnMember(name))) Then
        
          '.sayErr "No member named '#{name}' on #{.info()}"
          Me.sayErr("No member named '" + name + "' on " + (Me.info()))
        
        End if

        'return result
        return result
     end function
     ' ---------------------------
     Public Function getMemberCount ()
        'return .members.size
        return Me.members.size
     end function
     ' ---------------------------
     Public Function replaceForward (realNameDecl)
'This method is called on a 'forward' Declaration
'when the real declaration is found.
'We mix in all members from realNameDecl to this declaration
'and maybe remove the forward flag.

        'declare on realNameDecl
          'members

'mix in found namedecl here

        'for each key,member in map realNameDecl.members
        

'mix in found namedecl here

        'for each key,member in map realNameDecl.members
        for Each item in realNameDecl.members
          Dim key as string = item.key
          Dim member=item.value
        
          'declare member:Declaration
          
          'member.parent = this
          member.parent = Me
          '.members.set key,member
          Me.members.set(key, member)
        Next'  for each item in map

        '.isForward = realNameDecl.isForward
        Me.isForward = realNameDecl.isForward

        'if realNameDecl.nodeDeclared
        if realNameDecl.nodeDeclared Then
        
          '.nodeDeclared = realNameDecl.nodeDeclared
          Me.nodeDeclared = realNameDecl.nodeDeclared
        
        End if

        'return true
        return true
     end function
     ' ---------------------------
     Public Function makePointTo (nameDecl)

        'if nameDecl isnt instance of Declaration, fail with "makePointTo: not a Declaration"
        if Not (TypeOf nameDecl is Declaration) Then Throw New System.Exception("makePointTo: not a Declaration")

        '# remove existing members from nameDeclarations[]
        '.isForward = false
        Me.isForward = false
        'for each memberDecl in map .members
        for Each item in Me.members
          Dim memberDecl__propName as string = item.key
          Dim memberDecl=item.value
        
          'allNameDeclarations.remove memberDecl
          allNameDeclarations.remove(memberDecl)
        Next'  for each item in map

        '#save a copy of this.members pointer
        'var thisMembers = this.members
        Dim thisMembers = Me.members

        '#"point to" means share "members" object
        'this.members = nameDecl.members
        Me.members = nameDecl.members
        '//since we get the members, we must also respect the same normalization mode
        'this.normalizeModeKeepFirstCase = nameDecl.normalizeModeKeepFirstCase
        Me.normalizeModeKeepFirstCase = nameDecl.normalizeModeKeepFirstCase
        '//and other data
        'this.nodeClass = nameDecl.nodeClass
        Me.nodeClass = nameDecl.nodeClass
        '//this.isExported = nameDecl.isExported
        'this.nodeDeclared = nameDecl.nodeDeclared
        Me.nodeDeclared = nameDecl.nodeDeclared

        '#other nameDecl pointing here are redirected
        'for each other in allNameDeclarations
        For Each other in allNameDeclarations
        
            'if other.members is thisMembers
            if other.members = thisMembers Then
            
                'other.members = nameDecl.members
                other.members = nameDecl.members
            
            End if
            
        Next'  each in allNameDeclarations
        
     end function
     ' ---------------------------
     Public Function positionText ()

        'if .nodeDeclared
        if Me.nodeDeclared Then
        
            'return .nodeDeclared.positionText()
            return Me.nodeDeclared.positionText()
        
        'if .nodeDeclared
        
        else
        
          'return "(compiler-defined)"
          return "(compiler-defined)"
        
        End if
        
     end function
     ' ---------------------------
     Public Function originalDeclarationPosition ()
        'return "#{.positionText()} for reference: original declaration of '#{.name}'"
        return "" + (Me.positionText()) + " for reference: original declaration of '" + Me.name + "'"
     end function
     ' ---------------------------
     Public Function sayErr (msg)
        'logger.error "#{.positionText()} #{.info()} #{msg}"
        logger.error("" + (Me.positionText()) + " " + (Me.info()) + " " + msg)
     end function
     ' ---------------------------
     Public Function warn (msg)
        'logger.warning "#{.positionText()} #{.info()} #{msg}"
        logger.warning("" + (Me.positionText()) + " " + (Me.info()) + " " + msg)
     end function
     ' ---------------------------
     Public Function caseMismatch (text, actualNode)
'If this item has a different case than the name we're adding, emit error

        'if .name isnt text # if there is a case mismatch
        if Me.name <> text Then
        

            'logger.error "#{actualNode? actualNode.positionText():.positionText()} CASE MISMATCH: '#{text}'/'#{.name}'"
            logger.error("" + (actualNode ? actualNode.positionText() : Me.positionText()) + " CASE MISMATCH: '" + text + "'/'" + Me.name + "'")
            'logger.error .originalDeclarationPosition() #add original declaration line info
            logger.error(Me.originalDeclarationPosition())
            'return true
            return true
        
        End if
        
     end function
     ' ---------------------------
     Public Function addMember (nameDecl, options, nodeDeclared)
'Adds passed Declaration to .members
'Reports duplicated.
'returns: Identifier

'convert to Declaration

        'if nameDecl isnt instance of Declaration
        if Not (TypeOf nameDecl is Declaration) Then
        
            'nameDecl = new Declaration(nameDecl, options, nodeDeclared or .nodeDeclared)
            nameDecl = new Declaration(nameDecl, options, nodeDeclared OrElse Me.nodeDeclared)
        
        End if

        'logger.debug "addMember: '#{nameDecl.name}' to '#{.name}'" #[#{.constructor.name}] name:
        logger.debug("addMember: '" + nameDecl.name + "' to '" + Me.name + "'")

        'if no .members
        if NotMe.members Then
        
          'fail with "no .members in [#{.constructor.name}]"
          Throw New System.Exception("no .members in [" + Me.constructor.name + "]")
        
        End if

        'var normalized = .normalize(nameDecl.name)
        Dim normalized = Me.normalize(nameDecl.name)

        'if not .members.get(normalized) into var found:Declaration
        Dim found as Object
        if Not(Assign(found,Me.members.get(normalized))) Then
        
            '.members.set normalized, nameDecl
            Me.members.set(normalized, nameDecl)
            'nameDecl.parent = this
            nameDecl.parent = Me
            'return nameDecl
            return nameDecl
        
        End if

'else, found.

'If the found item has a different case than the name we're adding, emit error & return

        'if found.caseMismatch(nameDecl.name, nodeDeclared or nameDecl.nodeDeclared)
        if found.caseMismatch(nameDecl.name, nodeDeclared OrElse nameDecl.nodeDeclared) Then
        
            'return nameDecl
            return nameDecl

'if replaceSameName option set, replace found item with new item

            '.members.set normalized, nameDecl
            Me.members.set(normalized, nameDecl)
        
        'if found.caseMismatch(nameDecl.name, nodeDeclared or nameDecl.nodeDeclared)
        
        elseif found.isForward Then
        
            'found.replaceForward nameDecl
            found.replaceForward(nameDecl)
            'return found
            return found
        
        'else if found.isForward
        
        else
        
            'logger.error "#{nameDecl.positionText()}. DUPLICATED name: '#{nameDecl.name}'"
            logger.error("" + (nameDecl.positionText()) + ". DUPLICATED name: '" + nameDecl.name + "'")
            'logger.error "adding member '#{nameDecl.name}' to '#{.name}'"
            logger.error("adding member '" + nameDecl.name + "' to '" + Me.name + "'")
            'logger.error found.originalDeclarationPosition() #add extra information line
            logger.error(found.originalDeclarationPosition())
        
        End if
        End if

        'return nameDecl
        return nameDecl
     end function
     ' ---------------------------
     Public Function toString ()
        '#note: parent may point to a different node than the original declaration, if makePointTo() was used
        'return .name
        return Me.name
     end function
     ' ---------------------------
     Public Function composedName ()
        'var name = .name
        Dim name = Me.name
        'if .parent and .parent.name isnt 'prototype' and not .parent.name.endsWith('Scope]')
        if Me.parent AndAlso Me.parent.name <> "prototype" AndAlso Not(Me.parent.name.endsWith("Scope]")) Then
        
          'name = "#{.parent.name}.#{name}"
          name = "" + Me.parent.name + "." + name
        
        End if
        'return name
        return name
     end function
     ' ---------------------------
     Public Function info ()

        'var type = "any"
        Dim type = "any"

        'if .nodeClass is Grammar.ClassDeclaration
        if Me.nodeClass = Grammar.ClassDeclaration Then
        
            'type = 'Class'
            type = "Class"
        
        'if .nodeClass is Grammar.ClassDeclaration
        
        else
        
            'var nameDecltype = .findOwnMember('**proto**')
            Dim nameDecltype = Me.findOwnMember("**proto**")
            'if nameDecltype instanceof Declaration
            if TypeOf nameDecltype is Declaration Then
            
                'type = nameDecltype.name
                type = nameDecltype.name
                'if nameDecltype.parent and nameDecltype.parent.name isnt "Project Root Scope"
                if nameDecltype.parent AndAlso nameDecltype.parent.name <> "Project Root Scope" Then
                
                    'if type is 'prototype'
                    if type = "prototype" Then
                    
                        'type = nameDecltype.parent.name
                        type = nameDecltype.parent.name
                    
                    'if type is 'prototype'
                    
                    else
                    
                        'type = "#{nameDecltype.parent.name}.#{type}"
                        type = "" + nameDecltype.parent.name + "." + type
                    
                    End if
                    'end if

                'if no type and .nodeClass is Grammar.ImportStatement, type="import"
                    
                
                End if

                'if no type and .nodeClass is Grammar.ImportStatement, type="import"
                if Nottype AndAlso Me.nodeClass = Grammar.ImportStatement Then type = "import"
            
            'if nameDecltype instanceof Declaration
            
            else
            
                'do nothing
                Do Nothing
            
            End if
            
        
        End if
                '//commented: sometimes is confusing. If it not in **proto** it is not the type
                '//if .nodeDeclared and .nodeDeclared.type, type=.nodeDeclared.type.toString()
        'end if

        'if type, type=":#{type}" //prepend :
        

        'if type, type=":#{type}" //prepend :
        if type Then type = ":" + type

        'return "'#{.composedName()}#{type}'"
        return "'" + (Me.composedName()) + type + "'"
     end function
    
    end class 'Declaration


'#Module helper functions
'exported as members of export default class Declaration

    '    helper function fixSpecialNames(text:string)
    ' ---------------------------
    function fixSpecialNames(text)

      'if text in ['__proto__','NaN','Infinity','undefined','null','false','true','constructor'] # not good names
      if new ArrayList From {"__proto__", "NaN", "Infinity", "undefined", "null", "false", "true", "constructor"}
      .Contains(text) Then
      
        'return '|#{text}|'
        return "|" + text + "|"
      
      'if text in ['__proto__','NaN','Infinity','undefined','null','false','true','constructor'] # not good names
      
      else
      
        'return text
        return text
      
      End if
      
    end function

    '    helper function normalizeToLower(text:string) returns string
    ' ---------------------------
    function normalizeToLower(text)
'we do not allow two names differing only in upper/lower case letters

      'if text.charAt(0) is "'" or text.charAt(0) is '"' #Except for quoted names
      if text.charAt(0) = "'" OrElse text.charAt(0) = """ Then
      
          'return text
          return text
      
      End if

      'return fixSpecialNames(text.toLowerCase())
      return fixSpecialNames(text.toLowerCase())
    end function

    '    helper function normalizeKeepFirst(text:string) returns String
    ' ---------------------------
    function normalizeKeepFirst(text)
'Normalization for vars means: 1st char untouched, rest to to lower case.

'By keeping 1st char untouched, we allow "token" and "Token" to co-exists in the same scope.
''token', by name affinity, will default to type:'Token'

      'return fixSpecialNames( "#{text.slice(0,1)}#{text.slice(1).toLowerCase()}" )
      return fixSpecialNames("" + (text.slice(0, 1)) + (text.slice(1).toLowerCase()))
    end function

    '    helper function isCapitalized(text:string) returns boolean
    ' ---------------------------
    function isCapitalized(text)

      'if text and text.charAt(0) is text.charAt(0).toUpperCase()  and
      if text AndAlso text.charAt(0) = text.charAt(0).toUpperCase() AndAlso (text.length = 1 OrElse text.charAt(1) = text.charAt(1).toLowerCase()) Then
      
              'return true
              return true
      
      End if

      'return false
      return false
    end function


    '    export class DeclarationOptions
    ' constructor
    Class DeclarationOptions
        Public Property normalizeModeKeepFirstCase as Boolean' mainType: Boolean  
        
            Public Property pointsTo as Declaration' mainType: Declaration  
        
            Public Property type as Grammar.TypeDeclaration' mainType: Grammar.TypeDeclaration  
        
            Public Property returnType as Object
            Public Property nodeClass as ASTBase' mainType: ASTBase  
        
            Public Property isForward as Object
            Public Property isDummy as Object
            Public Property informError as Boolean' mainType: Boolean  
        
            Public Property value as Object
    
    Sub New() 'default constructor
    
    
    end class 'DeclarationOptions
' -----------
' Module code
' -----------
end module
