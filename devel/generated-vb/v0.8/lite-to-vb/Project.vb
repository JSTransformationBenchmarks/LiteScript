'Generated by LiteScript compiler v0.8.9, source: Project.lite.md
' -----------
Module Project
' -----------
'==============================
'LiteScript is a highly readable language that compiles to JavaScript.

'###Module Dependencies

    'shim import Map
    'var Map = require('./interfaces/Map.vb');

'The Project Class require all other modules to
'compile LiteScript code.

    'import
        'ASTBase, Grammar, Parser
        'Names, Validate
        'ControlledError, GeneralOptions
        'logger, color, shims, mkPath

'Get the 'Environment' object for the compiler to use.
'The 'Environment' object, must provide functions to load files, search modules,
'and a optional external cache (disk).
'The `Environment` abstraction allows us to support compile on server(node) or the browser.

    'import Environment
    'var ASTBase = require('./ASTBase.vb');
    'var Grammar = require('./Grammar.vb');
    'var Parser = require('./Parser.vb');
    'var Names = require('./Names.vb');
    'var Validate = require('./Validate.vb');
    'var ControlledError = require('./lib/ControlledError.vb');
    'var GeneralOptions = require('./lib/GeneralOptions.vb');
    'var logger = require('./lib/logger.vb');
    'var color = require('./lib/color.vb');
    'var shims = require('./interfaces/shims.vb');
    'var mkPath = require('./lib/mkPath.vb');

'Get the 'Environment' object for the compiler to use.
'The 'Environment' object, must provide functions to load files, search modules,
'and a optional external cache (disk).
'The `Environment` abstraction allows us to support compile on server(node) or the browser.

    'import Environment
    'var Environment = require('./lib/Environment.vb');

'Require the Producer (to include it in the dependency tree)

    '//ifdef PROD_JS
    '//import Producer_js
    '//var COMMENT_START="//"
    '//endif
    '//ifdef PROD_C
    '//import Producer_c
    '//var COMMENT_START="//"
    '//endif
    '//ifdef PROD_VB
    'import Producer_vb
    'var Producer_vb = require('./Producer_vb.vb');
    'var COMMENT_START="'"
    Dim COMMENT_START = "'"
    '//endif

'----------------
    '    export only class Project
    ' constructor
    Class Project
        Public Property options as GeneralOptions' mainType: GeneralOptions  
     
         Public Property name as Object
         Public Property moduleCache as new Dictionary(Of String, Grammar.Module)
     
         Public Property rootModule as Grammar.Module' mainType: Grammar.Module  
     
         Public Property compilerVars as new Dictionary(Of String, Names.Declaration)
     
         Public Property main as Grammar.Module' mainType: Grammar.Module  
     
         Public Property Producer as Object
         Public Property recurseLevel as Object=0
         Public Property filesProducedCount as Object
    
    Sub New(options)

'Initialize this project. Project has a cache for required modules.
'As with node's `require` mechanism, a module,
'when imported|required is only compiled once and then cached.

        'console.time 'Init Project'
        console.time("Init Project")

        '.name = 'Project'
        Me.name = "Project"

        'options.now = new Date()
        options.now = new Date()
        '.options = options
        Me.options = options

        '.moduleCache = new Map
        Me.moduleCache = new Map()

        'logger.init options
        logger.init(options)

'calculate project dir from main module

        'var tempFileInfo = new Environment.FileInfo(options.mainModuleName)
        Dim tempFileInfo = new Environment.FileInfo(options.mainModuleName)
        'options.projectDir = tempFileInfo.dir
        options.projectDir = tempFileInfo.dir
        'options.mainModuleName = '#{tempFileInfo.base}'
        options.mainModuleName = "" + tempFileInfo.base

        'options.outDir = Environment.resolvePath(options.outDir or '.')
        options.outDir = Environment.resolvePath(options.outDir OrElse ".")

        'Environment.setBaseInfo options
        Environment.setBaseInfo(options)

        'logger.msg 'Project Dir:',.options.projectDir
        logger.msg("Project Dir:", Me.options.projectDir)
        'logger.msg 'Main Module:',.options.mainModuleName
        logger.msg("Main Module:", Me.options.mainModuleName)
        'logger.msg 'Out Dir:',.options.outDir
        logger.msg("Out Dir:", Me.options.outDir)

'compiler vars, #defines, to use at conditional compilation

        '.compilerVars = new Map
        Me.compilerVars = new Map()

        'for each def in options.defines
        For Each def in options.defines
        
            '.setCompilerVar def
            Me.setCompilerVar(def)
        Next'  each in options.defines

'add 'ENV_JS' => this compiler is JS code

        '//ifdef TARGET_JS
        '//.setCompilerVar 'ENV_JS'
        '//.setCompilerVar options.browser? 'ENV_BROWSER' else 'ENV_NODE'
        '//endif

'add 'ENV_C' => this compiler is C-code (*native exe*)

        '//ifdef TARGET_C
        '//.setCompilerVar 'ENV_C'
        '//endif

'add 'TARGET_x'

'TARGET_JS: this is the compile-to-js version of LiteScript compiler

'TARGET_C: this is the compile-to-c version of LiteScript compiler

        '.setCompilerVar 'TARGET_#{options.target.toUpperCase()}'
        Me.setCompilerVar("TARGET_" + (options.target.toUpperCase()))

        'logger.msg 'preprocessor #defined', .compilerVars.keys()
        logger.msg("preprocessor #defined", Me.compilerVars.keys())
        'logger.info "" //blank line
        logger.info("")

'create a 'rootModule' module to hold global scope

        '.rootModule = new Grammar.Module() //parent is Project
        Me.rootModule = new Grammar.Module()
        '.rootModule.name = '*Global Scope*'
        Me.rootModule.name = "*Global Scope*"

        '.rootModule.fileInfo = new Environment.FileInfo('Project')
        Me.rootModule.fileInfo = new Environment.FileInfo("Project")
        '.rootModule.fileInfo.relFilename='Project'
        Me.rootModule.fileInfo.relFilename = "Project"
        '.rootModule.fileInfo.dir = options.projectDir
        Me.rootModule.fileInfo.dir = options.projectDir
        '.rootModule.fileInfo.outFilename = "#{options.outDir}/_project_"
        Me.rootModule.fileInfo.outFilename = "" + options.outDir + "/_project_"

'Validate.initialize will prepare the global scope
'by parsing the file: "interfaces/GlobalScope(JS|C|NODE|BROWSER).interface.md"

        'Validate.initialize this
        Validate.initialize(Me)

        'if options.perf>1, console.timeEnd 'Init Project'
        if options.perf > 1 Then console.timeEnd("Init Project")
     end function
    
     ' ---------------------------
     Public Function compile ()

'Import & compile the main module. The main module will, in turn, 'import' and 'compile'
'all dependent modules.

        'logger.msg "Compiling",.options.mainModuleName
        logger.msg("Compiling", Me.options.mainModuleName)

        'var importInfo = new Environment.ImportParameterInfo
        Dim importInfo = new Environment.ImportParameterInfo()
        'importInfo.name = .options.mainModuleName
        importInfo.name = Me.options.mainModuleName
        'importInfo.source = 'Project'
        importInfo.source = "Project"
        'importInfo.line=0
        importInfo.line = 0

        'console.time 'Parse'
        console.time("Parse")
        '.main = .importModule(.rootModule, importInfo)
        Me.main = Me.importModule(Me.rootModule, importInfo)
        '.main.isMain = true
        Me.main.isMain = true

        'if .options.perf>1, console.timeEnd 'Parse'
        if Me.options.perf > 1 Then console.timeEnd("Parse")

        'if logger.errorCount is 0
        if logger.errorCount = 0 Then
        
            'logger.info "\nParsed OK"
            logger.info("\nParsed OK")
        
        End if

'Validate

        'if no .options.skip
        if NotMe.options.skip Then
        
            'logger.info "Validating"
            logger.info("Validating")
            'console.time 'Validate'
            console.time("Validate")
            'Validate.execute
            Validate.execute()
            'if .options.perf>1, console.timeEnd 'Validate'
            if Me.options.perf > 1 Then console.timeEnd("Validate")
            'if logger.errorCount, logger.throwControlled '#{logger.errorCount} errors'
            if logger.errorCount Then logger.throwControlled("" + logger.errorCount + " errors")
        
        End if

'Produce, for each module

        'console.time 'Produce'
        console.time("Produce")
        'logger.msg "Producing #{.options.target}"
        logger.msg("Producing " + Me.options.target)
        '.filesProducedCount=0
        Me.filesProducedCount = 0
        'mkPath.create .options.outDir
        mkPath.create(Me.options.outDir)

        'for each moduleNode:Grammar.Module in map .moduleCache
        for Each item in Me.moduleCache
            Dim moduleNode__propName as string = item.key
            Dim moduleNode=item.value
        

            'var result:string
            Dim result = Nothing
            'logger.extra "source:", moduleNode.fileInfo.importInfo.name
            logger.extra("source:", moduleNode.fileInfo.importInfo.name)

            'var shouldProduce = true
            Dim shouldProduce = true
            'if moduleNode.fileInfo.isCore or no moduleNode.referenceCount
            if moduleNode.fileInfo.isCore OrElse NotmoduleNode.referenceCount Then
            
                'shouldProduce = false
                shouldProduce = false
            
            End if

            'if moduleNode.lexer.interfaceMode and .options.target is 'js'
            if moduleNode.lexer.interfaceMode AndAlso Me.options.target = "js" Then
            
                '// no interface files in js.
                'shouldProduce = false
                shouldProduce = false
            
            End if

            'if shouldProduce
            if shouldProduce Then
            

                'if not moduleNode.fileInfo.isLite
                if Not(moduleNode.fileInfo.isLite) Then
                
                    'logger.extra 'non-Lite module, copy to out dir.'
                    logger.extra("non-Lite module, copy to out dir.")
                    '#copy the file to output dir
                    'logger.msg "Note: non-lite module '#{moduleNode.fileInfo.filename}' required"
                    logger.msg("Note: non-lite module '" + moduleNode.fileInfo.filename + "' required")
                    'result = moduleNode.fileInfo.filename
                    result = moduleNode.fileInfo.filename
                
                'if not moduleNode.fileInfo.isLite
                
                else
                

'produce & get result target code

                    'moduleNode.lexer.outCode.filenames[0]=moduleNode.fileInfo.outFilename
                    moduleNode.lexer.outCode.filenames(0) = moduleNode.fileInfo.outFilename
                    'moduleNode.lexer.outCode.filenames[1]='#{moduleNode.fileInfo.outFilename.slice(0,-1)}h'
                    moduleNode.lexer.outCode.filenames(1) = "" + (moduleNode.fileInfo.outFilename.slice(0, -1)) + "h"
                    'moduleNode.lexer.outCode.fileMode=true //direct out to file
                    moduleNode.lexer.outCode.fileMode = true

                    '.produceModule moduleNode
                    Me.produceModule(moduleNode)

                    'moduleNode.lexer.outCode.close
                    moduleNode.lexer.outCode.close()
                    'result = "#{moduleNode.lexer.outCode.lineNum} lines"
                    result = "" + moduleNode.lexer.outCode.lineNum + " lines"
                
                End if

                    '//ifdef PROD_JS
                    '//if .options.generateSourceMap
                        '////console.time('Generate SourceMap #{moduleNode.fileInfo.base}')
                        '//Environment.externalCacheSave '#{moduleNode.fileInfo.outFilename}.map',
                                '//moduleNode.lexer.outCode.sourceMap.generate(
                                              '//moduleNode.fileInfo.base & moduleNode.fileInfo.outExtension
                                              '//,''
                                              '//,[Environment.relativeFrom(moduleNode.fileInfo.outDir,moduleNode.fileInfo.filename)]
                                              '//)
                        '////if .options.perf, console.timeEnd('Generate SourceMap #{moduleNode.fileInfo.base}')
                    '//endif

                'end if

                'logger.info color.green,"[OK]",result, " -> ",moduleNode.fileInfo.outRelFilename,color.normal
                

                'logger.info color.green,"[OK]",result, " -> ",moduleNode.fileInfo.outRelFilename,color.normal
                logger.info(color.green, "[OK]", result, " -> ", moduleNode.fileInfo.outRelFilename, color.normal)
                'logger.extra #blank line
                logger.extra()
                '.filesProducedCount++
                Me.filesProducedCount++
            
            End if

            'end if //shouldProduce

        'end for each module cached
            
        Next'  for each item in map

        'end for each module cached

        'logger.msg "Generated .#{.options.target} files (#{.filesProducedCount}) at #{.options.outDir}"
        

        'logger.msg "Generated .#{.options.target} files (#{.filesProducedCount}) at #{.options.outDir}"
        logger.msg("Generated ." + Me.options.target + " files (" + Me.filesProducedCount + ") at " + Me.options.outDir)
        'logger.msg "#{logger.errorCount} errors, #{logger.warningCount} warnings."
        logger.msg("" + logger.errorCount + " errors, " + logger.warningCount + " warnings.")

        '//ifdef PROD_C
        '//if no logger.errorCount, Producer_c.postProduction this
        '//endif

        'if .options.perf>1, console.timeEnd 'Produce'
        if Me.options.perf > 1 Then console.timeEnd("Produce")
     end function
     ' ---------------------------
     Public Function compileFile (filename)

'Called to compile GlobalScopeX.interface.md, from Validate module

        'var filenameInfo = new Environment.FileInfo(filename)
        Dim filenameInfo = new Environment.FileInfo(filename)
        'filenameInfo.importInfo.source = 'Compiler'
        filenameInfo.importInfo.source = "Compiler"
        'filenameInfo.importInfo.line=0
        filenameInfo.importInfo.line = 0

        '//search the file
        'filenameInfo.searchModule .rootModule.fileInfo.dir
        filenameInfo.searchModule(Me.rootModule.fileInfo.dir)

        '// create a module
        'var newModule = .createNewModule(filenameInfo, .rootModule)
        Dim newModule = Me.createNewModule(filenameInfo, Me.rootModule)

        '// compile the file
        '.compileFileOnModule filenameInfo.filename, newModule
        Me.compileFileOnModule(filenameInfo.filename, newModule)

        'return newModule
        return newModule
     end function
     ' ---------------------------
     Public Function compileFileOnModule (filename, moduleNode)

'Compilation:
'Load source -> Lexer/Tokenize -> Parse/create AST

        'logger.info String.spaces(this.recurseLevel*2),"compile: '#{Environment.relativeFrom(.options.projectDir,filename)}'"
        logger.info(String.spaces(Me.recurseLevel * 2), "compile: '" + (Environment.relativeFrom(Me.options.projectDir, filename)) + "'")

'Load source code, parse

        '.parseOnModule moduleNode, filename, Environment.loadFile(filename)
        Me.parseOnModule(moduleNode, filename, Environment.loadFile(filename))

'Check if this module 'imported other modules'. Process Imports (recursive)

        'if no .options.single
        if NotMe.options.single Then
        
            '.importDependencies moduleNode
            Me.importDependencies(moduleNode)
        
        End if
        
     end function
     ' ---------------------------
     Public Function parseOnModule (moduleNode, filename, sourceLines)
      try 
'This method will initialize lexer & parse  source lines into ModuleNode scope

'set Lexer source code, process lines, tokenize

        'logger.errorCount = 0
        logger.errorCount = 0

        'var stage = "lexer"
        Dim stage = "lexer"
        'moduleNode.lexer.initSource( filename, sourceLines )
        moduleNode.lexer.initSource(filename, sourceLines)
        'moduleNode.lexer.process()
        moduleNode.lexer.process()

'Parse source

        'stage = "parsing"
        stage = "parsing"
        'moduleNode.parse()
        moduleNode.parse()

'Check if errors were emitted

        'if logger.errorCount, logger.throwControlled "#{logger.errorCount} errors emitted"
        if logger.errorCount Then logger.throwControlled("" + logger.errorCount + " errors emitted")

'Handle errors, add stage info, and stack

        'exception err
        
        Catch err

            'if err instanceof ControlledError  //if not 'controlled' show lexer pos & call stack (includes err text)
            if TypeOf err is ControlledError Then
            
                'err = moduleNode.lexer.hardError or err //get important (inner) error
                err = moduleNode.lexer.hardError OrElse err
            
            'if err instanceof ControlledError  //if not 'controlled' show lexer pos & call stack (includes err text)
            
            else
            
                '// uncontrolled
                '// add position & stack
                'err.message = "#{moduleNode.lexer.posToString()}\n#{err.stack or err.message}"
                err.message = "" + (moduleNode.lexer.posToString()) + "\n" + (err.stack OrElse err.message)
            
            End if

            'logger.error err.message
            logger.error(err.message)

            '#show last soft error. Can be useful to pinpoint the problem
            'if moduleNode.lexer.softError, logger.msg "previous soft-error: #{moduleNode.lexer.softError.message}"
            if moduleNode.lexer.softError Then logger.msg("previous soft-error: " + moduleNode.lexer.softError.message)

            '//if process #we're in node.js
            '//    process.exit(1)
            '//else
            'throw err
            Throw err
        
     end function
     ' ---------------------------
     Public Function createNewModule (fileInfo, parent)

'create a **new Module** and then create a **new lexer** for the Module
'(each module has its own lexer. There is one lexer per file)

        'default parent = .rootModule
        if ismissing(parent) then parent=Me.rootModule: end if

        'var moduleNode = new Grammar.Module(parent)
        Dim moduleNode = new Grammar.Module(parent)
        'moduleNode.name = fileInfo.filename
        moduleNode.name = fileInfo.filename
        'moduleNode.fileInfo = fileInfo
        moduleNode.fileInfo = fileInfo
        'moduleNode.referenceCount = 0
        moduleNode.referenceCount = 0

'create a Lexer for the module. The Lexer receives this module exports as a "compiler"
'because the lexer preprocessor can compile marcros and generate code on the fly
'via 'compiler generate'

        'moduleNode.lexer = new Parser.Lexer(this, .options)
        moduleNode.lexer = new Parser.Lexer(Me, Me.options)

'Now create the module scope, with two local scope vars:
''module' and 'exports = module.exports'. 'exports' will hold all exported members.

        'moduleNode.createScope()
        moduleNode.createScope()
        'moduleNode.exports = new Names.Declaration('exports', {
                'nodeClass:Grammar.NamespaceDeclaration
                'normalizeModeKeepFirstCase:true
                '}
                ', moduleNode)
        moduleNode.exports = new Names.Declaration("exports", {{nodeClass,Grammar.NamespaceDeclaration}, {normalizeModeKeepFirstCase,true}}, moduleNode)
        'moduleNode.exportsReplaced = false
        moduleNode.exportsReplaced = false

        'var moduleVar = moduleNode.addToScope('module',{nodeClass:Grammar.NamespaceDeclaration})
        Dim moduleVar = moduleNode.addToScope("module", {{nodeClass,Grammar.NamespaceDeclaration}})
        '//moduleNode.exports = moduleVar.addMember('exports') #add as member of 'module'
        '//var opt = new Names.NameDeclOptions
        '//opt.pointsTo = moduleNode.exports
        '//moduleNode.addToScope('exports',opt) #add also as 'exports' in scope

'add other common built-in members of var 'module'. http://nodejs.org/api/modules.html#modules_module_id

        'moduleVar.addMember moduleNode.declareName('filename',{value:fileInfo.filename, nodeClass:Grammar.VariableDecl})
        moduleVar.addMember(moduleNode.declareName("filename", {{value,fileInfo.filename}, {nodeClass,Grammar.VariableDecl}}))

'Also, register every `import|require` in this module body, to track modules dependencies.
'We create a empty a empty `.requireCallNodes[]`, to hold:
'1. VariableRef, when is a require() call
'2. each VariableDecl, from ImportStatements

        'moduleNode.requireCallNodes=[]
        moduleNode.requireCallNodes = new ArrayList

        'return moduleNode
        return moduleNode
     end function
     ' ---------------------------
     Public Function produceModule (moduleNode)

        'moduleNode.lexer.outCode.browser = .options.browser
        moduleNode.lexer.outCode.browser = Me.options.browser

        'if .options.comments
        if Me.options.comments Then
        
            'moduleNode.lexer.outCode.put "#{COMMENT_START}Generated by LiteScript compiler v#{.options.version}, source: #{moduleNode.fileInfo.relFilename}"
            moduleNode.lexer.outCode.put("" + COMMENT_START + "Generated by LiteScript compiler v" + Me.options.version + ", source: " + moduleNode.fileInfo.relFilename)
            'moduleNode.lexer.outCode.startNewLine
            moduleNode.lexer.outCode.startNewLine()
        
        End if

        'moduleNode.produce
        moduleNode.produce()

        '#referenceSourceMap
        'if .options.generateSourceMap and moduleNode.fileInfo.outExtension is '.js'
        if Me.options.generateSourceMap AndAlso moduleNode.fileInfo.outExtension = ".js" Then
        
            'moduleNode.lexer.outCode.startNewLine
            moduleNode.lexer.outCode.startNewLine()
            'moduleNode.lexer.outCode.put "//# sourceMappingURL=#{moduleNode.fileInfo.base}#{moduleNode.fileInfo.outExtension}.map"
            moduleNode.lexer.outCode.put("//# sourceMappingURL=" + moduleNode.fileInfo.base + moduleNode.fileInfo.outExtension + ".map")
        
        End if
        
     end function
     ' ---------------------------
     Public Function importDependencies (moduleNode)

'Check if this module 'imported other modules'. Process Imports (recursive)<br>
'Note: This function does not get called if lite was run with the '-s' option

        'for each node:ASTBase in moduleNode.requireCallNodes
        For Each node in moduleNode.requireCallNodes
        

            'var importInfo = new Environment.ImportParameterInfo
            Dim importInfo = new Environment.ImportParameterInfo()
            'importInfo.source=moduleNode.fileInfo.filename
            importInfo.source = moduleNode.fileInfo.filename
            'importInfo.line=node.sourceLineNum
            importInfo.line = node.sourceLineNum


'get import parameter, and parent Module
'store a pointer to the imported module in
'the statement AST node

'If the origin is: ImportStatement/global Declare

            'if node instance of Grammar.ImportStatementItem
            if TypeOf node is Grammar.ImportStatementItem Then
            
                'declare node:Grammar.ImportStatementItem
                
                'if node.importParameter
                if node.importParameter Then
                
                    'importInfo.name = node.importParameter.getValue()
                    importInfo.name = node.importParameter.getValue()
                
                'if node.importParameter
                
                else
                
                    'importInfo.name = node.name
                    importInfo.name = node.name
                
                End if

                'if node.hasAdjective('shim') and node.findInScope(importInfo.name)
                if node.hasAdjective("shim") AndAlso node.findInScope(importInfo.name) Then
                
                    'continue // do not import if "shim import" and already declared
                    continue
                
                End if

'if it was 'global declare' set flags

                'if node.parent instanceof Grammar.DeclareStatement
                if TypeOf node.parent is Grammar.DeclareStatement Then
                
                    'importInfo.isGlobalDeclare = true
                    importInfo.isGlobalDeclare = true
                
                'if node.parent instanceof Grammar.DeclareStatement
                
                elseif TypeOf node.parent is Grammar.ImportStatement Then
                
                    'importInfo.globalImport = node.hasAdjective("global")
                    importInfo.globalImport = node.hasAdjective("global")
                
                End if
                End if
                
            
            End if

'if found a valid filename to import

            'if importInfo.name
            if importInfo.name Then
            
                'node.importedModule = .importModule(moduleNode, importInfo)
                node.importedModule = Me.importModule(moduleNode, importInfo)
            
            End if
            
        Next'  each in moduleNode.requireCallNodes
        
     end function
     ' ---------------------------
     Public Function importModule (importingModule, importInfo)

'importParameter is the raw string passed to `import/require` statements,

'*Return*: a ModuleNode AST Class instance (from local cache, external cache or as a result of compilation)

        'declare valid .recurseLevel
        

        '.recurseLevel++
        Me.recurseLevel++
        'var indent = String.spaces(.recurseLevel*2)
        Dim indent = String.spaces(Me.recurseLevel * 2)

        'logger.info ""
        logger.info("")
        'logger.info indent,"'#{importingModule.fileInfo.relFilename}' imports '#{importInfo.name}'"
        logger.info(indent, "'" + importingModule.fileInfo.relFilename + "' imports '" + importInfo.name + "'")

'Determine the full module filename. Search for the module in the environment.

        'var fileInfo = new Environment.FileInfo(importInfo)
        Dim fileInfo = new Environment.FileInfo(importInfo)

        'fileInfo.searchModule importingModule.fileInfo.dir
        fileInfo.searchModule(importingModule.fileInfo.dir)

        'var moduleNode
        Dim moduleNode = Nothing

'Before compiling the module, check internal, and external cache

'Check Internal Cache: if it is already compiled, return cached Module node

        'if .moduleCache.has(fileInfo.filename) #registered
        if Me.moduleCache.has(fileInfo.filename) Then
        
            'logger.info indent,'cached: ',fileInfo.filename
            logger.info(indent, "cached: ", fileInfo.filename)
            'moduleNode =  .moduleCache.get(fileInfo.filename)
            moduleNode = Me.moduleCache.get(fileInfo.filename)
            'moduleNode.dependencyTreeLevelOrder++
            moduleNode.dependencyTreeLevelOrder++
            'if moduleNode.dependencyTreeLevel<=importingModule.dependencyTreeLevel
            if moduleNode.dependencyTreeLevel <= importingModule.dependencyTreeLevel Then
            
                'moduleNode.dependencyTreeLevel=importingModule.dependencyTreeLevel+1
                moduleNode.dependencyTreeLevel = importingModule.dependencyTreeLevel + 1
            
            End if
            '.recurseLevel--
            Me.recurseLevel--
            'return moduleNode
            return moduleNode
        
        End if

'It isn't on internal cache, then create a **new Module**.

        'moduleNode = .createNewModule(fileInfo)
        moduleNode = Me.createNewModule(fileInfo)
        'moduleNode.dependencyTreeLevel = .recurseLevel
        moduleNode.dependencyTreeLevel = Me.recurseLevel

'early add to local cache, to cut off circular references

        '.moduleCache.set fileInfo.filename, moduleNode
        Me.moduleCache.set(fileInfo.filename, moduleNode)
        'moduleNode.importOrder = .moduleCache.size
        moduleNode.importOrder = Me.moduleCache.size

'Check if we can get exports from a "interface.md" file

        'if .getInterface(importingModule, fileInfo, moduleNode)
        if Me.getInterface(importingModule, fileInfo, moduleNode) Then
        
            '#getInterface also loads and analyze .js interfaces

            '#if it is an interface, but loaded from 'import' statement
            '#we increment .referenceCount in order to produce the file
            'if not importInfo.isGlobalDeclare, moduleNode.referenceCount++
            if Not(importInfo.isGlobalDeclare) Then moduleNode.referenceCount++
        
        'if .getInterface(importingModule, fileInfo, moduleNode)
        
        else
        

            'if importingModule is .rootModule and .options.compileIfNewer and fileInfo.outFileIsNewer
            if importingModule = Me.rootModule AndAlso Me.options.compileIfNewer AndAlso fileInfo.outFileIsNewer Then
            
                'do nothing //do not compile if source didnt change
                Do Nothing
            
            'if importingModule is .rootModule and .options.compileIfNewer and fileInfo.outFileIsNewer
            
            else
            
                'this.compileFileOnModule fileInfo.filename, moduleNode
                Me.compileFileOnModule(fileInfo.filename, moduleNode)
                'moduleNode.referenceCount++
                moduleNode.referenceCount++
            
            End if
            
        
        End if


'at last, return the parsed Module node

        'this.recurseLevel-=1
        Me.recurseLevel -= 1
        'return moduleNode
        return moduleNode
     end function
     ' ---------------------------
     Public Function getInterface (importingModule, fileInfo, moduleNode)
'If a 'interface' file exists, compile interface declarations instead of file
'return true if interface (exports) obtained

        'if fileInfo.interfaceFileExists
        if fileInfo.interfaceFileExists Then
        
            '# compile interface
            'this.compileFileOnModule fileInfo.interfaceFile, moduleNode
            Me.compileFileOnModule(fileInfo.interfaceFile, moduleNode)
            'return true //got Interface
            return true
        
        End if

'if we're generating c-code, a interface or file must exist

        'if .options.target in ['c','vb'], return
        if new ArrayList From {"c", "vb"}
        .Contains(Me.options.target) Then return
        '//ifdef PROD_VB
        'return
        return
     end function
     ' ---------------------------
     Public Function compilerVar (name)
'helper compilerVar(name)
'return rootModule.compilerVars.members[name].value

        'return .compilerVars.get(name)
        return Me.compilerVars.get(name)
     end function
     ' ---------------------------
     Public Function setCompilerVar (name, value)
'helper compilerVar(name)
'rootModule.compilerVars.members.set(name,value)

        'if no .compilerVars.get(name) into var nameDecl
        Dim nameDecl as Object
        if Not(Assign(nameDecl,Me.compilerVars.get(name))) Then
        
            'nameDecl = new Names.Declaration(name,{nodeClass:Grammar.VariableDecl})
            nameDecl = new Names.Declaration(name, {{nodeClass,Grammar.VariableDecl}})
            '.compilerVars.set name, nameDecl
            Me.compilerVars.set(name, nameDecl)
        
        End if

        'nameDecl.setMember "**value**",value
        nameDecl.setMember("**value**", value)
     end function
     ' ---------------------------
     Public Function redirectOutput (newOut)

        'for each moduleNode:Grammar.Module in map .moduleCache
        for Each item in Me.moduleCache
              Dim moduleNode__propName as string = item.key
              Dim moduleNode=item.value
        
              'moduleNode.lexer.outCode = newOut
              moduleNode.lexer.outCode = newOut
        Next'  for each item in map
        
     end function
    
    end class 'Project

'##Add helper properties and methods to AST node class Module

    '    append to class Grammar.Module
    Partial Class Grammar.Module
    
     '     properties
        'isMain: boolean
        'fileInfo #module file info
        'exports: Names.Declaration # holds module.exports as members
        'exportsReplaced: boolean # if exports was replaced by a item with 'export only'
        'requireCallNodes: Grammar.ImportStatementItem array #list of `import` item nodes or `require()` function calls (varRef)
        'referenceCount
        'movedToGlobal: boolean

     '     method getCompiledLines returns string array
         Public Property isMain as Boolean' mainType: Boolean  
     
         Public Property fileInfo as Object
         Public Property exports as Names.Declaration' mainType: Names.Declaration  
     
         Public Property exportsReplaced as Boolean' mainType: Boolean  
     
         Public Property requireCallNodes as Array' mainType: Array  ' itemType: Grammar.ImportStatementItem
     
         Public Property referenceCount as Object
         Public Property movedToGlobal as Boolean' mainType: Boolean  
     

     '     method getCompiledLines returns string array
     ' ---------------------------
     Public Function getCompiledLines ()
        'return .lexer.outCode.getResult()
        return Me.lexer.outCode.getResult()
     end function

     '     method getCompiledText returns string
     ' ---------------------------
     Public Function getCompiledText ()
        'return .lexer.outCode.getResult().join('\n')
        return Me.lexer.outCode.getResult().join("\n")
     end function
     
    
    End Class 'partial


'### Append to class Grammar.VariableRef
'#### Properties
'        importedModule: Grammar.Module

    '    append to class Grammar.ImportStatementItem
    Partial Class Grammar.ImportStatementItem
    
     '     properties
        'importedModule: Grammar.Module
         Public Property importedModule as Grammar.Module' mainType: Grammar.Module  
     
     
    
    End Class 'partial' -----------
' Module code
' -----------

    'end class Project

'##Add helper properties and methods to AST node class Module

    '    append to class Grammar.Module
    
end module
