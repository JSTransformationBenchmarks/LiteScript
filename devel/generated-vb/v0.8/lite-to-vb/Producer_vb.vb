'Generated by LiteScript compiler v0.8.9, source: Producer_vb.lite.md
' -----------
Module Producer_vb
' -----------
'===========

'The `producer` module extends Grammar classes, adding a `produce()` method
'to generate target code for the node.

'The compiler calls the `.produce()` method of the root 'Module' node
'in order to return the compiled code for the entire tree.

'We extend the Grammar classes, so this module require the `Grammar` module.

    'import ASTBase, Grammar, Environment, UniqueID
    'var ASTBase = require('./ASTBase.vb');
    'var Grammar = require('./Grammar.vb');
    'var Environment = require('./lib/Environment.vb');
    'var UniqueID = require('./lib/UniqueID.vb');
    'shim import Map
    'var Map = require('./interfaces/Map.vb');

'VB.NET Producer Functions
'=========================

    '    append to class Grammar.Module ###
    Partial Class Grammar.Module
    

     '     method produce()
     ' ---------------------------
     Public Function produce ()

'if a 'export default' was declared, set the referenced namespace
'as the new 'export default' (instead of 'module.exports')

        '.lexer.outCode.exportNamespace = 'module.exports'
        Me.lexer.outCode.exportNamespace = "module.exports"

'Literate programming should allow to reference a function defined later.
'Leave loose module imperative statements for the last.
'Produce all vars & functions definitions first.

        'var looseStatements=[]
        Dim looseStatements = new ArrayList

        '.out
            '{COMMENT: "-----------"},NL
            '"Module #{.fileInfo.base}",NL
            '{COMMENT: "-----------"},NL

        'for each statement in .body.statements
        Me.out({{COMMENT,"-----------"}}, NL, "Module " + Me.fileInfo.base, NL, {{COMMENT,"-----------"}}, NL)

        'for each statement in .body.statements
        For Each statement in Me.body.statements
        

            'case statement.specific.constructor
            select statement.specific.constructor
            case Grammar.ImportStatement,Grammar.VarStatement,Grammar.ClassDeclaration,Grammar.FunctionDeclaration,Grammar.NamespaceDeclaration,Grammar.AppendToDeclaration
            
                        'statement.produce
                        statement.produce()
            
            
            
            case else
            
                    'looseStatements.push statement
                    looseStatements.push(statement)
            
            
        Next'  each in Me.body.statements

        '.out
            '{COMMENT: "-----------"},NL
            '{COMMENT:"Module code"},NL
            '{COMMENT: "-----------"},NL

        'for each statement in looseStatements
        Me.out({{COMMENT,"-----------"}}, NL, {{COMMENT,"Module code"}}, NL, {{COMMENT,"-----------"}}, NL)

        'for each statement in looseStatements
        For Each statement in looseStatements
        
            'statement.produce
            statement.produce()
        Next'  each in looseStatements

        '.out
            'NL
            ''end module',NL
            'NL


'export 'export default' namespace, if it was set.

'if not .lexer.outCode.browser
'            if .exportsReplaced
'                .out 'module.exports=',.exports.name,";",NL

    '    append to class Grammar.Body
        Me.out(NL, "end module", NL, NL)
     end function
     
    
    End Class 'partial


'export 'export default' namespace, if it was set.

'if not .lexer.outCode.browser
'            if .exportsReplaced
'                .out 'module.exports=',.exports.name,";",NL

    '    append to class Grammar.Body
    Partial Class Grammar.Body
    

'A "Body" is an ordered list of statements.

'"Body"s lines have all the same indent, representing a scope.

'"Body"s are used for example, to parse an `if` statement body and `else` body, `for` loops, etc.

      'method produce()
      ' ---------------------------
      Public Function produce ()

        'for each statement in .statements
        For Each statement in Me.statements
        
          'statement.produce()
          statement.produce()
        Next'  each in Me.statements

        '.out NL
        Me.out(NL)
      end function
      
    
    End Class 'partial


'-------------------------------------
    '    append to class Grammar.Statement ###
    Partial Class Grammar.Statement
    

'`Statement` objects call their specific statement node's `produce()` method
'after adding any comment lines preceding the statement

      'method produce()
      ' ---------------------------
      Public Function produce ()

'add preceeding comment lines, in the same position as the source

        '.outPreviousComments
        Me.outPreviousComments()

'To enhance compiled code readability, add original Lite line as comment

        'if .lexer.options.comments // and .lexer.outCode.lastOriginalCodeComment<.lineInx
        if Me.lexer.options.comments Then
        

            'var commentTo =  .lastSourceLineNum
            Dim commentTo = Me.lastSourceLineNum
            'if .specific has property "body"
            if Me.specific.Contains("body") OrElse TypeOf Me.specific is Grammar.IfStatement OrElse TypeOf Me.specific is Grammar.WithStatement OrElse TypeOf Me.specific is Grammar.ForStatement OrElse TypeOf Me.specific is Grammar.CaseStatement Then
            
                    'commentTo =  .sourceLineNum
                    commentTo = Me.sourceLineNum
            
            End if

            '.outSourceLinesAsComment commentTo
            Me.outSourceLinesAsComment(commentTo)
        
        End if

            '//.lexer.outCode.lastOriginalCodeComment = commentTo

'Each statement in its own line

        'if .specific isnt instance of Grammar.SingleLineBody
        if Not (TypeOf Me.specific is Grammar.SingleLineBody) Then
        
            '.lexer.outCode.ensureNewLine
            Me.lexer.outCode.ensureNewLine()
        
        End if

'if there are one or more 'into var x' in a expression in this statement,
'declare vars before statement (exclude body of FunctionDeclaration)

        'this.callOnSubTree "declareIntoVar", Grammar.Body
        Me.callOnSubTree("declareIntoVar", Grammar.Body)

'call the specific statement (if,for,print,if,function,class,etc) .produce()

        'var mark = .lexer.outCode.markSourceMap(.indent)
        Dim mark = Me.lexer.outCode.markSourceMap(Me.indent)
        '.out .specific
        Me.out(Me.specific)

'add ";" after the statement
'then EOL comment (if it isnt a multiline statement)
'then NEWLINE

        'if not .specific.skipSemiColon
        if Not(Me.specific.skipSemiColon) Then
        
          '.addSourceMap mark
          Me.addSourceMap(mark)
        
        End if
        
      end function
      
    
    End Class 'partial
          '//.out ";"

'called above, pre-declare vars from 'into var x' assignment-expression

    'append to class Grammar.Oper
    Partial Class Grammar.Oper
    
      'method declareIntoVar()
      ' ---------------------------
      Public Function declareIntoVar ()
          'if .intoVar
          if Me.intoVar Then
          
              '.out "Dim ",.right," as Object",NL
              Me.out("Dim ", Me.right, " as Object", NL)
          
          End if
          
      end function
      
    
    End Class 'partial


'---------------------------------
    '    append to class Grammar.ThrowStatement ###
    Partial Class Grammar.ThrowStatement
    

      'method produce()
      ' ---------------------------
      Public Function produce ()
          'if .specifier is 'fail'
          if Me.specifier = "fail" Then
          
            '.out "Throw New System.Exception(", .expr,")"
            Me.out("Throw New System.Exception(", Me.expr, ")")
          
          'if .specifier is 'fail'
          
          else
          
            '.out "Throw ", .expr
            Me.out("Throw ", Me.expr)
          
          End if
          
      end function
      
    
    End Class 'partial


    '    append to class Grammar.ReturnStatement ###
    Partial Class Grammar.ReturnStatement
    

      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.out "return"
        Me.out("return")
        'if .expr
        if Me.expr Then
        
          '.out " ",.expr
          Me.out(" ", Me.expr)
        
        End if
        
      end function
      
    
    End Class 'partial


    '    append to class Grammar.FunctionCall ###
    Partial Class Grammar.FunctionCall
    

      'method produce()
      ' ---------------------------
      Public Function produce ()

        '.varRef.produce()
        Me.varRef.produce()
        'if .varRef.executes, return #if varRef already executes, () are not needed
        if Me.varRef.executes Then return

        '.out "()" #add (), so JS executes the function call
        Me.out("()")
      end function
      
    
    End Class 'partial


    '    append to class Grammar.Operand ###
    Partial Class Grammar.Operand
    

'`Operand:
  '|NumberLiteral|StringLiteral|RegExpLiteral
  '|ParenExpression|ArrayLiteral|ObjectLiteral|FunctionDeclaration
  '|VariableRef

'A `Operand` is the left or right part of a binary oper
'or the only Operand of a unary oper.

      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.out .name, .accessors
        Me.out(Me.name, Me.accessors)
      end function
      
    
    End Class 'partial

      '#end Operand

    '    append to class Grammar.StringLiteral ###
    Partial Class Grammar.StringLiteral
    

      'method produce()
      ' ---------------------------
      Public Function produce ()
          '.out '"', .getValue(), '"'
          Me.out(""", Me.getValue(), """)
      end function
      
    
    End Class 'partial

    '    append to class Grammar.UnaryOper ###
    Partial Class Grammar.UnaryOper
    

'`UnaryOper: ('-'|new|type of|not|no|bitnot) `

'A Unary Oper is an operator acting on a single operand.
'Unary Oper inherits from Oper, so both are `instance of Oper`

'Examples:
'1) `not`     *boolean negation*     `if not a is b`
'2) `-`       *numeric unary minus*  `-(4+3)`
'3) `new`     *instantiation*        `x = new classNumber[2]`
'4) `type of` *type name access*     `type of x is classNumber[2]`
'5) `no`      *'falsey' check*       `if no options then options={}`
'6) `bitnot`  *bit-unary-negation*   `a = bitnot xC0 + 5`

      'method produce()
      ' ---------------------------
      Public Function produce ()

        'var translated = operTranslate(.name)
        Dim translated = operTranslate(Me.name)
        'var prepend,append
        Dim prepend = Nothing, append = Nothing

'if it is "boolean not", add parentheses, because vb has a different precedence for "boolean not"
'-(prettier generated code) do not add () for simple "falsey" variable check

        'if translated is "Not"
        if translated = "Not" Then
        
            'if not (.name is "no" and .right.name instanceof Grammar.VariableRef)
            if Not((Me.name = "no" AndAlso TypeOf Me.right.name is Grammar.VariableRef)) Then
            
                'prepend ="("
                prepend = "("
                'append=")"
                append = ")"
            
            End if
            
        
        'if translated is "Not"
        
        elseif (translated.charAt(0) >= "a" AndAlso translated.charAt(0) <= "z") OrElse (translated.charAt(0) >= "A" AndAlso translated.charAt(0) <= "Z") Then
        
              'translated &= " "
              translated &= " "
        
        End if
        End if

        '.out translated, prepend, .right, append
        Me.out(translated, prepend, Me.right, append)
      end function
      
    
    End Class 'partial


    '    append to class Grammar.Oper ###
    Partial Class Grammar.Oper
    

      'method produce()
      ' ---------------------------
      Public Function produce ()

        'var oper = .name
        Dim oper = Me.name

'default mechanism to handle 'negated' operand

        'var prepend,append
        Dim prepend = Nothing, append = Nothing
        'if .negated # NEGATED
        if Me.negated Then
        

'if NEGATED and the oper is `is` we convert it to 'isnt'.
''isnt' will be translated to !==

            'if oper is 'is' # Negated is ---> !==
            if oper = "is" Then
            
                'oper = '<>'
                oper = "<>"
            
            'if oper is 'is' # Negated is ---> !==
            
            else
            
                'prepend ="Not ("
                prepend = "Not ("
                'append=")"
                append = ")"
            
            End if
            
        
        End if

'Check for special cases:

'1) 'in' operator, requires swapping left and right operands and to use `.indexOf(...)>=0`
'example: `x in [1,2,3]` -> `[1,2,3].indexOf(x)>=0`
'example: `x not in [1,2,3]` -> `[1,2,3].indexOf(x)==-1`
'example: `char not in myString` -> `myString.indexOf(char)==-1`
'example (`arguments` pseudo-array): `'lite' not in arguments` -> `Array.prototype.slice.call(arguments).indexOf(char)==-1`

        'if .name is 'in'
        if Me.name = "in" Then
        
            '.out prepend,.right,".Contains(",.left,")", append
            Me.out(prepend, Me.right, ".Contains(", Me.left, ")", append)
        
        'if .name is 'in'
        
        elseif Me.name = "instance of" Then
        
            '.out prepend,'TypeOf ',.left," is ",.right, append
            Me.out(prepend, "TypeOf ", Me.left, " is ", Me.right, append)
        
        'else if .name is 'instance of'
        
        elseif Me.name = "has property" Then
        
            '.out prepend,.left,".Contains(",.right,")", append
            Me.out(prepend, Me.left, ".Contains(", Me.right, ")", append)
        
        'else if .name is 'has property'
        
        elseif Me.name = "into" Then
        
            '.out "Assign(",.right,",",.left,")"
            Me.out("Assign(", Me.right, ",", Me.left, ")")
        
        'else if .name is 'into'
        
        else
        
            '.out prepend, .left, ' ', operTranslate(oper), ' ', .right , append
            Me.out(prepend, Me.left, " ", operTranslate(oper), " ", Me.right, append)
        
        End if
        End if
        End if
        End if
        
      end function
      
    
    End Class 'partial


    '    append to class Grammar.Expression ###
    Partial Class Grammar.Expression
    

      'method produce(negated:boolean)
      ' ---------------------------
      Public Function produce (negated)

'Produce the expression body, negated if options={negated:true}

        'var prepend=""
        Dim prepend = ""
        'var append=""
        Dim append = ""
        'if negated
        if negated Then
        

'(prettier generated code) Try to avoid unnecessary parens after '!'
'for example: if the expression is a single variable, as in the 'falsey' check:
'Example: `if no options.log then... ` --> `if (!options.log) {...`
'we don't want: `if (!(options.log)) {...`

          'if .operandCount is 1
          if Me.operandCount = 1 Then
          
              '#no parens needed
              'prepend = "Not"
              prepend = "Not"
          
          'if .operandCount is 1
          
          else
          
              'prepend = "Not("
              prepend = "Not("
              'append = ")"
              append = ")"
          
          End if
          
        
        End if
          '#end if
        '#end if negated

'produce the expression body

        '.out prepend, .root, append
        Me.out(prepend, Me.root, append)
      end function
      
    
    End Class 'partial


    '    append to class Grammar.VariableRef ###
    Partial Class Grammar.VariableRef
    

'`VariableRef: ['--'|'++'] IDENTIFIER [Accessors] ['--'|'++']`

'`VariableRef` is a Variable Reference.

 'a VariableRef can include chained 'Accessors', which can:
 '*access a property of the object : `.`-> PropertyAccess `[`->IndexAccess
 '*assume the variable is a function and perform a function call :  `(`-> FunctionAccess

      'method produce()
      ' ---------------------------
      Public Function produce ()

        'var preIfExported
        Dim preIfExported = Nothing

'Prefix ++/--, varName, Accessors and postfix ++/--

        'var refNameDecl = .tryGetFromScope(.name)
        Dim refNameDecl = Me.tryGetFromScope(Me.name)
        'if no refNameDecl
        if NotrefNameDecl Then
        
            '.sayErr "cannot find '#{.name}' in scope"
            Me.sayErr("cannot find '" + Me.name + "' in scope")
        
        End if

'node.js module.exports is a leaky abstractions for exported
'objects other than functions (e.g: Arrays or objects).
'You MUST use always "module.export.varX" and not a local var.

'If you do:

  'var arr=[];
  'module.export.arr = arr;

  'then use arr.push... arr.pop in the module code...

'It'll work fine until a module requirer does:

  'var reqd=require('theModule');
  'reqd.arr = []

'At that point, module.export.arr will point to a different array than
'the internal module var "arr[]", so the module will stop working as intended.

        'var useme = .name is 'this'? 'Me' else .name
        Dim useme = Me.name = "this" ? "Me" : Me.name
        '.out .preIncDec, preIfExported, useme, .accessors, .postIncDec
        Me.out(Me.preIncDec, preIfExported, useme, Me.accessors, Me.postIncDec)
      end function
      
    
    End Class 'partial


    '    append to class Grammar.AssignmentStatement ###
    Partial Class Grammar.AssignmentStatement
    

      'method produce()
      ' ---------------------------
      Public Function produce ()

        '.out .lvalue, ' ', operTranslate(.name), ' ', .rvalue
        Me.out(Me.lvalue, " ", operTranslate(Me.name), " ", Me.rvalue)
      end function
      
    
    End Class 'partial


'-------
    '    append to class Grammar.DefaultAssignment ###
    Partial Class Grammar.DefaultAssignment
    

'Example: `default option = 5`

      'method produce()
      ' ---------------------------
      Public Function produce ()

        '.out "if ismissing(",.assignment.lvalue,') then ',.assignment.lvalue,"=",.assignment.rvalue,": end if",NL
        Me.out("if ismissing(", Me.assignment.lvalue, ") then ", Me.assignment.lvalue, "=", Me.assignment.rvalue, ": end if", NL)

        '.skipSemiColon = true
        Me.skipSemiColon = true
      end function
      
    
    End Class 'partial

'-----------
'## Accessors
'We just defer to JavaScript's built in `.` `[ ]` and `( )` accessors

    '    append to class Grammar.PropertyAccess ##
    Partial Class Grammar.PropertyAccess
    
      'method produce()
      ' ---------------------------
      Public Function produce ()
        'if .name is 'initInstance'
        if Me.name = "initInstance" Then
        
            'do nothing  // initInstance is the liteScript unified (C and JS) way to call Class instance Initializator function.
            Do Nothing
        
        'if .name is 'initInstance'
        
        else
        
            '.out ".",.name
            Me.out(".", Me.name)
        
        End if
        
      end function
      
    
    End Class 'partial

    '    append to class Grammar.IndexAccess
    Partial Class Grammar.IndexAccess
    
      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.out "(",.name,")"
        Me.out("(", Me.name, ")")
      end function
      
    
    End Class 'partial

    '    append to class Grammar.FunctionArgument
    Partial Class Grammar.FunctionArgument
    
      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.out .expression
        Me.out(Me.expression)
      end function
      
    
    End Class 'partial

    '    append to class Grammar.FunctionAccess
    Partial Class Grammar.FunctionAccess
    
      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.out "(",{CSL:.args},")"
        Me.out("(", {{CSL,Me.args}}, ")")
      end function
      
    
    End Class 'partial

'-----------

    '    append to class ASTBase
    Partial Class ASTBase
    
     '     helper method lastLineOf(list:ASTBase array)
     ' ---------------------------
     Public Function lastLineOf (list)

'More Helper methods, get max line of list

        'var lastLine = .sourceLineNum
        Dim lastLine = Me.sourceLineNum
        'for each item in list
        For Each item in list
        
            'if item.sourceLineNum>lastLine
            if item.sourceLineNum > lastLine Then
            
              'lastLine = item.sourceLineNum
              lastLine = item.sourceLineNum
            
            End if
            
        Next'  each in list

        'return lastLine
        return lastLine
     end function


     '     method getOwnerPrefix() returns array
     ' ---------------------------
     Public Function getOwnerPrefix ()

'check if we're inside a ClassDeclaration or AppendToDeclaration.
'return prefix for item to be appended

        'var result=[]
        Dim result = new ArrayList
        'var start = this
        Dim start = Me

        'while start and start.getParent(Grammar.ClassDeclaration) into var parent
        Dim parent as Object
        Do whilestart AndAlso Assign(parent,start.getParent(Grammar.ClassDeclaration))
        

            'var ownerName, toPrototype
            Dim ownerName = Nothing, toPrototype = Nothing

            'if parent instance of Grammar.AppendToDeclaration
            if TypeOf parent is Grammar.AppendToDeclaration Then
            
                '#append to class prototype or object
                'declare parent:Grammar.AppendToDeclaration
                
                'toPrototype = not parent.toNamespace
                toPrototype = Not(parent.toNamespace)
                'ownerName = parent.varRef
                ownerName = parent.varRef
                'var refNameDecl  = parent.varRef.tryGetReference()
                Dim refNameDecl = parent.varRef.tryGetReference()
                'if refNameDecl and refNameDecl.nodeDeclared instanceof Grammar.ClassDeclaration
                if refNameDecl AndAlso TypeOf refNameDecl.nodeDeclared is Grammar.ClassDeclaration Then
                
                    'start = refNameDecl.nodeDeclared
                    start = refNameDecl.nodeDeclared
                
                'if refNameDecl and refNameDecl.nodeDeclared instanceof Grammar.ClassDeclaration
                
                else
                
                    'start = undefined
                    start = undefined
                
                End if
                
            
            'if parent instance of Grammar.AppendToDeclaration
            
            elseif TypeOf parent is Grammar.NamespaceDeclaration Then
            
                'toPrototype = false
                toPrototype = false
                'ownerName = parent.name
                ownerName = parent.name
                'start = parent
                start = parent
            
            'else if parent instance of Grammar.NamespaceDeclaration
            
            else
            
                'toPrototype = true
                toPrototype = true
                'ownerName = parent.name
                ownerName = parent.name
                'start = parent
                start = parent
            
            End if
            End if

            'result.unshift ownerName, (toPrototype? ".prototype." else ".")
            result.unshift(ownerName, (toPrototype ? ".prototype." : "."))
        
        Loop

        '#loop

        'return result
        return result
     end function
     
    
    End Class 'partial


'---
    '    append to class Grammar.WithStatement ###
    Partial Class Grammar.WithStatement
    

'`WithStatement: with VariableRef Body`

'The WithStatement simplifies calling several methods of the same object:
'Example:
'```
'with frontDoor
    '.show
    '.open
    '.show
    '.close
    '.show
'```

      'method produce()
      ' ---------------------------
      Public Function produce ()

        '.out "With ",.name
        Me.out("With ", Me.name)
        '.out .body
        Me.out(Me.body)

        '.out "end with"
        Me.out("end with")
        '.skipSemiColon = true
        Me.skipSemiColon = true
      end function
      
    
    End Class 'partial


'---

    '    append to class Grammar.VarDeclList ###
    Partial Class Grammar.VarDeclList
    

'default "produce" for VarDeclList is to out only names, comma separated

      'method produce
      ' ---------------------------
      Public Function produce ()
        '.out {CSL:.getNames()}
        Me.out({{CSL,Me.getNames()}})
      end function
      
    
    End Class 'partial


    '    append to class Grammar.TypeDeclaration ###
    Partial Class Grammar.TypeDeclaration
    

      'method produce()
      ' ---------------------------
      Public Function produce ()
        'if .mainType.name is 'Map'
        if Me.mainType.name = "Map" Then
        
          '.out "new Dictionary(Of #{.keyType or 'Object'}, #{.itemType or 'Object'})"
          Me.out("new Dictionary(Of " + (Me.keyType OrElse "Object") + ", " + (Me.itemType OrElse "Object") + ")")
        
        'if .mainType.name is 'Map'
        
        else
        
          '.out .mainType or 'Object'
          Me.out(Me.mainType OrElse "Object")
          'if .mainType, .out {COMMENT:"mainType: #{.mainType}  "}
          if Me.mainType Then Me.out({{COMMENT,"mainType: " + Me.mainType + "  "}})
          'if .keyType, .out {COMMENT:"keyType: #{.keyType}  "}
          if Me.keyType Then Me.out({{COMMENT,"keyType: " + Me.keyType + "  "}})
          'if .itemType, .out {COMMENT:"itemType: #{.itemType}"}
          if Me.itemType Then Me.out({{COMMENT,"itemType: " + Me.itemType}})
        
        End if

        '.out NL
        Me.out(NL)
      end function
      
    
    End Class 'partial

    '    append to class Grammar.PropertiesDeclaration ###
    Partial Class Grammar.PropertiesDeclaration
    

''var' followed by a list of comma separated: var names and optional assignment

      'method produce()
      ' ---------------------------
      Public Function produce ()
        'for each varDecl in .list
        For Each varDecl in Me.list
        
          '.out '    Public Property ', varDecl.name," as ",varDecl.type or 'Object'
          Me.out("    Public Property ", varDecl.name, " as ", varDecl.type OrElse "Object")
          'if varDecl.assignedValue, .out "=",varDecl.assignedValue
          if varDecl.assignedValue Then Me.out("=", varDecl.assignedValue)
          '.out NL
          Me.out(NL)
        Next'  each in Me.list
        
      end function

      'method produceAssignment(prefix)
      ' ---------------------------
      Public Function produceAssignment (prefix)

        '//.outSourceLinesAsComment .lastLineOf(.list)

        'if no prefix, prefix = .getOwnerPrefix()
        if Notprefix Then prefix = Me.getOwnerPrefix()

        'for each varDecl in .list
        For Each varDecl in Me.list
        
          'if varDecl.assignedValue #is not valid to assign to .prototype. - creates subtle errors later
          if varDecl.assignedValue Then
          
            'if prefix instance of Array and prefix[1] and prefix[1] isnt '.', .throwError 'cannot assign values to instance properties in "Append to"'
            if TypeOf prefix is Array AndAlso prefix(1) AndAlso prefix(1) <> "." Then Me.throwError("cannot assign values to instance properties in "Append to"")
            '.out '    ',prefix, varDecl.name,"=",varDecl.assignedValue,NL
            Me.out("    ", prefix, varDecl.name, "=", varDecl.assignedValue, NL)
          
          End if
          
        Next'  each in Me.list

        '.skipSemiColon = true
        Me.skipSemiColon = true
      end function
      
    
    End Class 'partial

    '    append to class Grammar.VarStatement ###
    Partial Class Grammar.VarStatement
    

''var' followed by a list of comma separated: var names and optional assignment

      'method produce()
      ' ---------------------------
      Public Function produce ()

        'declare valid .compilerVar:function
        
        'declare valid .export
        

        '.out 'Dim '
        Me.out("Dim ")

'Now, after 'var' or 'let' out one or more comma separated VariableDecl

        '.out {CSL:.list, freeForm:.list.length>2}
        Me.out({{CSL,Me.list}, {freeForm,Me.list.length > 2}})
      end function
      
    
    End Class 'partial


    '    append to class Grammar.ImportStatementItem ###
    Partial Class Grammar.ImportStatementItem
    

      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.out "'var ",.name," = require('", .getNodeJSRequireFileRef(),"');", NL
        Me.out("'var ", Me.name, " = require('", Me.getNodeJSRequireFileRef(), "');", NL)
      end function


      'method getNodeJSRequireFileRef()
      ' ---------------------------
      Public Function getNodeJSRequireFileRef ()

        'if .lexer.options.single and .importParameter
        if Me.lexer.options.single AndAlso Me.importParameter Then
        
            'return .importParameter.name
            return Me.importParameter.name
        
        End if

'node.js require() use "./" to denote a local module to load.
'It does as bash does for executable files.
'A name  without "./"" means "look in $PATH" (node_modules and up)

        'if no .importedModule or .importedModule.fileInfo.isCore or '.interface.' in .importedModule.fileInfo.filename
        if NotMe.importedModule OrElse Me.importedModule.fileInfo.isCore OrElse Me.importedModule.fileInfo.filename.Contains(".interface.") Then
        
            'return .name // for node, no './' means "look in node_modules, and up, then global paths"
            return Me.name
        
        End if

        'var thisModule = .getParent(Grammar.Module)
        Dim thisModule = Me.getParent(Grammar.Module)

'get the required file path, relative to the location of this module (as nodejs's require() requires)

        '#debug
        '#if no .importedModule.fileInfo.outRelFilename
        '#print "thisModule.fileInfo.outRelFilename",thisModule.fileInfo.outFilename
        '#print  ".importedModule.fileInfo.outRelFilename",.importedModule.fileInfo.outFilename

        'var fn = Environment.relativeFrom(Environment.getDir(thisModule.fileInfo.outFilename)
                                            ',.importedModule.fileInfo.outFilename);
        Dim fn = Environment.relativeFrom(Environment.getDir(thisModule.fileInfo.outFilename), Me.importedModule.fileInfo.outFilename)

'check for 'import x from 'path/file';

        'if .importParameter and fn.charAt(0) is '/' //has `from 'path/file'` AND  is an absolute path
        if Me.importParameter AndAlso fn.charAt(0) = "/" Then
        
            'return fn
            return fn
        
        End if

'else, a simple 'import x'

        'return "./#{fn}"; // node.js require() use "./" to denote a local module to load
        return "./" + fn
      end function
      
    
    End Class 'partial


    '    append to class Grammar.ImportStatement ###
    Partial Class Grammar.ImportStatement
    

''import' followed by a list of comma separated: var names and optional assignment

      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.out .list //see:Grammar.ImportStatementItem
        Me.out(Me.list)
        '.skipSemiColon = true //each item is `var x=require('x');`
        Me.skipSemiColon = true
      end function
      
    
    End Class 'partial


    '    append to class Grammar.VariableDecl ###
    Partial Class Grammar.VariableDecl
    

'variable name and optionally assign a value

      'method produce()
      ' ---------------------------
      Public Function produce ()

'It's a `var` keyword or we're declaring function parameters.
'In any case starts with the variable name

          '.out .name
          Me.out(Me.name)

          'declare valid .keyword
          

'If this VariableDecl come from a 'var' statement, we force assignment (to avoid subtle bugs,
'in LiteScript, 'var' declaration assigns 'undefined')

          'if .parent instanceof Grammar.VarStatement
          if TypeOf Me.parent is Grammar.VarStatement Then
          
              '.out ' = ',.assignedValue or 'Nothing'
              Me.out(" = ", Me.assignedValue OrElse "Nothing")
          
          'if .parent instanceof Grammar.VarStatement
          
          else
          
            'if .assignedValue // parameter default assignment
            if Me.assignedValue Then
            
                '.out ':=',.assignedValue
                Me.out(":=", Me.assignedValue)
            
            End if
            
          
          End if
          
      end function
      
    
    End Class 'partial

    '#end VariableDecl


    '    append to class Grammar.SingleLineBody ###
    Partial Class Grammar.SingleLineBody
    

      'method produce()
      ' ---------------------------
      Public Function produce ()
        'var bare=[]
        Dim bare = new ArrayList
        'for each statement in .statements
        For Each statement in Me.statements
        
            'bare.push statement.specific
            bare.push(statement.specific)
        Next'  each in Me.statements
        '.out {CSL:bare, separator:","}
        Me.out({{CSL,bare}, {separator,","}})
      end function
      
    
    End Class 'partial

    '    append to class Grammar.IfStatement ###
    Partial Class Grammar.IfStatement
    

      'method produce()
      ' ---------------------------
      Public Function produce ()

        'declare valid .elseStatement.produce
        

        'if .body instanceof Grammar.SingleLineBody
        if TypeOf Me.body is Grammar.SingleLineBody Then
        
            '.out "if ", .conditional,' Then ',.body
            Me.out("if ", Me.conditional, " Then ", Me.body)
        
        'if .body instanceof Grammar.SingleLineBody
        
        else
        
            '.out "if ", .conditional, " Then", NL // .getEOLComment()
            Me.out("if ", Me.conditional, " Then", NL)
            '.out  .body, NL
            Me.out(Me.body, NL)
            'if .elseStatement
            if Me.elseStatement Then
            
                '.outSourceLinesAsComment
                Me.outSourceLinesAsComment()
                '.elseStatement.produce()
                Me.elseStatement.produce()
            
            End if
            '.out "End if",NL
            Me.out("End if", NL)
        
        End if
        
      end function
      
    
    End Class 'partial


    '    append to class Grammar.ElseIfStatement ###
    Partial Class Grammar.ElseIfStatement
    

      'method produce()
      ' ---------------------------
      Public Function produce ()

        '.out NL,"else", .nextIf
        Me.out(NL, "else", Me.nextIf)
      end function
      
    
    End Class 'partial

    '    append to class Grammar.ElseStatement ###
    Partial Class Grammar.ElseStatement
    

      'method produce()
      ' ---------------------------
      Public Function produce ()

        '.out NL,"else",NL, .body, NL
        Me.out(NL, "else", NL, Me.body, NL)
      end function
      
    
    End Class 'partial

    '    append to class Grammar.ForStatement ###
    Partial Class Grammar.ForStatement
    

'There are 3 variants of `ForStatement` in LiteScript

      'method produce()
      ' ---------------------------
      Public Function produce ()

        '.variant.produce()
        Me.variant.produce()

'Since al 3 cases are closed with '}; //comment', we skip statement semicolon

        '.skipSemiColon = true
        Me.skipSemiColon = true
      end function
      
    
    End Class 'partial

'Pre-For code. If required, store the iterable in a temp var.
'(prettier generated code)
'Only do it if the iterable is a complex expression, if it can have side-effects or it's a literal.
'We create a temp var to assign the iterable expression to

    'Append to class Grammar.Expression
    Partial Class Grammar.Expression
    

      'method prepareTempVar() returns string
      ' ---------------------------
      Public Function prepareTempVar ()

        'declare .root.name: Grammar.VariableRef
        

        'if .operandCount>1 or .root.name.hasSideEffects or .root.name instanceof Grammar.Literal
        if Me.operandCount > 1 OrElse Me.root.name.hasSideEffects OrElse TypeOf Me.root.name is Grammar.Literal Then
        
            'var tempVarIterable = UniqueID.getVarName('list')  #unique temp iterable var name
            Dim tempVarIterable = UniqueID.getVarName("list")
            '.out "var ",tempVarIterable,"=",this,NL
            Me.out("var ", tempVarIterable, "=", Me, NL)
            'return tempVarIterable
            return tempVarIterable
        
        End if

        'return this
        return Me
      end function
      
    
    End Class 'partial


    '    append to class Grammar.ForEachProperty
    Partial Class Grammar.ForEachProperty
    
'### Variant 1) 'for each property' to loop over *object property names*

'`ForEachProperty: for each [own] property name-VariableDecl in object-VariableRef`

      'method produce()
      ' ---------------------------
      Public Function produce ()

          'var iterable = .iterable.prepareTempVar()
          Dim iterable = Me.iterable.prepareTempVar()

          'if .valueVar
          if Me.valueVar Then
          
            '.out "var ", .valueVar.name,"=undefined;",NL
            Me.out("var ", Me.valueVar.name, "=undefined;", NL)
          
          End if

          'var index=.keyIndexVar or UniqueID.getVarName('inx');
          Dim index = Me.keyIndexVar OrElse UniqueID.getVarName("inx")

          '.out "for ( var ", index, " in ", iterable, ")"
          Me.out("for ( var ", index, " in ", iterable, ")")

          'if .ownKey
          if Me.ownKey Then
          
              '.out "if (",iterable,".hasOwnProperty(",index,"))"
              Me.out("if (", iterable, ".hasOwnProperty(", index, "))")
          
          End if

          '.body.out "{", .valueVar.name,"=",iterable,"[",index,"];",NL
          Me.body.out("{", Me.valueVar.name, "=", iterable, "[", index, "];", NL)

          '.body.out .where
          Me.body.out(Me.where)

          '.body.out "{", .body, "}",NL
          Me.body.out("{", Me.body, "}", NL)

          '.body.out NL, "}"
          Me.body.out(NL, "}")

          '.out {COMMENT:"end for each property"},NL
          Me.out({{COMMENT,"end for each property"}}, NL)
      end function
      
    
    End Class 'partial


    '    append to class Grammar.ForEachInArray
    Partial Class Grammar.ForEachInArray
    
'### Variant 2) 'for each index' to loop over *Array indexes and items*

'`ForEachInArray: for each [index-VariableDecl,]item-VariableDecl in array-VariableRef`

      'method produce()
      ' ---------------------------
      Public Function produce ()

        'var iterable = .iterable.prepareTempVar()
        Dim iterable = Me.iterable.prepareTempVar()

        'if .isMap //new syntax "for each in map xx"
        if Me.isMap Then
        
            'return .produceInMap(iterable)
            return Me.produceInMap(iterable)
        
        End if

'Create a default index var name if none was provided

        'var indexVarName, startValue
        Dim indexVarName = Nothing, startValue = Nothing

        'if .keyIndexVar
        if Me.keyIndexVar Then
        
            'indexVarName = .keyIndexVar.name
            indexVarName = Me.keyIndexVar.name
            'startValue = .keyIndexVar.assignedValue or "0"
            startValue = Me.keyIndexVar.assignedValue OrElse "0"
            '.out "Dim ",indexVarName," as Integer =",startValue,NL
            Me.out("Dim ", indexVarName, " as Integer =", startValue, NL)
        
        End if

        '.out "For Each ", .valueVar.name, " in ", iterable,NL
        Me.out("For Each ", Me.valueVar.name, " in ", iterable, NL)
        '.out .where
        Me.out(Me.where)
        '.out .body
        Me.out(Me.body)
        'if .where, .out "End if",NL
        if Me.where Then Me.out("End if", NL)

        '.out "Next",{COMMENT:[" each in ",.iterable]},NL
        Me.out("Next", {{COMMENT,new ArrayList From {" each in ", Me.iterable}
        }}, NL)
      end function


'method: produceInMap
'When Map is implemented using js "Object"

      'method produceInMap(iterable)
      ' ---------------------------
      Public Function produceInMap (iterable)

          'var indexVarName:string
          Dim indexVarName = Nothing
          'if no .keyIndexVar
          if NotMe.keyIndexVar Then
          
            'indexVarName = .valueVar.name & '__propName'
            indexVarName = Me.valueVar.name & "__propName"
          
          'if no .keyIndexVar
          
          else
          
            'indexVarName = .keyIndexVar.name
            indexVarName = Me.keyIndexVar.name
          
          End if

          '//.out "var ", .valueVar.name,"=undefined;",NL
          '//.out 'if(!',iterable,'.dict) throw(new Error("for each in map: not a Map, no .dict property"));',NL
          '.out "for Each item in ", iterable, NL
          Me.out("for Each item in ", iterable, NL)
          '.body.out 'Dim ',indexVarName, " as string = item.key",NL
          Me.body.out("Dim ", indexVarName, " as string = item.key", NL)
          'if .valueVar
          if Me.valueVar Then
          
              '.body.out 'Dim ',.valueVar.name,"=item.value",NL
              Me.body.out("Dim ", Me.valueVar.name, "=item.value", NL)
          
          End if
          '.out .where
          Me.out(Me.where)
          '.out .body
          Me.out(Me.body)
          'if .where, .out 'End if',NL
          if Me.where Then Me.out("End if", NL)

          '.out "Next",{COMMENT:" for each item in map"},NL
          Me.out("Next", {{COMMENT," for each item in map"}}, NL)
      end function
      
    
    End Class 'partial

    '    append to class Grammar.ForIndexNumeric
    Partial Class Grammar.ForIndexNumeric
    
'### Variant 3) 'for index=...' to create *numeric loops*

'`ForIndexNumeric: for index-VariableDecl "=" start-Expression [,|;] (while|until) condition-Expression [(,|;) increment-Statement]`

'Examples: `for n=0 while n<10`, `for n=0 to 9`

      'method produce()
      ' ---------------------------
      Public Function produce ()

        'var isToDownTo: boolean
        Dim isToDownTo = Nothing
        'var endTempVarName
        Dim endTempVarName = Nothing

        'if .conditionPrefix in['to','down']
        if new ArrayList From {"to", "down"}
        .Contains(Me.conditionPrefix) Then
        
            'isToDownTo= true
            isToDownTo = true
        
        End if
        'end if

        'if isToDownTo
        

        'if isToDownTo
        if isToDownTo Then
        

            '#'for n=0 to 10' -> for(n=0;n<=10;n++)
            '#'for n=10 down to 0' -> for(n=10;n>=0;n--)
            '.out "for ",.keyIndexVar.name, " As Integer =", .keyIndexVar.assignedValue or "0"
            Me.out("for ", Me.keyIndexVar.name, " As Integer =", Me.keyIndexVar.assignedValue OrElse "0")
            '.out .keyIndexVar.name, .conditionPrefix is 'to'? " to " else " downto ", .endExpression
            Me.out(Me.keyIndexVar.name, Me.conditionPrefix = "to" ? " to " : " downto ", Me.endExpression)
            '.out .body,NL
            Me.out(Me.body, NL)
            '.out "Next", NL
            Me.out("Next", NL)
        
        'if isToDownTo
        
        else
        

'while|until conditions are evaluated on each loop.
'Produce the condition, negated if the prefix is 'until'.

            '#for n=0, while n<arr.length  -> for(n=0;n<arr.length;...
            '#for n=0, until n >= arr.length  -> for(n=0;!(n>=arr.length);...
            '.out "Dim ",.keyIndexVar.name, " As Integer =", .keyIndexVar.assignedValue or "0",NL
            Me.out("Dim ", Me.keyIndexVar.name, " As Integer =", Me.keyIndexVar.assignedValue OrElse "0", NL)
            '.out "Do While ", .endExpression.produce( negated = .conditionPrefix is 'until' ),NL
            Me.out("Do While ", Me.endExpression.produce(Me.conditionPrefix = "until"), NL)
            '.out .body,NL
            Me.out(Me.body, NL)
            '.out .keyIndexVar.name,"+=1", NL
            Me.out(Me.keyIndexVar.name, "+=1", NL)
            '.out "Loop", NL
            Me.out("Loop", NL)
        
        End if
        
      end function
      
    
    End Class 'partial


    '    append to class Grammar.ForWhereFilter
    Partial Class Grammar.ForWhereFilter
    
'### Helper for where filter
'`ForWhereFilter: [where Expression]`

      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.out 'if ',.filterExpression,' Then',NL
        Me.out("if ", Me.filterExpression, " Then", NL)
      end function
      
    
    End Class 'partial

    '    append to class Grammar.DeleteStatement
    Partial Class Grammar.DeleteStatement
    
'`DeleteStatement: delete VariableRef`

      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.out 'delete ',.varRef
        Me.out("delete ", Me.varRef)
      end function
      
    
    End Class 'partial

    '    append to class Grammar.WhileUntilExpression ###
    Partial Class Grammar.WhileUntilExpression
    

      'method produce(askFor:string, negated:boolean)
      ' ---------------------------
      Public Function produce (askFor, negated)

'If the parent ask for a 'while' condition, but this is a 'until' condition,
'or the parent ask for a 'until' condition and this is 'while', we must *negate* the condition.

        'if askFor and .name isnt askFor
        if askFor AndAlso Me.name <> askFor Then
        
            'negated = true
            negated = true
        
        End if

'*askFor* is used when the source code was, for example,
'`do until Expression` and we need to code: `while(!(Expression))`
'or the code was `loop while Expression` and we need to code: `if (!(Expression)) break`

'when you have a `until` condition, you need to negate the expression
'to produce a `while` condition. (`while NOT x` is equivalent to `until x`)

        '.expr.produce negated
        Me.expr.produce(negated)
      end function
      
    
    End Class 'partial


    '    append to class Grammar.DoLoop ###
    Partial Class Grammar.DoLoop
    

      'method produce()
      ' ---------------------------
      Public Function produce ()

'Note: **WhileUntilLoop** symbol has **DoLoop** as *prototype*, so this *.produce()* method
'is used by both symbols.

        'if .postWhileUntilExpression
        if Me.postWhileUntilExpression Then
        

'if we have a post-condition, for example: `do ... loop while x>0`,

            '.out "do ",NL // .getEOLComment()
            Me.out("do ", NL)
            '.out .body
            Me.out(Me.body)
            '.out "Loop while "
            Me.out("Loop while ")
            '.postWhileUntilExpression.produce(askFor='while')
            Me.postWhileUntilExpression.produce("while")
            '.out NL
            Me.out(NL)
        
        'if .postWhileUntilExpression
        
        else
        

            '.out 'Do while'
            Me.out("Do while")
            'if .preWhileUntilExpression
            if Me.preWhileUntilExpression Then
            
              '.preWhileUntilExpression.produce(askFor='while')
              Me.preWhileUntilExpression.produce("while")
            
            'if .preWhileUntilExpression
            
            else
            
              '.out 'true'
              Me.out("true")
            
            End if
            '.out NL, .body , NL
            Me.out(NL, Me.body, NL)
            '.out "Loop",NL
            Me.out("Loop", NL)
        
        End if


        'end if


    '    append to class Grammar.LoopControlStatement ###
        
      end function
      
    
    End Class 'partial


    '    append to class Grammar.LoopControlStatement ###
    Partial Class Grammar.LoopControlStatement
    
'This is a very simple produce() to allow us to use the `break` and `continue` keywords.

      'method produce()
      ' ---------------------------
      Public Function produce ()

'validate usage inside a for/while

        'var nodeASTBase = this.parent
        Dim nodeASTBase = Me.parent
        'do
        Do whiletrue
        

            'if nodeASTBase is instanceof Grammar.FunctionDeclaration
            if TypeOf nodeASTBase is Grammar.FunctionDeclaration Then
            
                '//if we reach function header
                '.sayErr '"{.control}" outside a for|while|do loop'
                Me.sayErr(""{.control}" outside a for|while|do loop")
                'break
                break
            
            'if nodeASTBase is instanceof Grammar.FunctionDeclaration
            
            elseif TypeOf nodeASTBase is Grammar.ForStatement OrElse TypeOf nodeASTBase is Grammar.DoLoop Then
            
                    'break //ok, break/continue used inside a loop
                    break
            
            End if
            End if

            'end if

            'nodeASTBase = nodeASTBase.parent
            

            'nodeASTBase = nodeASTBase.parent
            nodeASTBase = nodeASTBase.parent
        
        Loop

        '.out .control
        Me.out(Me.control)
      end function
      
    
    End Class 'partial

    '    append to class Grammar.DoNothingStatement ###
    Partial Class Grammar.DoNothingStatement
    

      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.out "Do Nothing"
        Me.out("Do Nothing")
      end function
      
    
    End Class 'partial

    '    append to class Grammar.ParenExpression ###
    Partial Class Grammar.ParenExpression
    

'A `ParenExpression` is just a normal expression surrounded by parentheses.

      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.out "(",.expr,")"
        Me.out("(", Me.expr, ")")
      end function
      
    
    End Class 'partial

    '    append to class Grammar.ArrayLiteral ###
    Partial Class Grammar.ArrayLiteral
    

'A `ArrayLiteral` is a definition of a list like `[1, a, 2+3]`. We just pass this through to JavaScript.

      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.out "new ArrayList"
        Me.out("new ArrayList")
        'if .items.length
        if Me.items.length Then
        
          '.out " From {",{CSL:.items},"}"
          Me.out(" From {", {{CSL,Me.items}}, "}")
        
        End if
        '.out NL
        Me.out(NL)
      end function
      
    
    End Class 'partial

    '    append to class Grammar.NameValuePair ###
    Partial Class Grammar.NameValuePair
    

'A `NameValuePair` is a single item in an object definition. Since we copy js for this, we pass this straight through

      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.out "{",.name,",",.value,"}"
        Me.out("{", Me.name, ",", Me.value, "}")
      end function
      
    
    End Class 'partial

    '    append to class Grammar.ObjectLiteral ### also FreeObjectLiteral
    Partial Class Grammar.ObjectLiteral
    

'A `ObjectLiteral` is an object definition using key/value pairs like `{a:1,b:2}`.
'JavaScript supports this syntax, so we just pass it through.

'A `FreeObjectLiteral` is an object definition using key/value pairs, but in free-form
'(one NameValuePair per line, indented, comma is optional)

     '     method produce()
     ' ---------------------------
     Public Function produce ()

          'if .parent.constructor is Grammar.Operand
          if Me.parent.constructor = Grammar.Operand Then
          
              'if .parent.parent.isMap //expression has isMap set
              if Me.parent.parent.isMap Then
              
                  '.isMap = true
                  Me.isMap = true
              
              End if
              
          
          End if

          'if .isMap, .out 'new Dictionary(Of String,Object) from '
          if Me.isMap Then Me.out("new Dictionary(Of String,Object) from ")
          '.out '{',{CSL:.items, freeForm:.constructor is Grammar.FreeObjectLiteral },'}'
          Me.out("{", {{CSL,Me.items}, {freeForm,Me.constructor = Grammar.FreeObjectLiteral}}, "}")
     end function
          '//if .isMap, .out ')'


     '     method calcFastNew(className)
     ' ---------------------------
     Public Function calcFastNew (className)

'calcFastNew compose the arguments when a function is called with a instanceLiteral (ObjectLiteral).
'In this case (producing JS) we just pass the ObjectLiteral to the constructor,
'in the case of Producer C, there's a optimized version.

        'return this
        return Me
     end function
     
    
    End Class 'partial

    '    append to class Grammar.FunctionDeclaration ###
    Partial Class Grammar.FunctionDeclaration
    

'`FunctionDeclaration: '[export][generator] (function|method|constructor) [name] FunctionParameters (["=" Expression]|Body)`

'`FunctionDeclaration`s are function definitions.

'`export` prefix causes the function to be included in `module.exports`
'`generator` prefix marks a 'generator' function that can be paused by `yield` (js/ES6 function*)

     'method produce(prefix:array)
     ' ---------------------------
     Public Function produce (prefix)

      'var isConstructor = this instance of Grammar.ConstructorDeclaration
      Dim isConstructor = TypeOf Me is Grammar.ConstructorDeclaration

      '//Generators are implemented in ES6 with the "function*" keyword (note the asterisk)
      'var generatorMark = .hasAdjective("generator") and .lexer.project.compilerVar('ES6')? "*" else ""
      Dim generatorMark = Me.hasAdjective("generator") AndAlso Me.lexer.project.compilerVar("ES6") ? "*" : ""

      '.out {COMMENT:"---------------------------"},NL //function start separator
      Me.out({{COMMENT,"---------------------------"}}, NL)

      'if this instance of Grammar.MethodDeclaration
      if TypeOf Me is Grammar.MethodDeclaration Then
      

          '#get owner where this method belongs to
          'if no prefix
          if Notprefix Then
          
              'if no .getOwnerPrefix() into prefix
              if Not(Assign(prefix,Me.getOwnerPrefix())) Then
              
                  'fail with 'method "#{.name}" Cannot determine owner object'
                  Throw New System.Exception("method "" + Me.name + "" Cannot determine owner object")
              
              End if
              
          
          End if

          'var ownerName:string = prefix.join("")
          Dim ownerName = prefix.join("")
          'if ownerName.slice(-1) is '.', ownerName = ownerName.slice(0,-1)
          if ownerName.slice(-1) = "." Then ownerName = ownerName.slice(0, -1)

          '#if shim, check before define
          '//if .hasAdjective("shim"), .out "if (!Object.prototype.hasOwnProperty.call(",ownerName,",'",.name,"'))",NL

          '//if .definePropItems #we should code Object.defineProperty
          '//    .out "Object.defineProperty(",NL,
          '//          ownerName, ",'",.name,"',{value:function",generatorMark
          '//else

          '//.out "Public Function ",prefix,.name," ",generatorMark
          '.out "Public Function ",.name," "
          Me.out("Public Function ", Me.name, " ")
      
      'if this instance of Grammar.MethodDeclaration
      
      else
      
          '.out "function ",.name, generatorMark
          Me.out("function ", Me.name, generatorMark)
      
      End if

'if 'nice', produce default nice body, and then the generator header for real body

      'var isNice = .hasAdjective("nice") and not (isConstructor or .hasAdjective("shim") or .definePropItems or .hasAdjective("generator"))
      Dim isNice = Me.hasAdjective("nice") AndAlso Not((isConstructor OrElse Me.hasAdjective("shim") OrElse Me.definePropItems OrElse Me.hasAdjective("generator")))
      'if isNice
      if isNice Then
      
          '.out "("
          Me.out("(")
          'if .paramsDeclarations.list.length, .out .paramsDeclarations,","
          if Me.paramsDeclarations.list.length Then Me.out(Me.paramsDeclarations, ",")
          '.out "__callback){", NL
          Me.out("__callback){", NL)
          '.out '  nicegen.run(this, ',prefix,.name,"_generator, arguments);",NL
          Me.out("  nicegen.run(this, ", prefix, Me.name, "_generator, arguments);", NL)
          '.out "};",NL
          Me.out("};", NL)
          '.out "function* ",prefix,.name,"_generator"
          Me.out("function* ", prefix, Me.name, "_generator")
      
      End if
      'end if

'Produce function parameters declaration

      '.out "(", .paramsDeclarations, ")", NL //.getEOLComment()
      

'Produce function parameters declaration

      '.out "(", .paramsDeclarations, ")", NL //.getEOLComment()
      Me.out("(", Me.paramsDeclarations, ")", NL)

'now produce function body

      '.produceBody
      Me.produceBody()

'if we were coding .definePropItems , close Object.defineProperty

      'if .definePropItems
      if Me.definePropItems Then
      
          'for each definePropItem in .definePropItems
          For Each definePropItem in Me.definePropItems
          
            '.out NL,",",definePropItem.name,":", definePropItem.negated? 'false':'true'
            Me.out(NL, ",", definePropItem.name, ":", definePropItem.negated ? "false" : "true")
          Next'  each in Me.definePropItems
          'end for
          '.out NL,"})"
          
          '.out NL,"})"
          Me.out(NL, "})")
      
      End if

'If the function was adjectivated 'export', add to module.exports

      '.produceExport .name
      Me.produceExport(Me.name)
     end function


     '     method produceBody()
     ' ---------------------------
     Public Function produceBody ()

'if the function has a exception block, insert 'try{'

      'if no .body or no .body.statements //interface function?
      if NotMe.body OrElse NotMe.body.statements Then
      
            '//.throwError 'function #{.name} from #{.lexer.filename} has no body'
            '.sayErr 'function #{.name} from #{.lexer.filename} has no body'
            Me.sayErr("function " + Me.name + " from " + Me.lexer.filename + " has no body")
            '.out "**NO BODY**",NL
            Me.out("**NO BODY**", NL)
            '.out "end function",NL
            Me.out("end function", NL)
            'return
            return
      
      End if

'if one-line-function, code now: Example: function square(x) = x*x

      'if .body instance of Grammar.Expression
      if TypeOf Me.body is Grammar.Expression Then
      
          '.out "return ", .body
          Me.out("return ", Me.body)
      
      'if .body instance of Grammar.Expression
      
      else
      

'if it has a "catch" or "exception", insert 'try{'

          'for each statement in .body.statements
          For Each statement in Me.body.statements
          
            'if statement.specific instance of Grammar.ExceptionBlock
            if TypeOf statement.specific is Grammar.ExceptionBlock Then
            
                '.out " try ",NL
                Me.out(" try ", NL)
                'break
                break
            
            End if
            
          Next'  each in Me.body.statements

'if params defaults where included, we assign default values to arguments

          'if .paramsDeclarations
          if Me.paramsDeclarations Then
          
              'for each varDecl in .paramsDeclarations.list
              For Each varDecl in Me.paramsDeclarations.list
              
                'if varDecl.assignedValue
                if varDecl.assignedValue Then
                
                    '.body.assignIfUndefined varDecl.name, varDecl.assignedValue
                    Me.body.assignIfUndefined(varDecl.name, varDecl.assignedValue)
                
                End if
                
              Next'  each in Me.paramsDeclarations.list
              
          
          End if
              '#end for
          '#end if

          '.body.produce()
          Me.body.produce()
      
      End if

      'end if one-line-function

'close the function, add source map for function default "return undefined" execution point

      '.out "end function",NL
      

'close the function, add source map for function default "return undefined" execution point

      '.out "end function",NL
      Me.out("end function", NL)
     end function
     
    
    End Class 'partial

'--------------------
    '    append to class Grammar.PrintStatement ###
    Partial Class Grammar.PrintStatement
    
'`print` is an alias for console.log

      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.out "Debug.Print(",{"CSL":.args},")"
        Me.out("Debug.Print(", {{"CSL",Me.args}}, ")")
      end function
      
    
    End Class 'partial


'--------------------
    '    append to class Grammar.EndStatement ###
    Partial Class Grammar.EndStatement
    

'Marks the end of a block. It's just a comment for javascript

      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.skipSemiColon = true
        Me.skipSemiColon = true
      end function
      
    
    End Class 'partial

'--------------------
    '    append to class Grammar.CompilerStatement ###
    Partial Class Grammar.CompilerStatement
    

      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.skipSemiColon = true
        Me.skipSemiColon = true
      end function
      
    
    End Class 'partial


'--------------------
    '    append to class Grammar.DeclareStatement ###
    Partial Class Grammar.DeclareStatement
    

'Out as comments

      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.skipSemiColon = true
        Me.skipSemiColon = true
      end function
      
    
    End Class 'partial


'----------------------------
    '    append to class Grammar.ClassDeclaration ###
    Partial Class Grammar.ClassDeclaration
    

'Classes contain a code block with properties and methods definitions.

      'method produce()
      ' ---------------------------
      Public Function produce ()

        '.out {COMMENT:"constructor"},NL
        Me.out({{COMMENT,"constructor"}}, NL)

'First, since in JS we have a object-class-function-constructor all-in-one
'we need to get the class constructor, and separate other class items.

        'var prefix = .getOwnerPrefix()
        Dim prefix = Me.getOwnerPrefix()

        '.out "Class ",.name,NL
        Me.out("Class ", Me.name, NL)
        'if .varRefSuper
        if Me.varRefSuper Then
        
          '.out "Inherits ",.varRefSuper,NL
          Me.out("Inherits ", Me.varRefSuper, NL)
        
        End if

'properties

        'for each item in .body.statements
        For Each item in Me.body.statements
        if item.specific.constructor = Grammar.PropertiesDeclaration Then
        
            '.out item.specific
            Me.out(item.specific)
        End if
        Next'  each in Me.body.statements

'constructor

        '.out NL
        Me.out(NL)
        'if .constructorDeclaration //there was a constructor body, add specified params
        if Me.constructorDeclaration Then
        
            '.out "Sub New(", .constructorDeclaration.paramsDeclarations, ")", NL // .getEOLComment()
            Me.out("Sub New(", Me.constructorDeclaration.paramsDeclarations, ")", NL)
        
        'if .constructorDeclaration //there was a constructor body, add specified params
        
        else
        
            '.out "Sub New() 'default constructor",NL
            Me.out("Sub New() 'default constructor", NL)
        
        End if

'call super-class __init

        'if .varRefSuper
        if Me.varRefSuper Then
        
              '.out
                  '{COMMENT:["default constructor: call super.constructor"]},NL
                  '"    MyBase.New("
              'if .constructorDeclaration and .constructorDeclaration.paramsDeclarations
              Me.out({{COMMENT,new ArrayList From {"default constructor: call super.constructor"}
                  }}, NL, "    MyBase.New(")
              'if .constructorDeclaration and .constructorDeclaration.paramsDeclarations
              if Me.constructorDeclaration AndAlso Me.constructorDeclaration.paramsDeclarations Then
              
                 'var names=[]
                 Dim names = new ArrayList
                 'for each varDecl in .constructorDeclaration.paramsDeclarations.list
                 For Each varDecl in Me.constructorDeclaration.paramsDeclarations.list
                 
                    'names.push varDecl.name
                    names.push(varDecl.name)
                 Next'  each in Me.constructorDeclaration.paramsDeclarations.list
                 '.out {CSL:names}
                 Me.out({{CSL,names}})
                 '.out ")",NL
                 Me.out(")", NL)
              
              End if
              
        
        End if
              '#end for
          '#end if

'// COMENTADO: NO ES NECESARIO EN VB.NET p q las props decl tienen su valor default
'initialize own properties

'for each item in .body.statements
'          where item.specific.constructor is Grammar.PropertiesDeclaration
'            declare item.specific:Grammar.PropertiesDeclaration
'            item.specific.produceAssignment('Me.') //produce property assignments
'        

        'if .constructorDeclaration //there was a body
        if Me.constructorDeclaration Then
        
            '.constructorDeclaration.produceBody
            Me.constructorDeclaration.produceBody()
        
        End if

        '.out NL
        Me.out(NL)


'now out methods, meaning: create properties in the object-function-class prototype

        'for each item in .body.statements
        For Each item in Me.body.statements
        if Not (new ArrayList From {Grammar.PropertiesDeclaration, Grammar.ConstructorDeclaration}
          .Contains(item.specific.constructor)) Then
        
            'item.specific.produce //produce methods
            item.specific.produce()
        End if
        Next'  each in Me.body.statements

'If the class was adjectivated 'export', add to module.exports

        '.out NL,"end class '",.name,NL
        Me.out(NL, "end class '", Me.name, NL)
      end function
      
    
    End Class 'partial




    '    append to class Grammar.AppendToDeclaration ###
    Partial Class Grammar.AppendToDeclaration
    

'Any class|object can have properties or methods appended at any time.
'Append-to body contains properties and methods definitions.

      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.out "Partial Class ",.varRef,NL
        Me.out("Partial Class ", Me.varRef, NL)
        '.out .body
        Me.out(Me.body)
        '.out NL
        Me.out(NL)
        '.out "End Class 'partial"
        Me.out("End Class 'partial")
        '.skipSemiColon = true
        Me.skipSemiColon = true
      end function
      
    
    End Class 'partial



    '    append to class Grammar.NamespaceDeclaration ###
    Partial Class Grammar.NamespaceDeclaration
    

'Any class|object can have properties or methods appended at any time.
'Append-to body contains properties and methods definitions.

      'method produce()
      ' ---------------------------
      Public Function produce ()
        '.out 'Namespace ',.name,NL
        Me.out("Namespace ", Me.name, NL)
        '.out .body
        Me.out(Me.body)
      end function
      
    
    End Class 'partial


    '    append to class Grammar.TryCatch ###
    Partial Class Grammar.TryCatch
    

      'method produce()
      ' ---------------------------
      Public Function produce ()

        '.out "try ",NL,.body, .exceptionBlock,NL
        Me.out("try ", NL, Me.body, Me.exceptionBlock, NL)
        '.out "End try",NL
        Me.out("End try", NL)
      end function
      
    
    End Class 'partial

    '    append to class Grammar.ExceptionBlock ###
    Partial Class Grammar.ExceptionBlock
    

      'method produce()
      ' ---------------------------
      Public Function produce ()

        '.out NL,"Catch ",.catchVar
        Me.out(NL, "Catch ", Me.catchVar)
        '.out .body
        Me.out(Me.body)

        'if .finallyBody
        if Me.finallyBody Then
        
          '.out NL,"Finally"
          Me.out(NL, "Finally")
          '.out .finallyBody
          Me.out(Me.finallyBody)
        
        End if
        
      end function
      
    
    End Class 'partial


    '    append to class Grammar.CaseStatement ###
    Partial Class Grammar.CaseStatement
    

      '      method produce()
      ' ---------------------------
      Public Function produce ()

'if we have a varRef, is a case over a value

        'if .isInstanceof
        if Me.isInstanceof Then
        
            '.produceInstanceOfLoop
            Me.produceInstanceOfLoop()
            'return
            return
        
        End if

        '.out 'select ',.varRef,NL
        Me.out("select ", Me.varRef, NL)
        'for each index,whenSection in .cases
        Dim index as Integer =0
        For Each whenSection in Me.cases
        

            '.out 'case ', {CSL:whenSection.expressions,  separator:',', freeForm:0},NL
            Me.out("case ", {{CSL,whenSection.expressions}, {separator,","}, {freeForm,0}}, NL)
            '.out whenSection.body, NL,NL
            Me.out(whenSection.body, NL, NL)
        Next'  each in Me.cases
'else body

        'if .elseBody
        if Me.elseBody Then
        
            '.out NL,'case else', NL,.elseBody,NL
            Me.out(NL, "case else", NL, Me.elseBody, NL)
        
        End if
        
      end function


      '      method produceInstanceOfLoop
      ' ---------------------------
      Public Function produceInstanceOfLoop ()

        'var tmpVar=UniqueID.getVarName('class')
        Dim tmpVar = UniqueID.getVarName("class")
        '.out "Class_ptr ",tmpVar," = ",.varRef,".class;",NL,
            '"while(",tmpVar,"){",NL
        Me.out("Class_ptr ", tmpVar, " = ", Me.varRef, ".class;", NL, "while(", tmpVar, "){", NL)

        'for each index,whenSection in .cases
        Dim index as Integer =0
        For Each whenSection in Me.cases
        

            'whenSection.outSourceLinesAsComment
            whenSection.outSourceLinesAsComment()

            'whenSection.out index>0? 'else ' : '' ,
                ''if (', {pre:['(',.varRef,'.class=='], CSL:whenSection.expressions, post:')', separator:'||'},
                ''){',
                'whenSection.body, NL,
                ''break;',NL, //exit while super loop
                ''}'
            whenSection.out(index > 0 ? "else " : "", "if (", {{pre,new ArrayList From {"(", Me.varRef, ".class=="}
                }, {CSL,whenSection.expressions}, {post,")"}, {separator,"||"}}, "){", whenSection.body, NL, "break;", NL, "}")
        Next'  each in Me.cases

        'end for

        '.out tmpVar,'=',tmpVar,'.super;',NL //move to super
        

        '.out tmpVar,'=',tmpVar,'.super;',NL //move to super
        Me.out(tmpVar, "=", tmpVar, ".super;", NL)
        '.out '}',NL //close while loooking for super
        Me.out("}", NL)

'else body

        'if .elseBody, .out NL,'if(!tmpVar) {',.elseBody,'}'
        if Me.elseBody Then Me.out(NL, "if(!tmpVar) {", Me.elseBody, "}")
      end function
      
    
    End Class 'partial


    '    append to class Grammar.YieldExpression ###
    Partial Class Grammar.YieldExpression
    

      'method produce()
      ' ---------------------------
      Public Function produce ()

'Check location

        'if no .getParent(Grammar.FunctionDeclaration) into var functionDeclaration
        Dim functionDeclaration as Object
        if Not(Assign(functionDeclaration,Me.getParent(Grammar.FunctionDeclaration))) OrElse NotfunctionDeclaration.hasAdjective("nice") Then
        
                '.throwError '"yield" can only be used inside a "nice function/method"'
                Me.throwError(""yield" can only be used inside a "nice function/method"")
        
        End if

        'var yieldArr=[]
        Dim yieldArr = new ArrayList

        'var varRef = .fnCall.varRef
        Dim varRef = Me.fnCall.varRef
        '//from .varRef calculate object owner and method name

        'var thisValue=['null']
        Dim thisValue = new ArrayList From {"null"}
        'var fnName = varRef.name #default if no accessors
        Dim fnName = varRef.name

        'if varRef.accessors
        if varRef.accessors Then
        

            'var inx=varRef.accessors.length-1
            Dim inx = varRef.accessors.length - 1
            'if varRef.accessors[inx] instance of Grammar.FunctionAccess
            if TypeOf varRef.accessors(inx) is Grammar.FunctionAccess Then
            
                'var functionAccess = varRef.accessors[inx]
                Dim functionAccess = varRef.accessors(inx)
                'yieldArr = functionAccess.args
                yieldArr = functionAccess.args
                'inx--
                inx--
            
            End if

            'if inx>=0
            if inx >= 0 Then
            
                'if varRef.accessors[inx] isnt instance of Grammar.PropertyAccess
                if Not (TypeOf varRef.accessors(inx) is Grammar.PropertyAccess) Then
                
                    '.throwError 'yield needs a clear method name. Example: "yield until obj.method(10)". redefine yield parameter.'
                    Me.throwError("yield needs a clear method name. Example: "yield until obj.method(10)". redefine yield parameter.")
                
                End if

                'fnName = "'#{varRef.accessors[inx].name}'"
                fnName = "'" + (varRef.accessors(inx).name) + "'"
                'thisValue = [varRef.name]
                thisValue = new ArrayList From {varRef.name}
                'thisValue.push varRef.accessors.slice(0,inx)
                thisValue.push(varRef.accessors.slice(0, inx))
            
            End if
            
        
        End if


        'if .specifier is 'until'
        if Me.specifier = "until" Then
        

            'yieldArr.unshift fnName
            yieldArr.unshift(fnName)
            'yieldArr.unshift thisValue
            yieldArr.unshift(thisValue)
        
        'if .specifier is 'until'
        
        else
        

            'yieldArr.push "'map'",.arrExpression, thisValue, fnName
            yieldArr.push("'map'", Me.arrExpression, thisValue, fnName)
        
        End if


        '.out "yield [ ",{CSL:yieldArr}," ]"
        Me.out("yield [ ", {{CSL,yieldArr}}, " ]")
      end function
      
    
    End Class 'partial



'# Helper functions


'Utility
'-------

    'var NL = '\n' # New Line constant
    Dim NL = "\n"

'Operator Mapping
'================

'Many LiteScript operators can be easily mapped one-to-one with their JavaScript equivalents.

    'var OPER_TRANSLATION_map = map

      ''no':           'Not'
      ''not':          'Not'
      ''unary -':      '-'
      ''unary +':      '+'

      ''&':            '&'  //string concat
      ''&=':           '&='  //string concat

      ''bitand':       'And'
      ''bitor':        'Or'
      ''bitxor':       'Xor'
      ''bitnot':       'Not'

      ''type of':      'TypeOf'
      ''instance of':  'TypeOf'

      ''is':           '='
      ''isnt':         '<>'
      ''<>':           '<>'
      ''and':          'AndAlso'
      ''but':          'AndAlso'
      ''or':           'OrElse'
      ''has property': 'Contains'

    'function operTranslate(name:string)
    Dim OPER_TRANSLATION_map = new Dictionary(Of String,Object) from {
        {"no","Not"}
        , {"not","Not"}
        , {"unary -","-"}
        , {"unary +","+"}
        , {"&","&"}
        , {"&=","&="}
        , {"bitand","And"}
        , {"bitor","Or"}
        , {"bitxor","Xor"}
        , {"bitnot","Not"}
        , {"type of","TypeOf"}
        , {"instance of","TypeOf"}
        , {"is","="}
        , {"isnt","<>"}
        , {"<>","<>"}
        , {"and","AndAlso"}
        , {"but","AndAlso"}
        , {"or","OrElse"}
        , {"has property","Contains"}
      }

    'function operTranslate(name:string)
    ' ---------------------------
    function operTranslate(name)
      'return OPER_TRANSLATION_map.get(name) or name
      return OPER_TRANSLATION_map.get(name) OrElse name
    end function

'---------------------------------

    '    append to class ASTBase
    Partial Class ASTBase
    

'Helper methods and properties, valid for all nodes

     '     properties skipSemiColon
         Public Property skipSemiColon as Object

     '     helper method assignIfUndefined(name, value: Grammar.Expression)
     ' ---------------------------
     Public Function assignIfUndefined (name, value)

          'declare valid value.root.name.name
          
          '#do nothing if value is 'undefined'

          '#Expression->Operand->VariableRef->name
          'var varRef:Grammar.VariableRef = value.root.name
          Dim varRef = value.root.name
          'if varRef.constructor is Grammar.VariableRef
          if varRef.constructor = Grammar.VariableRef Then
          
              'if varRef.name is 'undefined'
              if varRef.name = "undefined" Then
              
                  '.out {COMMENT:name},": undefined",NL
                  Me.out({{COMMENT,name}}, ": undefined", NL)
                  'return
                  return
              
              End if
              
          
          End if

          '.out "if isMissing(",name,') then ',name,"=",value,": end if",NL
          Me.out("if isMissing(", name, ") then ", name, "=", value, ": end if", NL)
     end function

     '     helper method produceExport(name:string)
     ' ---------------------------
     Public Function produceExport (name)

'"module.export" not valid for browser modules

        'return
        return
     end function
     
    
    End Class 'partial' -----------
' Module code
' -----------
end module
