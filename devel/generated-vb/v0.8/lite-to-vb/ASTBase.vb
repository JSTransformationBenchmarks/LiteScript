'Generated by LiteScript compiler v0.8.9, source: ASTBase.lite.md
' -----------
Module ASTBase
' -----------
'-----------------------------------------

'This module defines the base abstract syntax tree class used by the grammar.
'It's main purpose is to provide utility methods used in the grammar
'for **req**uired tokens, **opt**ional tokens
'and comma or semicolon **Separated Lists** of symbols.

'Dependencies

    'import Parser, ControlledError
    'var Parser = require('./Parser.vb');
    'var ControlledError = require('./lib/ControlledError.vb');
    'import logger
    'var logger = require('./lib/logger.vb');

    '//ifdef PROD_C
    '//var COMMENT_START="//"
    '//endif
    '//ifdef PROD_JS
    '//var COMMENT_START="//"
    '//endif
    '//ifdef PROD_VB
    'var COMMENT_START="'"
    Dim COMMENT_START = "'"
    '//endif

    '    only export class ASTBase
    ' constructor
    Class ASTBase
        Public Property parent as ASTBase' mainType: ASTBase  
     
         Public Property childs as Array' mainType: Array  ' itemType: ASTBase
     
         Public Property name as String' mainType: String  
     
         Public Property keyword as String' mainType: String  
     
         Public Property type as Object
         Public Property indent as Object=0
         Public Property lexer as Parser.Lexer' mainType: Parser.Lexer  
     
         Public Property lineInx as Object
         Public Property sourceLineNum as Object
         Public Property column as Object
         Public Property locked as Boolean' mainType: Boolean  
     
         Public Property extraInfo as Object
    
    Sub New(parent, name)

        '.parent = parent
        Me.parent = parent
        '.name = name
        Me.name = name

'Get lexer from parent

        'if parent
        if parent Then
        
            '.lexer = parent.lexer
            Me.lexer = parent.lexer

'Remember this node source position.
'Also remember line index in tokenized lines, and indent

            'if .lexer
            if Me.lexer Then
            
                '.sourceLineNum = .lexer.sourceLineNum
                Me.sourceLineNum = Me.lexer.sourceLineNum
                '.column = .lexer.token.column
                Me.column = Me.lexer.token.column
                '.indent = .lexer.indent
                Me.indent = Me.lexer.indent
                '.lineInx = .lexer.lineInx
                Me.lineInx = Me.lexer.lineInx
            
            End if
            
        
        End if
        
     end function
    
     ' ---------------------------
     Public Function lock ()
'**lock** marks this node as "locked", meaning we are certain this is the right class
'for the given syntax. For example, if the `FunctionDeclaration` class see the token `function`,
'we are certain this is the right class to use, so we 'lock()'.
'Once locked, any **req**uired token not present causes compilation to fail.

        '.locked = true
        Me.locked = true
     end function
     ' ---------------------------
     Public Function getParent (searchedClass)
'**getParent** method searchs up the AST tree until a specfied node class is found

        'var node = this.parent
        Dim node = Me.parent
        'while node and node isnt instance of searchedClass
        Do whilenode AndAlso Not (TypeOf node is searchedClass)
        
            'node = node.parent # move to parent
            node = node.parent
        
        Loop
        'return node
        return node
     end function
     ' ---------------------------
     Public Function positionText ()

        'if not .lexer or no .sourceLineNum, return "(compiler-defined)"
        if Not(Me.lexer) OrElse NotMe.sourceLineNum Then return "(compiler-defined)"
        'return "#{.lexer.filename}:#{.sourceLineNum}:#{.column or 0}"
        return "" + Me.lexer.filename + ":" + Me.sourceLineNum + ":" + (Me.column OrElse 0)
     end function
     ' ---------------------------
     Public Function toString ()

        'return "[#{.constructor.name}]"
        return "[" + Me.constructor.name + "]"
     end function
     ' ---------------------------
     Public Function sayErr (msg)

        'logger.error .positionText(), msg
        logger.error(Me.positionText(), msg)
     end function
     ' ---------------------------
     Public Function warn (msg)

        'logger.warning .positionText(), msg
        logger.warning(Me.positionText(), msg)
     end function
     ' ---------------------------
     Public Function throwError (msg)
'**throwError** add node position info and throws a 'controlled' error.

'A 'controlled' error, shows only err.message

'A 'un-controlled' error is an unhandled exception in the compiler code itself,
'and it shows error message *and stack trace*.

        'logger.throwControlled "#{.positionText()}. #{msg}"
        logger.throwControlled("" + (Me.positionText()) + ". " + msg)
     end function
     ' ---------------------------
     Public Function throwParseFailed (msg)
'throws a parseFailed-error

'During a node.parse(), if there is a token mismatch, a "parse failed" is raised.
'"parse failed" signals a failure to parse the tokens from the stream,
'however the syntax might still be valid for another AST node.
'If the AST node was locked-on-target, it is a hard-error.
'If the AST node was NOT locked, it's a soft-error, and will not abort compilation
'as the parent node will try other AST classes against the token stream before failing.

        '//var err = new Error("#{.positionText()}. #{msg}")
        'var cErr = new ControlledError("#{.lexer.posToString()}. #{msg}")
        Dim cErr = new ControlledError("" + (Me.lexer.posToString()) + ". " + msg)
        'cErr.soft = not .locked
        cErr.soft = Not(Me.locked)
        'throw cErr
        Throw cErr
     end function
     ' ---------------------------
     Public Function parse ()
'abstract method representing the TRY-Parse of the node.
'Child classes _must_ override this method

        '.throwError 'Parser Not Implemented'
        Me.throwError("Parser Not Implemented")
     end function
     ' ---------------------------
     Public Function produce ()
'**produce()** is the method to produce target code for this node.
'Child classes _should_ override this,
'if the default production isnt: `.out .name`

        '.out .name
        Me.out(Me.name)
     end function
     ' ---------------------------
     Public Function parseDirect (key, directMap)

'We use a DIRECT associative array to pick the exact AST node to parse
'based on the actual token value or type.
'This speeds up parsing, avoiding parsing by trial & error

'Check keyword

        'if directMap.get(key) into var param
        Dim param as Object
        if Assign(param,directMap.get(key)) Then
        

'try parse by calling .opt

            'var statement
            Dim statement = Nothing
            'if param instance of Array
            if TypeOf param is Array Then
            
               '#accept Arrays also
               'statement = ASTBase.prototype.opt.apply(this, param)
               statement = ASTBase.prototype.opt.apply(Me, param)
            
            'if param instance of Array
            
            else
            
               '#normal call
               'statement = .opt(param)
               statement = Me.opt(param)
            
            End if

'return parsed statement or nothing

            'return statement
            return statement
        
        End if
        
     end function
     ' ---------------------------
     Public Function opt ()
'**opt** (optional) parses optional parts of a grammar. It attempts to parse
'the token stream using one of the classes or token types specified.
'This method takes a variable number of arguments.
'For example:
  'calling `.opt IfStatement, Expression, 'IDENTIFIER'`
  'would attempt to parse the token stream first as an `IfStatement`. If that fails, it would attempt
  'to use the `Expression` class. If that fails, it will accept a token of type `IDENTIFIER`.
  'If all of those fail, it will return `undefined`.

'Method start:
'Remember the actual position, to rewind if all optionals fail to parse

        'var startPos = .lexer.getPos()
        Dim startPos = Me.lexer.getPos()

        '#debug
        'var spaces = .levelIndent()
        Dim spaces = Me.levelIndent()

'For each argument, -a class or a string-, we will attempt to parse the token stream
'with the class, or match the token type to the string.

        'for each searched in arguments.toArray()
        var _list1=arguments.toArray()
        For Each searched in _list1
        

'skip empty, null & undefined

          'if no searched, continue
          if Notsearched Then continue

'determine value or type
'For strings, we check the token **value** or **TYPE** (if searched is all-uppercase)

          'if typeof searched is 'string'
          if TypeOf searched = "string" Then
          

                'declare searched:string
                

                '#debug spaces, .constructor.name,'TRY',searched, 'on', .lexer.token.toString()

                'var isTYPE = searched.charAt(0)>="A" and searched.charAt(0)<="Z" and searched is searched.toUpperCase()
                Dim isTYPE = searched.charAt(0) >= "A" AndAlso searched.charAt(0) <= "Z" AndAlso searched = searched.toUpperCase()
                'var found
                Dim found = Nothing

                'if isTYPE
                if isTYPE Then
                
                  'found = .lexer.token.type is searched
                  found = Me.lexer.token.type = searched
                
                'if isTYPE
                
                else
                
                  'found = .lexer.token.value is searched
                  found = Me.lexer.token.value = searched
                
                End if

                'if found
                if found Then
                

'Ok, type/value found! now we return: token.value
'Note: we shouldn't return the 'token' object, because returning objects (here and in js)
'is "pass-by-reference". You return a "pointer" to the object.
'If we return the 'token' object, the calling function will recive a "pointer"
'and it can inadvertedly alter the token object in the token stream. (it should not, leads to subtle bugs)

                      'logger.debug spaces, .constructor.name,'matched OK:',searched, .lexer.token.value
                      logger.debug(spaces, Me.constructor.name, "matched OK:", searched, Me.lexer.token.value)
                      'var result = .lexer.token.value
                      Dim result = Me.lexer.token.value

'Advance a token, .lexer.token always has next token

                      '.lexer.nextToken()
                      Me.lexer.nextToken()
                      'return result
                      return result
                
                End if
                
          
          'if typeof searched is 'string'
          
          else
          

'"searched" is an AST class

            'declare searched:Function //class
            

            'logger.debug spaces, .constructor.name,'TRY',searched.name, 'on', .lexer.token.toString()
            logger.debug(spaces, Me.constructor.name, "TRY", searched.name, "on", Me.lexer.token.toString())

'if the argument is an AST node class, we instantiate the class and try the `parse()` method.
'`parse()` can fail with `ParseFailed` if the syntax do not match

            'try
            try 
            

                'var astNode:ASTBase = new searched(this) # create required ASTNode, to try parse
                Dim astNode = new searched(Me)

                'astNode.parse() # if it can't parse, will raise an exception
                astNode.parse()

                'logger.debug spaces, 'Parsed OK!->',searched.name
                logger.debug(spaces, "Parsed OK!->", searched.name)

                'return astNode # parsed ok!, return instance
                return astNode
            
            Catch err
                'if err isnt instance of ControlledError, throw err //re-raise if not ControlledError
                if Not (TypeOf err is ControlledError) Then Throw err
                'declare err:ControlledError
                

'If parsing fail, but the AST node were not 'locked' on target, (a soft-error),
'we will try other AST nodes.

                'if err.soft
                if err.soft Then
                
                    '.lexer.softError = err
                    Me.lexer.softError = err
                    'logger.debug spaces, searched.name,'parse failed.',err.message
                    logger.debug(spaces, searched.name, "parse failed.", err.message)

'rewind the token stream, to try other AST nodes

                    'logger.debug "<<REW to", "#{startPos.sourceLineNum}:#{startPos.token.column or 0} [#{startPos.index}]", startPos.token.toString()
                    logger.debug("<<REW to", "" + startPos.sourceLineNum + ":" + (startPos.token.column OrElse 0) + " [" + startPos.index + "]", startPos.token.toString())
                    '.lexer.setPos startPos
                    Me.lexer.setPos(startPos)
                
                'if err.soft
                
                else
                

'else: it's a hard-error. The AST node were locked-on-target.
'We abort parsing and throw.

                    '# the first hard-error is the most informative, the others are cascading ones
                    'if .lexer.hardError is null, .lexer.hardError = err
                    if Me.lexer.hardError = null Then Me.lexer.hardError = err

'raise up, abort parsing

                    'raise err
                    Throw err
                
                End if

                'end if - type of error

            'end catch
                
            
            End try

            'end catch

          'end if - string or class
            
          
          End if

          'end if - string or class

        'end loop - try the next argument
          
        Next'  each in arguments.toArray()

        'end loop - try the next argument

'No more arguments.
'`opt` returns `undefined` if none of the arguments can be use to parse the token stream.

        'return undefined
        

'No more arguments.
'`opt` returns `undefined` if none of the arguments can be use to parse the token stream.

        'return undefined
        return undefined
     end function
     ' ---------------------------
     Public Function req ()

'**req** (required) try to parse *required* symbols of the grammar.
'It works the same way as `opt` except that it throws an error if none of the arguments
'can be used to parse the stream.

'We first call `opt` to try the arguments in order.
'If a value is returned, the parsing was successful,
'so we just return the node that `opt` found.

        'var result = ASTBase.prototype.opt.apply(this,arguments)
        Dim result = ASTBase.prototype.opt.apply(Me, arguments)

'If `opt` returns nothing, we give the user a useful error message.

        'if no result
        if Notresult Then
        
          '.throwParseFailed "#{.constructor.name}:#{.extraInfo or ''} found #{.lexer.token.toString()} but #{.listArgs(arguments)} required"
          Me.throwParseFailed("" + Me.constructor.name + ":" + (Me.extraInfo OrElse "") + " found " + (Me.lexer.token.toString()) + " but " + (Me.listArgs(arguments)) + " required")
        
        End if

        'return result
        return result
     end function
     ' ---------------------------
     Public Function reqOneOf (arr)
'(performance) check before try to parse, that the next token is in the list

        'if .lexer.token.value in arr
        if arr.Contains(Me.lexer.token.value) Then
        
            'return ASTBase.prototype.req.apply(this,arr)
            return ASTBase.prototype.req.apply(Me, arr)
        
        'if .lexer.token.value in arr
        
        else
        
            '.throwParseFailed "not in list"
            Me.throwParseFailed("not in list")
        
        End if
        
     end function
     ' ---------------------------
     Public Function optList ()
'this generic method will look for zero or more of the requested classes,

        'var item
        Dim item = Nothing
        'var list=[]
        Dim list = new ArrayList

        'do
        Do whiletrue
        
          'item = ASTBase.prototype.opt.apply(this,arguments)
          item = ASTBase.prototype.opt.apply(Me, arguments)
          'if no item then break
          if Notitem Then break
          'list.push item
          list.push(item)
        
        Loop

        'return list.length? list : undefined
        return list.length ? list : undefined
     end function
     ' ---------------------------
     Public Function optSeparatedList (astClass, separator, closer)

'Start optSeparatedList

        'var result = []
        Dim result = new ArrayList
        'var optSepar
        Dim optSepar = Nothing

'except the requested closer is NEWLINE,
'NEWLINE is included as an optional extra separator
'and also we allow a free-form mode list

        'if closer isnt 'NEWLINE' #Except required closer *IS* NEWLINE
        if closer <> "NEWLINE" Then
        

'if the list starts with a NEWLINE,
'assume an indented free-form mode separated list,
'where NEWLINE is a valid separator.

            'if .lexer.token.type is 'NEWLINE'
            if Me.lexer.token.type = "NEWLINE" Then
            
                'return .optFreeFormList( astClass, separator, closer )
                return Me.optFreeFormList(astClass, separator, closer)
            
            End if

'else normal list, but NEWLINE is accepted as optional before and after separator

            'optSepar = 'NEWLINE' #newline is optional before and after separator
            optSepar = "NEWLINE"
        
        End if

'normal separated list,
'loop until closer found

        'logger.debug "optSeparatedList [#{.constructor.name}] indent:#{.indent}, get SeparatedList of [#{astClass.name}] by '#{separator}' closer:", closer or '-no closer-'
        logger.debug("optSeparatedList [" + Me.constructor.name + "] indent:" + Me.indent + ", get SeparatedList of [" + astClass.name + "] by '" + separator + "' closer:", closer OrElse "-no closer-")

        'var blockIndent = .lexer.indent
        Dim blockIndent = Me.lexer.indent
        'var startLine = .lexer.sourceLineNum
        Dim startLine = Me.lexer.sourceLineNum
        'do until .opt(closer) or .lexer.token.type is 'EOF'
        Do whileNot(Me.opt(closer) OrElse Me.lexer.token.type = "EOF")
        

'get a item

            'var item = .req(astClass)
            Dim item = Me.req(astClass)
            '.lock()
            Me.lock()

'add item to result

            'result.push(item)
            result.push(item)

'newline after item (before comma or closer) is optional

            'var consumedNewLine = .opt(optSepar)
            Dim consumedNewLine = Me.opt(optSepar)

'if, after newline, we got the closer, then exit.

            'if .opt(closer) then break #closer found
            if Me.opt(closer) Then break

'here, a 'separator' (comma/semicolon) means: 'there is another item'.
'Any token other than 'separator' means 'end of list'

            'if no .opt(separator)
            if NotMe.opt(separator) Then
            
                '# any token other than comma/semicolon means 'end of comma separated list'
                '# but if a closer was required, then "other" token is an error
                'if closer, .throwError "Expected '#{closer}' to end list started at line #{startLine}, got '#{.lexer.token.value}'"
                if closer Then Me.throwError("Expected '" + closer + "' to end list started at line " + startLine + ", got '" + Me.lexer.token.value + "'")
                'if consumedNewLine, .lexer.returnToken()
                if consumedNewLine Then Me.lexer.returnToken()
                'break # if no error, end of list
                break
            
            End if
            'end if

'optional newline after comma

            'consumedNewLine = .opt(optSepar)
            

'optional newline after comma

            'consumedNewLine = .opt(optSepar)
            consumedNewLine = Me.opt(optSepar)
            'if consumedNewLine and .lexer.indent <= blockIndent
            if consumedNewLine AndAlso Me.lexer.indent <= blockIndent Then
            
                '.lexer.sayErr "SeparatedList, after '#{separator}' - next line is same or less indented (#{.lexer.indent}) than block indent (#{blockIndent})"
                Me.lexer.sayErr("SeparatedList, after '" + separator + "' - next line is same or less indented (" + Me.lexer.indent + ") than block indent (" + blockIndent + ")")
                'return result
                return result
            
            End if
            
        
        Loop

        'return result
        return result
     end function
     ' ---------------------------
     Public Function optFreeFormList (astClass, separator, closer)

'In "freeForm Mode", each item stands in its own line, and commas (separators) are optional.
'The item list ends when a closer is found or when indentation changes

        'var result = []
        Dim result = new ArrayList
        'var lastItemSourceLine = -1
        Dim lastItemSourceLine = -1
        'var separatorAfterItem
        Dim separatorAfterItem = Nothing
        'var parentIndent = .parent.indent or 0
        Dim parentIndent = Me.parent.indent OrElse 0

'FreeFormList should start with NEWLINE
'First line sets indent level

        '.req "NEWLINE"
        Me.req("NEWLINE")
        'var startLine = .lexer.sourceLineNum
        Dim startLine = Me.lexer.sourceLineNum
        'var blockIndent = .lexer.indent
        Dim blockIndent = Me.lexer.indent

        'logger.debug "optFreeFormList: [#{astClass.name} #{separator}]*  parent:#{.parent.name}.#{.constructor.name} parentIndent:#{parentIndent}, blockIndent:#{blockIndent}, closer:", closer or '-no-'
        logger.debug("optFreeFormList: [" + astClass.name + " " + separator + "]*  parent:" + Me.parent.name + "." + Me.constructor.name + " parentIndent:" + parentIndent + ", blockIndent:" + blockIndent + ", closer:", closer OrElse "-no-")

        'if blockIndent <= parentIndent #first line is same or less indented than parent - assume empty list
        if blockIndent <= parentIndent Then
        
          '.lexer.sayErr "free-form SeparatedList: next line is same or less indented (#{blockIndent}) than parent indent (#{parentIndent}) - assume empty list"
          Me.lexer.sayErr("free-form SeparatedList: next line is same or less indented (" + blockIndent + ") than parent indent (" + parentIndent + ") - assume empty list")
          'return result
          return result
        
        End if

'now loop until closer or an indent change

        '#if closer found (`]`, `)`, `}`), end of list
        'do until .opt(closer) or .lexer.token.type is 'EOF'
        Do whileNot(Me.opt(closer) OrElse Me.lexer.token.type = "EOF")
        

'check for indent changes

            'logger.debug "freeForm Mode .lexer.indent:#{.lexer.indent} block indent:#{blockIndent} parentIndent:#{parentIndent}"
            logger.debug("freeForm Mode .lexer.indent:" + Me.lexer.indent + " block indent:" + blockIndent + " parentIndent:" + parentIndent)
            'if .lexer.indent isnt blockIndent
            if Me.lexer.indent <> blockIndent Then
            

'indent changed:
'if a closer was specified, indent change before the closer means error (line misaligned)

                  'if closer
                  if closer Then
                  
                    '.lexer.throwErr "Misaligned indent: #{.lexer.indent}. Expected #{blockIndent}, or '#{closer}' to end block started at line #{startLine}"
                    Me.lexer.throwErr("Misaligned indent: " + Me.lexer.indent + ". Expected " + blockIndent + ", or '" + closer + "' to end block started at line " + startLine)
                  
                  End if

'check for excesive indent

                  '//if .lexer.indent > blockIndent
                  '//  .lexer.throwErr "Misaligned indent: #{.lexer.indent}. Expected #{blockIndent} to continue block, or #{parentIndent} to close block started at line #{startLine}"

'else, if no closer specified, and indent decreased => end of list

                  'break #end of list
                  break
            
            End if

            'end if

'check for more than one statement on the same line, with no separator

            'if not separatorAfterItem and .lexer.sourceLineNum is lastItemSourceLine
            

'check for more than one statement on the same line, with no separator

            'if not separatorAfterItem and .lexer.sourceLineNum is lastItemSourceLine
            if Not(separatorAfterItem) AndAlso Me.lexer.sourceLineNum = lastItemSourceLine Then
            
                '.lexer.sayErr "More than one [#{astClass.name}] on line #{lastItemSourceLine}. Missing ( ) on function call?"
                Me.lexer.sayErr("More than one [" + astClass.name + "] on line " + lastItemSourceLine + ". Missing ( ) on function call?")
            
            End if

            'lastItemSourceLine = .lexer.sourceLineNum
            lastItemSourceLine = Me.lexer.sourceLineNum

'else, get a item

            'var item = .req(astClass)
            Dim item = Me.req(astClass)
            '.lock()
            Me.lock()

'add item to result

            'result.push(item)
            result.push(item)

'newline after item (before comma or closer) is optional

            '.opt('NEWLINE')
            Me.opt("NEWLINE")

'separator (comma|semicolon) is optional,
'NEWLINE also is optional and valid

            'separatorAfterItem = .opt(separator)
            separatorAfterItem = Me.opt(separator)
            '.opt('NEWLINE')
            Me.opt("NEWLINE")
        
        Loop

        'logger.debug "END freeFormMode [#{.constructor.name}] blockIndent:#{blockIndent}, get SeparatedList of [#{astClass.name}] by '#{separator}' closer:", closer or '-no closer-'
        logger.debug("END freeFormMode [" + Me.constructor.name + "] blockIndent:" + blockIndent + ", get SeparatedList of [" + astClass.name + "] by '" + separator + "' closer:", closer OrElse "-no closer-")

        '//if closer then .opt('NEWLINE') # consume optional newline after closer in free-form mode

        'return result
        return result
     end function
     ' ---------------------------
     Public Function reqSeparatedList (astClass, separator, closer)
'**reqSeparatedList** is the same as `optSeparatedList` except that it throws an error
'if the list is empty

'First, call optSeparatedList

        'var result:ASTBase array = .optSeparatedList(astClass, separator, closer)
        Dim result = Me.optSeparatedList(astClass, separator, closer)
        'if result.length is 0, .throwParseFailed "#{.constructor.name}: Get list: At least one [#{astClass.name}] was expected"
        if result.length = 0 Then Me.throwParseFailed("" + Me.constructor.name + ": Get list: At least one [" + astClass.name + "] was expected")

        'return result
        return result
     end function
     ' ---------------------------
     Public Function listArgs (args)
'listArgs list arguments (from opt or req). used for debugging
'and syntax error reporting

        'var msg = []
        Dim msg = new ArrayList
        'for each i in args
        For Each i in args
        

            'declare valid i.name
            

            'if typeof i is 'string'
            if TypeOf i = "string" Then
            
                'msg.push("'#{i}'")
                msg.push("'" + i + "'")
            
            'if typeof i is 'string'
            
            elseif i Then
            
                'if typeof i is 'function'
                if TypeOf i = "function" Then
                
                  'msg.push("[#{i.name}]")
                  msg.push("[" + i.name + "]")
                
                'if typeof i is 'function'
                
                else
                
                  'msg.push("<#{i.name}>")
                  msg.push("<" + i.name + ">")
                
                End if
                
            
            'else if i
            
            else
            
                'msg.push("[null]")
                msg.push("[null]")
            
            End if
            End if
            
        Next'  each in args

        'return msg.join('|')
        return msg.join("|")
     end function
     ' ---------------------------
     Public Function out ()

'*out* is a helper function for code generation
'It evaluates and output its arguments. uses .lexer.out

        'var rawOut = .lexer.outCode
        Dim rawOut = Me.lexer.outCode

        'for each item in arguments.toArray()
        var _list2=arguments.toArray()
        For Each item in _list2
        

'skip empty items

          'if no item, continue
          if Notitem Then continue

'if it is the first thing in the line, out indentation

          'if rawOut.currLine.length is 0  and .indent > 0
          if rawOut.currLine.length = 0 AndAlso Me.indent > 0 Then
          
              'rawOut.put String.spaces(.indent)
              rawOut.put(String.spaces(Me.indent))
          
          End if

'if it is an AST node, call .produce()

          'if item instance of ASTBase
          if TypeOf item is ASTBase Then
          
              'declare item:ASTBase
              
              'item.produce()
              item.produce()
          
          'if item instance of ASTBase
          
          elseif item = "\n" Then
          
            'rawOut.startNewLine()
            rawOut.startNewLine()
          
          'else if item is '\n'
          
          elseif TypeOf item = "string" Then
          
            'rawOut.put item
            rawOut.put(item)
          
          'else if type of item is 'string'
          
          elseif TypeOf item is Array Then
          
              '# Recursive #
              'ASTBase.prototype.out.apply this,item
              ASTBase.prototype.out.apply(Me, item)
          
          'else if item instance of Array
          
          elseif TypeOf item is Object Then
          

            '// expected keys:
            '//  COMMENT:string, NLI, CSL:Object array, freeForm, h

'{CSL:arr} -> output the array as Comma Separated List (note: CSL can be present and undefined)

              'if item.hasProperty('CSL')
              Dim comment as Object
              Dim header as Object
              if item.hasProperty("CSL") Then
              

                  'var CSL:array = item.tryGetProperty("CSL")
                  Dim CSL = item.tryGetProperty("CSL")

                  'if CSL
                  if CSL Then
                  
                      '// additional keys: pre,post,separator
                      'var separator = item.tryGetProperty('separator') or ', '
                      Dim separator = item.tryGetProperty("separator") OrElse ", "
                      'var freeFormMode = item.tryGetProperty('freeForm')
                      Dim freeFormMode = item.tryGetProperty("freeForm")
                      'var newLineIncluded = false
                      Dim newLineIncluded = false
                      'var actualIndent = rawOut.getIndent()
                      Dim actualIndent = rawOut.getIndent()

                      'for each inx,listItem in CSL
                      Dim inx as Integer =0
                      For Each listItem in CSL
                      

                            'declare valid listItem.out
                            

                            'if freeFormMode
                            if freeFormMode Then
                            
                                'rawOut.startNewLine
                                rawOut.startNewLine()
                                'rawOut.put String.spaces(actualIndent+4)
                                rawOut.put(String.spaces(actualIndent + 4))
                                'newLineIncluded = true
                                newLineIncluded = true
                            
                            End if

                            'if inx>0
                            if inx > 0 Then
                            
                                'rawOut.put separator
                                rawOut.put(separator)
                            
                            End if

                            '#recurse
                            '.out item.tryGetProperty('pre'), listItem, item.tryGetProperty('post')
                            Me.out(item.tryGetProperty("pre"), listItem, item.tryGetProperty("post"))
                      Next'  each in CSL

                      'end for

                      'if newLineIncluded # prettier generated code
                      

                      'if newLineIncluded # prettier generated code
                      if newLineIncluded Then
                      
                            'rawOut.startNewLine
                            rawOut.startNewLine()
                      
                      End if
                      
                  
                  End if
                  
              
              'if item.hasProperty('CSL')
              
              elseif Assign(comment,item.tryGetProperty("COMMENT")) Then
              

                  'if no .lexer or .lexer.options.comments #comments level > 0
                  if NotMe.lexer OrElse Me.lexer.options.comments Then
                  

                      '# prepend // if necessary
                      'if type of item isnt 'string' or not comment.startsWith(COMMENT_START), rawOut.put "#{COMMENT_START} "
                      if TypeOf item <> "string" OrElse Not(comment.startsWith(COMMENT_START)) Then rawOut.put("" + COMMENT_START + " ")
                      '.out comment
                      Me.out(comment)
                  
                  End if
                  
              
              'else if item.tryGetProperty('COMMENT') into var comment:string
              
              elseif Assign(header,item.tryGetProperty("h")) <> undefined Then
              
                  'rawOut.setHeader header
                  rawOut.setHeader(header)
              
              'else if item.tryGetProperty('h') into var header:number isnt undefined
              
              else
              
                  '.sayErr "ASTBase method out Map|Object: unrecognized keys: #{item.allPropertyNames()}"
                  Me.sayErr("ASTBase method out Map|Object: unrecognized keys: " + (item.allPropertyNames()))
              
              End if
              End if
              End if
              
          
          'else if item instanceof Object
          
          else
          
              'rawOut.put item.toString() # try item.toString()
              rawOut.put(item.toString())
          
          End if
          End if
          End if
          End if
          End if

          'end if

        'end loop, next item
          
        Next'  each in arguments.toArray()

        'end loop, next item


     '     helper method outInfoLineAsComment(lineInx)
        
     end function
     ' ---------------------------
     Public Function outInfoLineAsComment (lineInx)

'out line, using comment chars form the target lang (js & c: "//")

        '.lexer.infoLines[lineInx].outAsComment .lexer.outCode
        Me.lexer.infoLines(lineInx).outAsComment(Me.lexer.outCode)
     end function
     ' ---------------------------
     Public Function outPreviousComments ()

'out previous lines with comments

        'if no .sourceLineNum, return // if undefined or 0
        if NotMe.sourceLineNum Then return

        '//search CODE line, immediatly previous to this
        'var prevCODElineInx = .lexer.getPrevCODEInfoLineIndex(.sourceLineNum)
        Dim prevCODElineInx = Me.lexer.getPrevCODEInfoLineIndex(Me.sourceLineNum)

        '//search line previous to this (any type)
        'var endAtInx = .lexer.getInfoLineIndex(.sourceLineNum-1)
        Dim endAtInx = Me.lexer.getInfoLineIndex(Me.sourceLineNum - 1)

        '// print in-between lines (comments & blank lines)
        'for lineInx=prevCODElineInx+1 to endAtInx
        for lineInx As Integer =prevCODElineInx + 1lineInx to endAtInx
            '.outInfoLineAsComment lineInx
            Me.outInfoLineAsComment(lineInx)
        
        Next
        
     end function
     ' ---------------------------
     Public Function outSourceLinesAsComment (upTo, fromLineNum)

        'if no .lexer.options.comments, return
        if NotMe.lexer.options.comments Then return

        'default fromLineNum = .sourceLineNum // this statement
        if ismissing(fromLineNum) then fromLineNum=Me.sourceLineNum: end if
        'default upTo = .sourceLineNum // this statement
        if ismissing(upTo) then upTo=Me.sourceLineNum: end if

        'var startAtInx = .lexer.getInfoLineIndex(fromLineNum)
        Dim startAtInx = Me.lexer.getInfoLineIndex(fromLineNum)
        'var endAtInx = .lexer.getInfoLineIndex(upTo)
        Dim endAtInx = Me.lexer.getInfoLineIndex(upTo)

        'for lineInx=startAtInx to endAtInx
        for lineInx As Integer =startAtInxlineInx to endAtInx
            '.outInfoLineAsComment lineInx
            Me.outInfoLineAsComment(lineInx)
        
        Next
        
     end function
     ' ---------------------------
     Public Function addSourceMap (mark)

        '.lexer.outCode.addCompleteSourceMap mark, .sourceLineNum
        Me.lexer.outCode.addCompleteSourceMap(mark, Me.sourceLineNum)
     end function
     ' ---------------------------
     Public Function levelIndent ()
'show indented messaged for debugging

        'var indent = 0
        Dim indent = 0
        'var node = this
        Dim node = Me
        'while node.parent into node
        Do whileAssign(node,node.parent)
        
            'indent += 2 //add 2 spaces
            indent += 2
        
        Loop

        'return String.spaces(indent)
        return String.spaces(indent)
     end function
    
    end class 'ASTBase
' -----------
' Module code
' -----------


    'end class ASTBase
    
end module
